This patch adds the current XXH3 checksum algorithms to rsync. They
are not yet finalized, so do NOT use this in a distributed rsync yet!

To use this patch, run these commands for a successful build:

    patch -p1 <patches/xxh3.diff
    ./configure                         (optional if already run)
    make

based-on: 89827e49bcc0296d93aab73a53bb8c7c88baf202
diff --git a/checksum.c b/checksum.c
--- a/checksum.c
+++ b/checksum.c
@@ -26,11 +26,20 @@
  * with this program; if not, visit the http://fsf.org website.
  */
 
+#define PRE_RELEASE_XXHASH 1
+
 #include "rsync.h"
+#ifdef PRE_RELEASE_XXHASH
+#include "xxh3.h"
+#endif
 #ifdef SUPPORT_XXHASH
 #include "xxhash.h"
 #endif
 
+#if defined PRE_RELEASE_XXHASH || XXH_VERSION_NUMBER >= 800
+#define SUPPORT_XXH3 1
+#endif
+
 extern int am_server;
 extern int whole_file;
 extern int checksum_seed;
@@ -40,6 +49,10 @@ extern const char *checksum_choice;
 
 struct name_num_obj valid_checksums = {
 	"checksum", NULL, NULL, 0, 0, {
+#ifdef SUPPORT_XXH3
+		{ CSUM_XXH3_128, "xxh128", NULL },
+		{ CSUM_XXH3_64, "xxh3", NULL },
+#endif
 #ifdef SUPPORT_XXHASH
 		{ CSUM_XXH64, "xxh64", NULL },
 		{ CSUM_XXH64, "xxhash", NULL },
@@ -137,7 +150,10 @@ int csum_len_for_type(int cst, BOOL flist_csum)
 		return MD5_DIGEST_LEN;
 #ifdef SUPPORT_XXHASH
 	  case CSUM_XXH64:
+	  case CSUM_XXH3_64:
 		return 64/8;
+	  case CSUM_XXH3_128:
+		return 128/8;
 #endif
 	  default: /* paranoia to prevent missing case values */
 		exit_cleanup(RERR_UNSUPPORTED);
@@ -162,6 +178,8 @@ int canonical_checksum(int csum_type)
 		return -1;
 #ifdef SUPPORT_XXHASH
 	  case CSUM_XXH64:
+	  case CSUM_XXH3_64:
+	  case CSUM_XXH3_128:
 		return 1;
 #endif
 	  default: /* paranoia to prevent missing case values */
@@ -200,6 +218,17 @@ void get_checksum2(char *buf, int32 len, char *sum)
 	  case CSUM_XXH64:
 		SIVAL64(sum, 0, XXH64(buf, len, checksum_seed));
 		break;
+#endif
+#ifdef SUPPORT_XXH3
+	  case CSUM_XXH3_64:
+		SIVAL64(sum, 0, XXH3_64bits_withSeed(buf, len, checksum_seed));
+		break;
+	  case CSUM_XXH3_128: {
+		XXH128_hash_t digest = XXH3_128bits_withSeed(buf, len, checksum_seed);
+		SIVAL64(sum, 0, digest.low64);
+		SIVAL64(sum, 8, digest.high64);
+		break;
+	  }
 #endif
 	  case CSUM_MD5: {
 		MD5_CTX m5;
@@ -315,6 +344,45 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
 		SIVAL64(sum, 0, XXH64_digest(state));
 		break;
 	  }
+#endif
+#ifdef SUPPORT_XXH3
+	  case CSUM_XXH3_64: {
+		static XXH3_state_t* state = NULL;
+		if (!state && !(state = XXH3_createState()))
+			out_of_memory("file_checksum");
+
+		XXH3_64bits_reset(state);
+
+		for (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)
+			XXH3_64bits_update(state, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);
+
+		remainder = (int32)(len - i);
+		if (remainder > 0)
+			XXH3_64bits_update(state, (uchar *)map_ptr(buf, i, remainder), remainder);
+
+		SIVAL64(sum, 0, XXH3_64bits_digest(state));
+		break;
+	  }
+	  case CSUM_XXH3_128: {
+		XXH128_hash_t digest;
+		static XXH3_state_t* state = NULL;
+		if (!state && !(state = XXH3_createState()))
+			out_of_memory("file_checksum");
+
+		XXH3_128bits_reset(state);
+
+		for (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)
+			XXH3_128bits_update(state, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);
+
+		remainder = (int32)(len - i);
+		if (remainder > 0)
+			XXH3_128bits_update(state, (uchar *)map_ptr(buf, i, remainder), remainder);
+
+		digest = XXH3_128bits_digest(state);
+		SIVAL64(sum, 0, digest.low64);
+		SIVAL64(sum, 8, digest.high64);
+		break;
+	  }
 #endif
 	  case CSUM_MD5: {
 		MD5_CTX m5;
@@ -391,6 +459,9 @@ static union {
 #ifdef SUPPORT_XXHASH
 static XXH64_state_t* xxh64_state;
 #endif
+#ifdef SUPPORT_XXH3
+static XXH3_state_t* xxh3_state;
+#endif
 static int cursum_type;
 
 void sum_init(int csum_type, int seed)
@@ -408,6 +479,18 @@ void sum_init(int csum_type, int seed)
 			out_of_memory("sum_init");
 		XXH64_reset(xxh64_state, 0);
 		break;
+#endif
+#ifdef SUPPORT_XXH3
+	  case CSUM_XXH3_64:
+		if (!xxh3_state && !(xxh3_state = XXH3_createState()))
+			out_of_memory("sum_init");
+		XXH3_64bits_reset(xxh3_state);
+		break;
+	  case CSUM_XXH3_128:
+		if (!xxh3_state && !(xxh3_state = XXH3_createState()))
+			out_of_memory("sum_init");
+		XXH3_128bits_reset(xxh3_state);
+		break;
 #endif
 	  case CSUM_MD5:
 		MD5_Init(&ctx.m5);
@@ -450,6 +533,14 @@ void sum_update(const char *p, int32 len)
 	  case CSUM_XXH64:
 		XXH64_update(xxh64_state, p, len);
 		break;
+#endif
+#ifdef SUPPORT_XXH3
+	  case CSUM_XXH3_64:
+		XXH3_64bits_update(xxh3_state, p, len);
+		break;
+	  case CSUM_XXH3_128:
+		XXH3_128bits_update(xxh3_state, p, len);
+		break;
 #endif
 	  case CSUM_MD5:
 		MD5_Update(&ctx.m5, (uchar *)p, len);
@@ -504,6 +595,17 @@ int sum_end(char *sum)
 	  case CSUM_XXH64:
 		SIVAL64(sum, 0, XXH64_digest(xxh64_state));
 		break;
+#endif
+#ifdef SUPPORT_XXH3
+	  case CSUM_XXH3_64:
+		SIVAL64(sum, 0, XXH3_64bits_digest(xxh3_state));
+		break;
+	  case CSUM_XXH3_128: {
+		XXH128_hash_t digest = XXH3_128bits_digest(xxh3_state);
+		SIVAL64(sum, 0, digest.low64);
+		SIVAL64(sum, 8, digest.high64);
+		break;
+	  }
 #endif
 	  case CSUM_MD5:
 		MD5_Final((uchar *)sum, &ctx.m5);
diff --git a/lib/md-defines.h b/lib/md-defines.h
--- a/lib/md-defines.h
+++ b/lib/md-defines.h
@@ -13,3 +13,5 @@
 #define CSUM_MD4 4
 #define CSUM_MD5 5
 #define CSUM_XXH64 6
+#define CSUM_XXH3_64 7
+#define CSUM_XXH3_128 8
diff --git a/rsync.1.md b/rsync.1.md
--- a/rsync.1.md
+++ b/rsync.1.md
@@ -1474,6 +1474,8 @@ your home directory (remove the '=' for that).
     The checksum options that you may be able to use are:
 
     - `auto` (the default)
+    - `xxh128`
+    - `xxh3`
     - `xxh64` (aka xxhash)
     - `md5`
     - `md4`
