This patch from Sami Farin lets you specify --fsync if you want fsync()
to be called on every file we write.

--- orig/options.c	2005-01-24 01:43:10
+++ options.c	2004-11-27 18:10:44
@@ -38,6 +38,7 @@ int make_backups = 0;
  **/
 int whole_file = -1;
 
+int do_fsync = 0;
 int archive_mode = 0;
 int keep_dirlinks = 0;
 int copy_links = 0;
@@ -251,6 +252,7 @@ void usage(enum logcode F)
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir            make backups into this directory\n");
   rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
+  rprintf(F,"     --fsync                 fsync every written file\n");
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
   rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
   rprintf(F," -d, --dirs                  transfer directories without recursing\n");
@@ -358,6 +360,7 @@ static struct poptOption long_options[] 
   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
   {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
+  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
   {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
   {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
@@ -1227,6 +1230,9 @@ void server_options(char **args,int *arg
 		args[ac++] = tmpdir;
 	}
 
+	if (do_fsync && am_sender)
+		args[ac++] = "--fsync";
+
 	if (basis_dir[0] && am_sender) {
 		/* the server only needs this option if it is not the sender,
 		 *   and it may be an older version that doesn't know this
--- orig/receiver.c	2005-01-24 01:43:10
+++ receiver.c	2004-07-16 20:13:31
@@ -35,6 +35,7 @@ extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int io_error;
+extern int do_fsync;
 extern char *tmpdir;
 extern char *partial_dir;
 extern char *basis_dir[];
@@ -237,6 +238,12 @@ static int receive_data(int f_in, char *
 		exit_cleanup(RERR_FILEIO);
 	}
 
+	if (do_fsync && fd != -1 && fsync(fd) != 0) {
+		rsyserr(FERROR, errno, "fsync failed on %s",
+			full_fname(fname));
+		exit_cleanup(RERR_FILEIO);
+	}
+
 	sum_end(file_sum1);
 
 	if (mapbuf)
--- orig/t_stub.c	2004-07-29 16:08:04
+++ t_stub.c	2004-10-09 04:03:09
@@ -28,6 +28,7 @@
 
 int modify_window = 0;
 int module_id = -1;
+int do_fsync;
 char *partial_dir;
 struct exclude_list_struct server_exclude_list;
 
--- orig/util.c	2005-01-20 23:05:34
+++ util.c	2004-07-03 20:18:13
@@ -33,6 +33,7 @@ extern int module_id;
 extern int modify_window;
 extern char *partial_dir;
 extern struct exclude_list_struct server_exclude_list;
+extern int do_fsync;
 
 int sanitize_paths = 0;
 
@@ -298,6 +299,12 @@ int copy_file(char *source, char *dest, 
 		return -1;
 	}
 
+	if (do_fsync && fsync(ofd) < 0) {
+		rsyserr(FERROR, errno, "fsync failed on %s",
+			full_fname(dest));
+		return -1;
+	}
+
 	return 0;
 }
 
