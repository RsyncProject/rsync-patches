This patch from Sami Farin lets you specify --fsync if you want fsync()
to be called on every file we write.

--- orig/options.c	2005-10-15 16:39:46
+++ options.c	2005-08-27 21:21:34
@@ -41,6 +41,7 @@ int whole_file = -1;
 int append_mode = 0;
 int keep_dirlinks = 0;
 int copy_links = 0;
+int do_fsync = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_perms = 0;
@@ -313,6 +314,7 @@ void usage(enum logcode F)
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
+  rprintf(F,"     --fsync                 fsync every written file\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
@@ -471,6 +473,7 @@ static struct poptOption long_options[] 
   {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
+  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
   {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
@@ -1560,6 +1563,9 @@ void server_options(char **args,int *arg
 		args[ac++] = tmpdir;
 	}
 
+	if (do_fsync && am_sender)
+		args[ac++] = "--fsync";
+
 	if (basis_dir[0] && am_sender) {
 		/* the server only needs this option if it is not the sender,
 		 *   and it may be an older version that doesn't know this
--- orig/receiver.c	2005-09-16 05:41:02
+++ receiver.c	2005-02-20 00:17:37
@@ -38,6 +38,7 @@ extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int io_error;
+extern int do_fsync;
 extern int basis_dir_cnt;
 extern int make_backups;
 extern int cleanup_got_literal;
@@ -319,6 +320,12 @@ static int receive_data(int f_in, char *
 		exit_cleanup(RERR_FILEIO);
 	}
 
+	if (do_fsync && fd != -1 && fsync(fd) != 0) {
+		rsyserr(FERROR, errno, "fsync failed on %s",
+			full_fname(fname));
+		exit_cleanup(RERR_FILEIO);
+	}
+
 	sum_end(file_sum1);
 
 	if (mapbuf)
--- orig/t_stub.c	2005-10-16 22:38:39
+++ t_stub.c	2005-10-18 08:16:12
@@ -29,6 +29,7 @@
 int modify_window = 0;
 int module_id = -1;
 int relative_paths = 0;
+int do_fsync;
 char *partial_dir;
 struct filter_list_struct server_filter_list;
 
--- orig/util.c	2005-10-16 22:38:40
+++ util.c	2005-10-18 08:17:00
@@ -32,6 +32,7 @@ extern int dry_run;
 extern int module_id;
 extern int modify_window;
 extern int relative_paths;
+extern int do_fsync;
 extern char *partial_dir;
 extern struct filter_list_struct server_filter_list;
 
@@ -311,6 +312,12 @@ int copy_file(char *source, char *dest, 
 		return -1;
 	}
 
+	if (do_fsync && fsync(ofd) < 0) {
+		rsyserr(FERROR, errno, "fsync failed on %s",
+			full_fname(dest));
+		return -1;
+	}
+
 	return 0;
 }
 
