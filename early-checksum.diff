This patch changes the way the --checksum option works by having the
receiving side perform a checksum-read of every file in the file list
as the list is received (if the sizes are equal), marking non-matching
items with a flag.  The idea is that the checksum pass on the sender and
the receiver can then happen in parallel instead of having the reciever
to its checksum pass during its normal find-the-different-files pass.

I have benchmarked this a little, and it appears to slow things down
for a local copy, so the old algorithm is used for local copies.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/early-checksum.diff
    ./configure                                 (optional if already run)
    make

--- old/flist.c
+++ new/flist.c
@@ -33,6 +33,7 @@ extern int am_sender;
 extern int inc_recurse;
 extern int do_progress;
 extern int always_checksum;
+extern int pre_checksum;
 extern int module_id;
 extern int ignore_errors;
 extern int numeric_ids;
@@ -850,6 +851,15 @@ static struct file_struct *recv_file_ent
 			memcpy(bp, F_SUM(first), checksum_len);
 		} else
 			read_buf(f, bp, checksum_len);
+		if (pre_checksum && sum_len) {
+			STRUCT_STAT st;
+			char *fname = f_name(file, NULL);
+			if (stat(fname, &st) == 0 && st.st_size == file_length) {
+				file_checksum(fname, tmp_sum, st.st_size);
+				if (memcmp(bp, tmp_sum, checksum_len) != 0)
+					file->flags |= FLAG_SUM_DIFFERS;
+			}
+		}
 	}
 
 	if (S_ISREG(mode) || S_ISLNK(mode))
--- old/generator.c
+++ new/generator.c
@@ -73,6 +73,7 @@ extern int protocol_version;
 extern int file_total;
 extern int fuzzy_basis;
 extern int always_checksum;
+extern int pre_checksum;
 extern int checksum_len;
 extern char *partial_dir;
 extern char *basis_dir[];
@@ -569,7 +570,8 @@ void itemize(struct file_struct *file, i
 
 
 /* Perform our quick-check heuristic for determining if a file is unchanged. */
-int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
+int unchanged_file(char *fn, int fnamecmp_type, struct file_struct *file,
+		   STRUCT_STAT *st)
 {
 	if (st->st_size != F_LENGTH(file))
 		return 0;
@@ -578,6 +580,8 @@ int unchanged_file(char *fn, struct file
 	   of the file time to determine whether to sync */
 	if (always_checksum > 0 && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
+		if (pre_checksum && fnamecmp_type == FNAMECMP_FNAME)
+			return !(file->flags & FLAG_SUM_DIFFERS);
 		file_checksum(fn, sum, st->st_size);
 		return memcmp(sum, F_SUM(file), checksum_len) == 0;
 	}
@@ -816,7 +820,7 @@ static int try_dests_reg(struct file_str
 			match_level = 1;
 			/* FALL THROUGH */
 		case 1:
-			if (!unchanged_file(cmpbuf, file, stp))
+			if (!unchanged_file(cmpbuf, 0, file, stp))
 				continue;
 			best_match = j;
 			match_level = 2;
@@ -1508,7 +1512,7 @@ static void recv_generator(char *fname, 
 		;
 	else if (fnamecmp_type == FNAMECMP_FUZZY)
 		;
-	else if (unchanged_file(fnamecmp, file, &st)) {
+	else if (unchanged_file(fnamecmp, fnamecmp_type, file, &st)) {
 		if (partialptr) {
 			do_unlink(partialptr);
 			handle_partial_dir(partialptr, PDIR_DELETE);
--- old/hlink.c
+++ new/hlink.c
@@ -382,7 +382,7 @@ int hard_link_check(struct file_struct *
 				}
 				break;
 			}
-			if (!unchanged_file(cmpbuf, file, &alt_st))
+			if (!unchanged_file(cmpbuf, 0, file, &alt_st))
 				continue;
 			statret = 1;
 			*stp = alt_st;
--- old/main.c
+++ new/main.c
@@ -46,6 +46,7 @@ extern int module_id;
 extern int copy_links;
 extern int copy_dirlinks;
 extern int keep_dirlinks;
+extern int always_checksum;
 extern int preserve_hard_links;
 extern int protocol_version;
 extern int file_total;
@@ -73,6 +74,9 @@ extern char *password_file;
 extern char curr_dir[MAXPATHLEN];
 extern struct filter_list_struct server_filter_list;
 
+extern char curr_dir[MAXPATHLEN];
+
+int pre_checksum = 0;
 int local_server = 0;
 int new_root_dir = 0;
 mode_t orig_umask = 0;
@@ -793,6 +797,7 @@ static void do_server_recv(int f_in, int
 	struct file_list *flist;
 	char *local_name = NULL;
 	char *dir = NULL;
+	char olddir[sizeof curr_dir];
 	int save_verbose = verbose;
 
 	if (filesfrom_fd >= 0) {
@@ -839,6 +844,10 @@ static void do_server_recv(int f_in, int
 		filesfrom_fd = -1;
 	}
 
+	strlcpy(olddir, curr_dir, sizeof olddir);
+	if (always_checksum && !local_server && argc > 0)
+		pre_checksum = push_dir(argv[0], 0);
+
 	flist = recv_file_list(f_in);
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
@@ -848,6 +857,9 @@ static void do_server_recv(int f_in, int
 		recv_additional_file_list(f_in);
 	verbose = save_verbose;
 
+	if (pre_checksum)
+		pop_dir(olddir);
+
 	if (argc > 0)
 		local_name = get_local_name(flist,argv[0]);
 
@@ -927,6 +939,7 @@ int client_run(int f_in, int f_out, pid_
 {
 	struct file_list *flist = NULL;
 	int exit_code = 0, exit_code2 = 0;
+	char olddir[sizeof curr_dir];
 	char *local_name = NULL;
 
 	cleanup_child_pid = pid;
@@ -1007,12 +1020,19 @@ int client_run(int f_in, int f_out, pid_
 		filesfrom_fd = -1;
 	}
 
+	strlcpy(olddir, curr_dir, sizeof olddir);
+	if (always_checksum && !local_server)
+		pre_checksum = push_dir(argv[0], 0);
+
 	if (write_batch && !am_server)
 		start_write_batch(f_in);
 	flist = recv_file_list(f_in);
 	if (inc_recurse && file_total == 1)
 		recv_additional_file_list(f_in);
 
+	if (pre_checksum)
+		pop_dir(olddir);
+
 	if (flist && flist->count > 0) {
 		local_name = get_local_name(flist, argv[0]);
 
--- old/rsync.h
+++ new/rsync.h
@@ -71,6 +71,7 @@
 #define FLAG_HLINK_LAST (1<<7)	/* receiver/generator */
 #define FLAG_HLINK_DONE (1<<8)	/* receiver/generator */
 #define FLAG_LENGTH64 (1<<9)	/* sender/receiver/generator */
+#define FLAG_SUM_DIFFERS (1<<10)/* receiver/generator */
 
 /* These flags are passed to functions but not stored. */
 
