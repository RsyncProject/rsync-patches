John Taylor's patch for implementing --time-limit and --stop-at, reworked
to be simpler and more efficient by Wayne Davison.

Do we need configure support for mktime() and strptime()?

--- io.c	16 Jan 2004 16:31:47 -0000	1.119
+++ io.c	27 Apr 2004 02:56:33 -0000
@@ -44,6 +44,7 @@ static int io_multiplexing_in;
 static int multiplex_in_fd = -1;
 static int multiplex_out_fd = -1;
 static time_t last_io;
+extern time_t stop_at_utime;
 static int no_flush;
 
 extern int bwlimit;
@@ -125,15 +126,20 @@ static void check_timeout(void)
 {
 	time_t t;
 
-	if (!io_timeout)
+	if (!io_timeout && !stop_at_utime)
 		return;
 
+	t = time(NULL);
+
+	if (stop_at_utime && t >= stop_at_utime) {
+		rprintf(FERROR, "run-time limit exceeded\n");
+		exit_cleanup(RERR_TIMEOUT);
+	}
+
 	if (!last_io) {
-		last_io = time(NULL);
+		last_io = t;
 		return;
 	}
-
-	t = time(NULL);
 
 	if (last_io && io_timeout && (t-last_io) >= io_timeout) {
 		if (!am_server && !am_daemon) {
--- options.c	17 Apr 2004 17:07:23 -0000	1.147
+++ options.c	27 Apr 2004 02:56:33 -0000
@@ -92,6 +92,7 @@ int modify_window = 0;
 int blocking_io = -1;
 int checksum_seed = 0;
 unsigned int block_size = 0;
+time_t stop_at_utime = 0;
 
 
 /** Network address family. **/
@@ -288,6 +289,8 @@ void usage(enum logcode F)
   rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");
   rprintf(F,"     --password-file=FILE    get password from FILE\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
+  rprintf(F,"     --stop-at=YY-MM-DD@HH:MM Stop rsync at year-month-day@hour:minute\n");
+  rprintf(F,"     --time-limit=TIME       Stop rsync after TIME minutes have elapsed\n");
   rprintf(F,"     --write-batch=PREFIX    write batch fileset starting with PREFIX\n");
   rprintf(F,"     --read-batch=PREFIX     read batch fileset starting with PREFIX\n");
   rprintf(F," -h, --help                  show this help screen\n");
@@ -305,7 +308,7 @@ void usage(enum logcode F)
 enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-      OPT_READ_BATCH, OPT_WRITE_BATCH,
+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_STOP_AT, OPT_TIME_LIMIT,
       OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
@@ -377,6 +380,8 @@ static struct poptOption long_options[] 
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
+  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
+  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
@@ -471,6 +476,7 @@ int parse_arguments(int *argc, const cha
 {
 	int opt;
 	char *ref = lp_refuse_options(module_id);
+	struct tm stop_at_tm;
 	const char *arg;
 	poptContext pc;
 
@@ -584,6 +590,37 @@ int parse_arguments(int *argc, const cha
 			return 0;
 #endif
 
+		case OPT_STOP_AT:
+			arg = poptGetOptArg(pc);
+			if (!strptime(arg, "%y-%m-%d@%H:%M", &stop_at_tm)) {
+				snprintf(err_buf, sizeof err_buf,
+				    "invalid --stop-at format: %s\n",
+				    arg);
+				rprintf(FERROR, "ERROR: %s", err_buf);
+				return 0;
+			}
+			stop_at_utime = mktime(&stop_at_tm);
+			if (stop_at_utime < time(NULL)) {
+				snprintf(err_buf, sizeof err_buf,
+				    "--stop-at time is in the past: %s\n",
+				    arg);
+				rprintf(FERROR, "ERROR: %s", err_buf);
+				return 0;
+			}
+			break;
+
+		case OPT_TIME_LIMIT:
+			arg = poptGetOptArg(pc);
+			if ((stop_at_utime = atol(arg) * 60) <= 0) {
+				snprintf(err_buf, sizeof err_buf,
+				    "invalid --time-limit value: %s\n",
+				    arg);
+				rprintf(FERROR, "ERROR: %s", err_buf);
+				return 0;
+			}
+			stop_at_utime += time(NULL);
+			break;
+
 		default:
 			/* A large opt value means that set_refuse_options()
 			 * turned this option off (opt-BASE is its index). */
@@ -881,6 +918,15 @@ void server_options(char **args,int *arg
 
 	if (bwlimit) {
 		if (asprintf(&arg, "--bwlimit=%d", bwlimit) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
+
+	if (stop_at_utime) {
+		long mins = (stop_at_utime - time(NULL)) / 60;
+		if (mins <= 0)
+			mins = 1;
+		if (asprintf(&arg, "--time-limit=%ld", mins) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
--- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
+++ rsync.yo	27 Apr 2004 02:56:35 -0000
@@ -346,6 +346,8 @@ verb(
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
+     --stop-at=YY-MM-DD@HH:MM Stop rsync at year-month-day@hour:minute
+     --time-limit=TIME       Stop rsync after TIME minutes have elapsed
      --write-batch=PREFIX    write batch fileset starting with PREFIX
      --read-batch=PREFIX     read batch fileset starting with PREFIX
  -h, --help                  show this help screen
@@ -888,6 +890,13 @@ of rsync transfers, blocks of data are s
 transfer was too fast, it will wait before sending the next data block. The
 result is an average transfer rate equaling the specified limit. A value
 of zero specifies no limit.
+
+dit(bf(--stop-at=YY-MM-DD@HH:MM)) This option allows you to specify at what
+time to stop rsync, in year-month-day@hour:minute numeric format (e.g.
+04-12-3l@23:59).
+
+dit(bf(--time-limit=TIME)) This option allows you to specify the maximum
+number of minutes rsync will run for.
 
 dit(bf(--write-batch=PREFIX)) Generate a set of files that can be
 transferred as a batch update. Each filename in the set starts with
