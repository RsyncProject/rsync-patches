Depends-On-Patch: g2r-basis-filename.diff

The changes to generator.c were greatly simplified, making the patch
easier to maintain and fixing the failing test in the testsuite.
Very lightly tested.

Be sure to run "make proto" before "make".

--- orig/generator.c	2004-09-20 19:57:58
+++ generator.c	2004-09-23 15:33:08
@@ -43,6 +43,7 @@ extern int ignore_times;
 extern int size_only;
 extern int io_timeout;
 extern int protocol_version;
+extern int fuzzy_basis;
 extern int always_checksum;
 extern char *partial_dir;
 extern char *compare_dest;
@@ -244,6 +245,92 @@ static void generate_and_send_sums(int f
 }
 
 
+static void split_names(char *fname, char **dirname, char **basename)
+{
+	char *slash = strrchr(fname, '/');
+	if (slash) {
+		*dirname = fname;
+		*slash = '\0';
+		*basename = slash+1;
+	} else {
+		*basename = fname;
+		*dirname = ".";
+	}
+}
+
+
+static unsigned int measure_name(const char *name, const char *basename,
+				 const char *ext)
+{
+	int namelen = strlen(name);
+	int extlen = strlen(ext);
+	unsigned int score = 0;
+
+	/* Extensions must match */
+	if (namelen <= extlen || strcmp(name + namelen - extlen, ext) != 0)
+		return 0;
+
+	/* Now score depends on similarity of prefix */
+	for (; *name == *basename && *name; name++, basename++)
+		score++;
+	return score;
+}
+
+
+static int find_fuzzy(const char *fname, char *buf, STRUCT_STAT *st_ptr)
+{
+	DIR *d;
+	struct dirent *di;
+	char *basename, *dirname;
+	char mangled_name[MAXPATHLEN];
+	char bestname[MAXPATHLEN];
+	unsigned int bestscore = 0;
+	const char *ext;
+
+	strlcpy(mangled_name, fname, sizeof mangled_name);
+
+	split_names(mangled_name, &dirname, &basename);
+	if (!(d = opendir(dirname))) {
+		rsyserr(FERROR, errno, "recv_generator opendir(%s)", dirname);
+		return -1;
+	}
+
+	/* Get final extension, eg. .gz; never full basename though. */
+	if (!(ext = strrchr(basename + 1, '.')))
+		ext = basename + strlen(basename); /* ext = "" */
+
+	while ((di = readdir(d)) != NULL) {
+		const char *dname = d_name(di);
+		unsigned int score;
+
+		if (dname[0] == '.' && (dname[1] == '\0'
+		    || (dname[1] == '.' && dname[2] == '\0')))
+			continue;
+
+		score = measure_name(dname, basename, ext);
+		if (verbose > 4) {
+			rprintf(FINFO, "[%s] fuzzy score for %s = %u\n",
+				who_am_i(), dname, score);
+		}
+		if (score > bestscore) {
+			strlcpy(bestname, dname, sizeof bestname);
+			bestscore = score;
+		}
+	}
+	closedir(d);
+
+	/* Found a candidate. */
+	if (bestscore != 0) {
+		pathjoin(buf, MAXPATHLEN, dirname, bestname);
+		if (verbose > 2) {
+			rprintf(FINFO, "[%s] fuzzy match %s->%s\n",
+				who_am_i(), fname, buf);
+		}
+		return link_stat(buf, st_ptr, 0);
+	}
+	return -1;
+}
+
 
 /*
  * Acts on file number @p i from @p flist, whose name is @p fname.
@@ -256,11 +343,11 @@ static void generate_and_send_sums(int f
 static void recv_generator(char *fname, struct file_struct *file, int i,
 			   int f_out, int f_out_name)
 {
-	int fd = -1, f_copy;
+	int fd = -1, f_copy = -1;
 	STRUCT_STAT st, partial_st;
-	struct file_struct *back_file;
+	struct file_struct *back_file = NULL;
 	int statret, stat_errno;
-	char *fnamecmp, *partialptr, *backupptr;
+	char *fnamecmp, *partialptr, *backupptr = NULL;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
 
@@ -468,6 +555,15 @@ static void recv_generator(char *fname, 
 	} else
 		partialptr = NULL;
 
+	if (statret == -1 && fuzzy_basis) {
+		if (find_fuzzy(fname, fnamecmpbuf, &st) == 0
+		    && S_ISREG(st.st_mode)) {
+			statret = 0;
+			fnamecmp = fnamecmpbuf;
+			fnamecmp_type = G2R_FUZZY;
+		}
+	}
+
 	if (statret == -1) {
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
@@ -494,7 +590,7 @@ static void recv_generator(char *fname, 
 		return;
 	}
 
-	if (skip_file(fnamecmp, file, &st)) {
+	if (fnamecmp_type != G2R_FUZZY && skip_file(fnamecmp, file, &st)) {
 		if (fnamecmp_type == G2R_FNAME)
 			set_perms(fname, file, &st, PERMS_REPORT);
 		return;
@@ -553,10 +649,6 @@ prepare_to_open:
 			return;
 		}
 		fnamecmp_type = G2R_BACKUP;
-	} else {
-		backupptr = NULL;
-		back_file = NULL;
-		f_copy = -1;
 	}
 
 	if (verbose > 3) {
@@ -570,6 +662,21 @@ prepare_to_open:
 notify_others:
 	if (f_out_name >= 0) {
 		write_byte(f_out_name, fnamecmp_type);
+		if (fnamecmp_type == G2R_FUZZY) {
+			uchar lenbuf[3], *lb = lenbuf;
+			int len = strlen(fnamecmpbuf);
+			if (len > 0x7F) {
+#if MAXPATHLEN > 0x7FFF
+				*lb++ = len / 0x10000 + 0x80;
+				*lb++ = len / 0x100;
+#else
+				*lb++ = len / 0x100 + 0x80;
+#endif
+			}
+			*lb = len;
+			write_buf(f_out_name, lenbuf, lb - lenbuf + 1);
+			write_buf(f_out_name, fnamecmpbuf, len);
+		}
 		io_flush(NORMAL_FLUSH); /* XXX make this more efficient! */
 	}
 
--- orig/main.c	2004-07-22 00:10:43
+++ main.c	2004-07-22 00:32:31
@@ -48,6 +48,7 @@ extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
 extern int recurse;
+extern int fuzzy_basis;
 extern int relative_paths;
 extern int rsync_port;
 extern int whole_file;
@@ -463,7 +464,7 @@ static int do_recv(int f_in,int f_out,st
 	int pid;
 	int status = 0;
 	int error_pipe[2], name_pipe[2];
-	BOOL need_name_pipe = compare_dest && !dry_run;
+	BOOL need_name_pipe = (compare_dest || fuzzy_basis) && !dry_run;
 
 	/* The receiving side mustn't obey this, or an existing symlink that
 	 * points to an identical file won't be replaced by the referent. */
--- orig/options.c	2004-09-23 17:42:07
+++ options.c	2004-09-23 14:59:46
@@ -85,6 +85,7 @@ int safe_symlinks = 0;
 int copy_unsafe_links = 0;
 int size_only = 0;
 int bwlimit = 0;
+int fuzzy_basis = 0;
 size_t bwlimit_writemax = 0;
 int delete_after = 0;
 int only_existing = 0;
@@ -279,6 +280,7 @@ void usage(enum logcode F)
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --link-dest=DIR         create hardlinks to DIR for unchanged files\n");
+  rprintf(F,"     --fuzzy                 use similar file as basis if basis doesn't exist\n");
   rprintf(F," -P                          equivalent to --partial --progress\n");
   rprintf(F," -z, --compress              compress file data\n");
   rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
@@ -378,6 +380,7 @@ static struct poptOption long_options[] 
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest, 0, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, &compare_dest,  OPT_LINK_DEST, 0, 0 },
+  {"fuzzy",            0,  POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
   {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
@@ -833,6 +836,11 @@ int parse_arguments(int *argc, const cha
 				 link_dest ? "--link-dest" : "--compare-dest");
 			return 0;
 		}
+		if (compare_dest) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--inplace does not yet work with --fuzzy\n");
+			return 0;
+		}
 	} else {
 		if (keep_partial && !partial_dir)
 			partial_dir = getenv("RSYNC_PARTIAL_DIR");
@@ -1099,6 +1107,9 @@ void server_options(char **args,int *arg
 		}
 	}
 
+	if (fuzzy_basis && am_sender)
+		args[ac++] = "--fuzzy";
+
 	*argc = ac;
 	return;
 
--- orig/receiver.c	2004-09-07 21:57:20
+++ receiver.c	2004-07-30 18:21:38
@@ -319,6 +319,27 @@ static int receive_data(int f_in, char *
 }
 
 
+static void read_gen_name(int fd, char *buf)
+{
+	int len = read_byte(fd);
+	if (len & 0x80) {
+#if MAXPATHLEN > 32767
+		uchar lenbuf[2];
+		read_buf(fd, (char *)lenbuf, 2);
+		len = (len & ~0x80) * 0x10000 + lenbuf[0] * 0x100 + lenbuf[1];
+#else
+		len = (len & ~0x80) * 0x100 + read_byte(fd);
+#endif
+	}
+	if (len >= MAXPATHLEN) {
+		rprintf(FERROR, "bogus data on generator name pipe\n");
+		exit_cleanup(RERR_PROTOCOL);
+	}
+
+	read_sbuf(fd, buf, len);
+}
+
+
 static void discard_receive_data(int f_in, OFF_T length)
 {
 	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
@@ -448,6 +469,10 @@ int recv_files(int f_in, struct file_lis
 			case G2R_BACKUP:
 				fnamecmp = get_backup_name(fname);
 				break;
+			case G2R_FUZZY:
+				read_gen_name(f_in_name, fnamecmpbuf);
+				fnamecmp = fnamecmpbuf;
+				break;
 			default:
 				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 					 compare_dest, fname);
--- orig/rsync.h	2004-09-07 21:52:22
+++ rsync.h	2004-09-07 22:02:37
@@ -122,6 +122,7 @@
 #define G2R_FNAME	0x80
 #define G2R_PARTIAL_DIR	0x81
 #define G2R_BACKUP	0x82
+#define G2R_FUZZY	0x83
 
 
 /* Log-message categories.  FLOG is only used on the daemon side to
--- orig/rsync.yo	2004-09-24 16:42:30
+++ rsync.yo	2004-07-03 19:27:25
@@ -356,6 +356,7 @@ verb(
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare received files relative to DIR
      --link-dest=DIR         create hardlinks to DIR for unchanged files
+     --fuzzy                 use similar file as basis if basis is gone
  -P                          equivalent to --partial --progress
  -z, --compress              compress file data
  -C, --cvs-exclude           auto ignore files in the same way CVS does
