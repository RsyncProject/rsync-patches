This patch adds the "xxhash" checksum method that can then be selected
using the --checksum-choice=xxhash option.

Based on a patch by Bill Wichser.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/xxhash.diff
    ./configure
    make

based-on: be7af36c517757d7ff9562275ebfc04355613dff
diff --git a/checksum.c b/checksum.c
--- a/checksum.c
+++ b/checksum.c
@@ -20,6 +20,9 @@
  */
 
 #include "rsync.h"
+#ifdef SUPPORT_XXHASH
+#include "xxhash.h"
+#endif
 
 extern int checksum_seed;
 extern int protocol_version;
@@ -32,6 +35,7 @@ extern char *checksum_choice;
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
 #define CSUM_MD5 5
+#define CSUM_XXHASH 6
 
 int xfersum_type = 0; /* used for the file transfer checksums */
 int checksum_type = 0; /* used for the pre-transfer (--checksum) checksums */
@@ -68,6 +72,10 @@ int parse_csum_name(const char *name, int len)
 		return CSUM_MD5;
 	if (len == 4 && strncasecmp(name, "none", 4) == 0)
 		return CSUM_NONE;
+#ifdef SUPPORT_XXHASH
+	if (len == 6 && strncasecmp(name, "xxhash", 6) == 0)
+		return CSUM_XXHASH;
+#endif
 
 	rprintf(FERROR, "unknown checksum name: %s\n", name);
 	exit_cleanup(RERR_UNSUPPORTED);
@@ -88,6 +96,10 @@ int csum_len_for_type(int cst, BOOL flist_csum)
 		return MD4_DIGEST_LEN;
 	  case CSUM_MD5:
 		return MD5_DIGEST_LEN;
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH:
+		return sizeof (XXH64_hash_t);
+#endif
 	  default: /* paranoia to prevent missing case values */
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
@@ -184,6 +196,11 @@ void get_checksum2(char *buf, int32 len, char *sum)
 		mdfour_result(&m, (uchar *)sum);
 		break;
 	  }
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH: 
+		SIVAL64(sum, 0, XXH64(buf, len, checksum_seed));
+		break;
+#endif
 	  default: /* paranoia to prevent missing case values */
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
@@ -240,6 +257,34 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
 
 		mdfour_result(&m, (uchar *)sum);
 		break;
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH: {
+		XXH64_state_t* state = XXH64_createState();
+		if (state == NULL)
+			out_of_memory("file_checksum xx64");
+
+		if (XXH64_reset(state, 0) == XXH_ERROR) {
+			rprintf(FERROR, "error resetting XXH64 seed");
+			exit_cleanup(RERR_STREAMIO);
+		}
+
+		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+			XXH_errorcode const updateResult =
+			    XXH64_update(state, (uchar *)map_ptr(buf, i, CSUM_CHUNK), CSUM_CHUNK);
+			if (updateResult == XXH_ERROR) {
+				rprintf(FERROR, "error computing XX64 hash");
+				exit_cleanup(RERR_STREAMIO);
+			}
+		}
+		remainder = (int32)(len - i);
+		if (remainder > 0)
+			XXH64_update(state, (uchar *)map_ptr(buf, i, CSUM_CHUNK), remainder);
+		SIVAL64(sum, 0, XXH64_digest(state));
+
+		XXH64_freeState(state);
+		break;
+	  }
+#endif
 	  default:
 		rprintf(FERROR, "invalid checksum-choice for the --checksum option (%d)\n", checksum_type);
 		exit_cleanup(RERR_UNSUPPORTED);
@@ -252,6 +297,9 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
 static int32 sumresidue;
 static md_context md;
 static int cursum_type;
+#ifdef SUPPORT_XXHASH
+XXH64_state_t* xxh64_state = NULL;
+#endif
 
 void sum_init(int csum_type, int seed)
 {
@@ -277,6 +325,19 @@ void sum_init(int csum_type, int seed)
 		SIVAL(s, 0, seed);
 		sum_update(s, 4);
 		break;
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH:
+		if (xxh64_state == NULL) {
+			xxh64_state = XXH64_createState();
+			if (xxh64_state == NULL)
+				out_of_memory("sum_init xxh64");
+		}
+		if (XXH64_reset(xxh64_state, 0) == XXH_ERROR) {
+			rprintf(FERROR, "error resetting XXH64 state");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		break;
+#endif
 	  case CSUM_NONE:
 		break;
 	  default: /* paranoia to prevent missing case values */
@@ -326,6 +387,14 @@ void sum_update(const char *p, int32 len)
 		if (sumresidue)
 			memcpy(md.buffer, p, sumresidue);
 		break;
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH:
+		if (XXH64_update(xxh64_state, p, len) == XXH_ERROR) {
+			rprintf(FERROR, "error computing XX64 hash");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		break;
+#endif
 	  case CSUM_NONE:
 		break;
 	  default: /* paranoia to prevent missing case values */
@@ -354,6 +423,11 @@ int sum_end(char *sum)
 			mdfour_update(&md, (uchar *)md.buffer, sumresidue);
 		mdfour_result(&md, (uchar *)sum);
 		break;
+#ifdef SUPPORT_XXHASH
+	  case CSUM_XXHASH:
+		SIVAL64(sum, 0, XXH64_digest(xxh64_state));
+		break;
+#endif
 	  case CSUM_NONE:
 		*sum = '\0';
 		break;
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -350,9 +350,21 @@ AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
     sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
     popt.h popt/popt.h linux/falloc.h netinet/in_systm.h netinet/ip.h \
-    zlib.h)
+    zlib.h xxhash.h)
 AC_HEADER_MAJOR_FIXED
 
+dnl Do you want to disable use of xxhash checksums
+AC_ARG_ENABLE([xxhash],
+	AS_HELP_STRING([--disable-xxhash],[disable xxhash checksums]))
+AH_TEMPLATE([SUPPORT_XXHASH],
+[Undefine if you do not want xxhash checksums.  By default this is defined.])
+if test x"$enable_xxhash" != x"no"; then
+    if test x"$ac_cv_header_xxhash_h" = x"yes"; then
+	AC_SEARCH_LIBS(XXH64_createState, xxhash)
+	AC_DEFINE(SUPPORT_XXHASH)
+    fi
+fi
+
 AC_CACHE_CHECK([if makedev takes 3 args],rsync_cv_MAKEDEV_TAKES_3_ARGS,[
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -578,6 +578,7 @@ static void print_rsync_version(enum logcode f)
 	char const *links = "no ";
 	char const *iconv = "no ";
 	char const *ipv6 = "no ";
+	char const *xxhash = "no ";
 	STRUCT_STAT *dumstat;
 
 #if SUBPROTOCOL_VERSION != 0
@@ -614,6 +615,9 @@ static void print_rsync_version(enum logcode f)
 #ifdef CAN_SET_SYMLINK_TIMES
 	symtimes = "";
 #endif
+#ifdef SUPPORT_XXHASH
+	xxhash = "";
+#endif
 
 	rprintf(f, "%s  version %s  protocol version %d%s\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION, subprotocol);
@@ -627,8 +631,8 @@ static void print_rsync_version(enum logcode f)
 		(int)(sizeof (int64) * 8));
 	rprintf(f, "    %ssocketpairs, %shardlinks, %ssymlinks, %sIPv6, batchfiles, %sinplace,\n",
 		got_socketpair, hardlinks, links, ipv6, have_inplace);
-	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes, %sprealloc\n",
-		have_inplace, acls, xattrs, iconv, symtimes, prealloc);
+	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes, %sprealloc, %sxxhash\n",
+		have_inplace, acls, xattrs, iconv, symtimes, prealloc, xxhash);
 
 #ifdef MAINTAINER_MODE
 	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
diff --git a/rsync.yo b/rsync.yo
--- a/rsync.yo
+++ b/rsync.yo
@@ -1371,11 +1371,12 @@ batch-writing option is in effect.
 
 dit(bf(--checksum-choice=STR)) This option overrides the checksum algorithms.
 If one algorithm name is specified, it is used for both the transfer checksums
-and (assuming bf(--checksum) is specified) the pre-transfer checksumming. If two
+and (assuming bf(--checksum) is specified) the pre-transfer checksums. If two
 comma-separated names are supplied, the first name affects the transfer
-checksums, and the second name affects the pre-transfer checksumming.
+checksums, and the second name affects the pre-transfer checksums.
 
-The algorithm choices are "auto", "md4", "md5", and "none".  If "none" is
+The algorithm choices are "auto", "md4", "md5", "xxhash", and "none".
+If "none" is
 specified for the first name, the bf(--whole-file) option is forced on and no
 checksum verification is performed on the transferred data.  If "none" is
 specified for the second name, the bf(--checksum) option cannot be used. The
