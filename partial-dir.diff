You must run "make proto" after applying this patch.

--- orig/cleanup.c	2004-07-20 21:36:07
+++ cleanup.c	2004-07-27 23:32:17
@@ -111,7 +111,8 @@ void _exit_cleanup(int code, const char 
 		}
 	}
 
-	if (cleanup_got_literal && cleanup_fname && keep_partial) {
+	if (cleanup_got_literal && cleanup_fname && keep_partial
+	    && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {
 		char *fname = cleanup_fname;
 		cleanup_fname = NULL;
 		if (cleanup_fd_r != -1)
--- orig/generator.c	2004-07-26 16:24:55
+++ generator.c	2004-07-27 03:58:55
@@ -42,6 +42,7 @@ extern int size_only;
 extern int io_timeout;
 extern int protocol_version;
 extern int always_checksum;
+extern char *partial_dir;
 extern char *compare_dest;
 extern int link_dest;
 extern int whole_file;
@@ -418,7 +419,18 @@ static void recv_generator(char *fname, 
 		return;
 	}
 
-	fnamecmp = fname;
+	if (partial_dir) {
+		STRUCT_STAT st2;
+		if (!(fnamecmp = partial_dir_fname(fname)))
+			fnamecmp = fname;
+		else if (link_stat(fnamecmp, &st2, 0) == 0
+		    && S_ISREG(st2.st_mode)) {
+			statret = 0;
+			st = st2;
+		} else
+			fnamecmp = fname;
+	} else
+		fnamecmp = fname;
 
 	if (statret == -1 && compare_dest != NULL) {
 		/* try the file at compare_dest instead */
--- orig/options.c	2004-07-23 17:16:13
+++ options.c	2004-07-26 16:43:48
@@ -118,6 +118,7 @@ unsigned int backup_dir_remainder;
 
 char *backup_suffix = NULL;
 char *tmpdir = NULL;
+char *partial_dir = NULL;
 char *compare_dest = NULL;
 char *config_file = NULL;
 char *shell_cmd = NULL;
@@ -268,6 +269,7 @@ void usage(enum logcode F)
   rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
+  rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
@@ -383,6 +385,7 @@ static struct poptOption long_options[] 
   {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
   {"progress",         0,  POPT_ARG_NONE,   &do_progress, 0, 0, 0 },
   {"partial",          0,  POPT_ARG_NONE,   &keep_partial, 0, 0, 0 },
+  {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
@@ -718,6 +721,8 @@ int parse_arguments(int *argc, const cha
 			(*argv)[i] = alloc_sanitize_path((*argv)[i], NULL);
 		if (tmpdir)
 			tmpdir = alloc_sanitize_path(tmpdir, curr_dir);
+		if (partial_dir)
+			partial_dir = alloc_sanitize_path(partial_dir, curr_dir);
 		if (compare_dest)
 			compare_dest = alloc_sanitize_path(compare_dest, curr_dir);
 		if (backup_dir)
@@ -770,6 +775,11 @@ int parse_arguments(int *argc, const cha
 
 	if (inplace) {
 #if HAVE_FTRUNCATE
+		if (partial_dir) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--inplace cannot be used with --partial-dir\n");
+			return 0;
+		}
 		keep_partial = 0;
 #else
 		snprintf(err_buf, sizeof err_buf,
@@ -777,7 +787,8 @@ int parse_arguments(int *argc, const cha
 			 am_server ? "server" : "client");
 		return 0;
 #endif
-	}
+	} else if (partial_dir)
+		keep_partial = 1;
 
 	if (files_from) {
 		char *colon;
@@ -969,7 +980,10 @@ void server_options(char **args,int *arg
 		args[ac++] = arg;
 	}
 
-	if (keep_partial)
+	if (partial_dir && am_sender) {
+		args[ac++] = "--partial-dir";
+		args[ac++] = partial_dir;
+	} else if (keep_partial)
 		args[ac++] = "--partial";
 
 	if (force_delete)
--- orig/receiver.c	2004-07-26 16:20:00
+++ receiver.c	2004-07-27 23:26:20
@@ -38,6 +38,7 @@ extern int preserve_perms;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
+extern char *partial_dir;
 extern char *compare_dest;
 extern int make_backups;
 extern int do_progress;
@@ -342,7 +343,7 @@ int recv_files(int f_in, struct file_lis
 	char *fname, fbuf[MAXPATHLEN];
 	char template[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
-	char *fnamecmp;
+	char *fnamecmp, *partialptr;
 	char fnamecmpbuf[MAXPATHLEN];
 	struct file_struct *file;
 	struct stats initial_stats;
@@ -410,8 +411,6 @@ int recv_files(int f_in, struct file_lis
 		if (verbose > 2)
 			rprintf(FINFO, "recv_files(%s)\n", safe_fname(fname));
 
-		fnamecmp = fname;
-
 		if (read_batch) {
 			while (i > next_gen_i) {
 				next_gen_i = read_int(batch_gen_fd);
@@ -438,9 +437,22 @@ int recv_files(int f_in, struct file_lis
 			continue;
 		}
 
+		if (partial_dir) {
+			if ((partialptr = partial_dir_fname(fname)) != NULL)
+				fnamecmp = partialptr;
+			else
+				fnamecmp = fname;
+		} else
+			fnamecmp = partialptr = fname;
+
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
+		if (fd1 == -1 && fnamecmp != fname) {
+			fnamecmp = fname;
+			fd1 = do_open(fnamecmp, O_RDONLY, 0);
+		}
+
 		if (fd1 == -1 && compare_dest != NULL) {
 			/* try the file at compare_dest instead */
 			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
@@ -528,7 +540,8 @@ int recv_files(int f_in, struct file_lis
 				continue;
 			}
 
-			cleanup_set(fnametmp, fname, file, fd1, fd2);
+			if (partialptr)
+				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
 		}
 
 		if (!am_server && verbose) /* log the transfer */
@@ -548,10 +561,20 @@ int recv_files(int f_in, struct file_lis
 			exit_cleanup(RERR_FILEIO);
 		}
 
-		if (recv_ok || keep_partial || inplace)
+		if (recv_ok || inplace)
 			finish_transfer(fname, fnametmp, file, recv_ok);
-		else
+		else if (keep_partial && partialptr
+		    && handle_partial_dir(partialptr, PDIR_CREATE))
+			finish_transfer(partialptr, fnametmp, file, 0);
+		else {
+			partialptr = NULL;
 			do_unlink(fnametmp);
+		}
+
+		if (partialptr != fname && fnamecmp == partialptr && recv_ok) {
+			do_unlink(partialptr);
+			handle_partial_dir(partialptr, PDIR_DELETE);
+		}
 
 		cleanup_disable();
 
@@ -559,9 +582,13 @@ int recv_files(int f_in, struct file_lis
 			int msgtype = csum_length == SUM_LENGTH || read_batch ?
 				FERROR : FINFO;
 			if (msgtype == FERROR || verbose) {
-				char *errstr, *redostr;
-				char *keptstr = keep_partial || inplace ?
-					"retain" : "discard";
+				char *errstr, *redostr, *keptstr;
+				if (!(keep_partial && partialptr) && !inplace)
+					keptstr = "discarded";
+				else if (partial_dir)
+					keptstr = "put into partial-dir";
+				else
+					keptstr = "retained";
 				if (msgtype == FERROR) {
 					errstr = "ERROR";
 					redostr = "";
@@ -570,7 +597,7 @@ int recv_files(int f_in, struct file_lis
 					redostr = " (will try again)";
 				}
 				rprintf(msgtype,
-					"%s: %s failed verification -- update %sed%s.\n",
+					"%s: %s failed verification -- update %s%s.\n",
 					errstr, safe_fname(fname),
 					keptstr, redostr);
 			}
--- orig/rsync.h	2004-07-23 17:16:13
+++ rsync.h	2004-07-27 23:23:54
@@ -115,6 +115,9 @@
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
 
+#define PDIR_CREATE	1
+#define PDIR_DELETE	0
+
 
 /* Log-message categories.  FLOG is only used on the daemon side to
  * output messages to the log file. */
--- orig/rsync.yo	2004-07-24 16:52:10
+++ rsync.yo	2004-07-27 23:48:13
@@ -317,6 +317,7 @@ verb(
      --ignore-errors         delete even if there are I/O errors
      --max-delete=NUM        don't delete more than NUM files
      --partial               keep partially transferred files
+     --partial-dir=DIR       put a partially transferred file into DIR
      --force                 force deletion of dirs even if not empty
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set I/O timeout in seconds
@@ -865,6 +866,26 @@ it is more desirable to keep partially t
 --partial option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
 
+dit(bf(--partial-dir=DIR)) Turns on --partial mode, but tells rsync to
+put a partially transferred file into DIR instead of writing out the
+file to the destination dir.  Rsync will also use a file found in this
+dir as data to speed up the transfer (i.e. when you redo the send after
+rsync creates a partial file).
+
+Rsync will create the dir if it is missing, so feel free to use a
+relative path (such as "--partial-dir=.rsync-partial") if you want the
+file put into a directory created in the destination file's directory
+(rsync will also try to remove the DIR if a partial file was found to
+already exist and the DIR was specified as a relative path).
+
+If you are deleting files on the destination and your partial-dir is
+inside the destination hierarchy, you should use --delete-after or add an
+exclude to prevent the partial file from being deleted before it can be
+used (e.g. "--exclude=.rsync-partial/").
+
+IMPORTANT: do NOT use a directory for the --partial-dir that is writable
+by other users (such as /tmp) -- it is insecure!
+
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
--- orig/t_stub.c	2004-05-15 20:10:13
+++ t_stub.c	2004-07-24 17:00:35
@@ -28,6 +28,7 @@
 
 int modify_window = 0;
 int module_id = -1;
+char *partial_dir;
 struct exclude_list_struct server_exclude_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
--- orig/util.c	2004-07-26 16:33:24
+++ util.c	2004-07-27 23:25:20
@@ -31,6 +31,7 @@ extern int verbose;
 extern int dry_run;
 extern int module_id;
 extern int modify_window;
+extern char *partial_dir;
 extern struct exclude_list_struct server_exclude_list;
 
 int sanitize_paths = 0;
@@ -970,6 +971,66 @@ char *full_fname(const char *fn)
 	return result;
 }
 
+static char partial_fname[MAXPATHLEN];
+
+char *partial_dir_fname(const char *fname)
+{
+	char *t = partial_fname;
+	int sz = sizeof partial_fname;
+	const char *fn;
+
+	if ((fn = strrchr(fname, '/')) != NULL) {
+		fn++;
+		if (*partial_dir != '/') {
+			int len = fn - fname;
+			strncpy(t, fname, len); /* safe */
+			t += len;
+			sz -= len;
+		}
+	} else
+		fn = fname;
+	if ((int)pathjoin(t, sz, partial_dir, fn) >= sz)
+		return NULL;
+
+	return partial_fname;
+}
+
+/* If no --partial-dir option was specified, we don't need to do anything
+ * (the partial-dir is essentially '.'), so just return success. */
+int handle_partial_dir(const char *fname, int create)
+{
+	char *fn, *dir;
+
+	if (fname != partial_fname)
+		return 1;
+	if (!create && *partial_dir == '/')
+		return 1;
+	if (!(fn = strrchr(partial_fname, '/')))
+		return 1;
+
+	*fn = '\0';
+	dir = partial_fname;
+	if (create) {
+		STRUCT_STAT st;
+#if SUPPORT_LINKS
+		int statret = do_lstat(dir, &st);
+#else
+		int statret = do_stat(dir, &st);
+#endif
+		if (statret == 0 && !S_ISDIR(st.st_mode)) {
+			if (do_unlink(dir) < 0)
+				return 0;
+			statret = -1;
+		}
+		if (statret < 0 && do_mkdir(dir, 0700) < 0)
+			return 0;
+	} else
+		do_rmdir(dir);
+	*fn = '/';
+
+	return 1;
+}
+
 /** We need to supply our own strcmp function for file list comparisons
    to ensure that signed/unsigned usage is consistent between machines. */
 int u_strcmp(const char *cs1, const char *cs2)
