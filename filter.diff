After applying this patch and running configure, you MUST run this
command before "make":

    make proto

This patch adds the ability to merge rules into your excludes/includes
using a ". FILE" idiom.  If you specify a name with a preceding -p
option, that filename will be looked for in every subdirectory that
rsync visits, and the rules found in that subdirectory's file will
affect either just that dir or, if -i is specified, that dir and its
subdirs.

For example:

  rsync -av --exclude='. -pi .excl' from/ to

The above will look for a file named ".excl" in every directory of the
hierarchy that rsync visits, and it will exclude (by default) names
based on the rules found therein.  If one of the .excl files contains
this:

  + *.c
  . -p .excl2
  . -i .excl3
  *.o

Then the file ".excl2" will also be read in from the current dir and all
its subdirs (due to the -p option) with each file's rules only affecting
the file's current directory.  The file ".excl3" would just be read in
for the current dir (because it was not specified with the -p option),
but its rules would be inherited by all its subdirectories (because of
the -i option).

..wayne..

--- orig/exclude.c	2004-08-05 23:16:37
+++ exclude.c	2004-08-06 22:58:08
@@ -27,17 +27,66 @@
 #include "rsync.h"
 
 extern int verbose;
+extern int am_sender;
 extern int eol_nulls;
 extern int list_only;
 extern int recurse;
+extern int io_error;
+extern int module_id;
+extern int delete_mode;
+extern int delete_excluded;
+extern int sanitize_paths;
 
 extern char curr_dir[];
+extern unsigned int curr_dir_len;
 
 struct exclude_list_struct exclude_list = { 0, 0, "" };
-struct exclude_list_struct local_exclude_list = { 0, 0, "per-dir .cvsignore " };
 struct exclude_list_struct server_exclude_list = { 0, 0, "server " };
 char *exclude_path_prefix = NULL;
 
+struct mergelist_save_struct {
+    struct exclude_list_struct *array;
+    int count;
+};
+
+static char dirbuf[MAXPATHLEN];
+static unsigned int dirbuf_offset = 0;
+static struct exclude_struct **mergelist_parents;
+static int mergelist_cnt = 0;
+static int mergelist_size = 0;
+static int initialized_mergelist_cnt = -1;
+
+/* Each exclude_list_struct describes a singly-linked list by keeping track
+ * of both the head and tail pointers.  The list is slightly unusual in that
+ * a parent-dir's content can be appended to the end of the local list in a
+ * special way:  the last item in the local list has its "next" pointer set
+ * to point to the inherited list, but the local list's tail pointer points
+ * at the end of the local list.  Thus, if the local list is empty, the head
+ * will be pointing at the inherited content but the tail will be NULL.  To
+ * help you visualize this, here are the possible list arrangements:
+ *
+ * Completely Empty                     Local Content Only
+ * ==================================   ====================================
+ * head -> NULL                         head -> Local1 -> Local2 -> NULL
+ * tail -> NULL                         tail -------------^
+ *
+ * Inherited Content Only               Both Local and Inherited Content
+ * ==================================   ====================================
+ * head -> Parent1 -> Parent2 -> NULL   head -> L1 -> L2 -> P1 -> P2 -> NULL
+ * tail -> NULL                         tail ---------^
+ *
+ * This means that anyone wanting to traverse the whole list to USE it just
+ * needs to start at the head and use the "next" pointers until it goes
+ * NULL.  To add new local content, we insert the item after the tail item
+ * and update the tail (obviously, if "tail" was NULL, we insert it at the
+ * head).  To clear the local list, WE MUST NOT FREE THE INHERITED CONTENT
+ * because it is shared between the current list and our parent list(s).
+ * The easiest way to handle this is to simply truncate the list after the
+ * tail item and then free the local list from the head.  When inheriting
+ * the list for a new local dir, we just save off the exclude_list_struct
+ * values (so we can pop back to them later) and set the tail to NULL.
+ */
+
 /** Build an exclude structure given an exclude pattern. */
 static void make_exclude(struct exclude_list_struct *listp, const char *pat,
 			 unsigned int pat_len, unsigned int mflags)
@@ -46,6 +95,31 @@ static void make_exclude(struct exclude_
 	const char *cp;
 	unsigned int ex_len;
 
+	if (verbose > 2) {
+		rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s%sclude)\n",
+			who_am_i(), (int)pat_len, pat, listp->debug_type,
+			mflags & MATCHFLG_MERGE_FILE ? "FILE " : "",
+			mflags & MATCHFLG_INCLUDE ? "in" : "ex");
+	}
+
+	if (mflags & MATCHFLG_MERGE_FILE) {
+		int i;
+		/* If the local include file was already mentioned, don't
+		 * add it again. */
+		for (i = 0; i < mergelist_cnt; i++) {
+			struct exclude_struct *ex = mergelist_parents[i];
+			if (strlen(ex->pattern) == pat_len
+			    && memcmp(ex->pattern, pat, pat_len) == 0)
+				return;
+		}
+		if ((pat_len == 10 || (pat_len > 10 && pat[pat_len-11] == '/'))
+		    && strncmp(pat+pat_len-10, ".cvsignore", 10) == 0) {
+			mflags |= MATCHFLG_CVSIGNORE;
+			mflags &= ~(MATCHFLG_INCLUDE | MATCHFLG_INHERIT);
+		} else
+			mflags &= ~MATCHFLG_CVSIGNORE;
+	}
+
 	ret = new(struct exclude_struct);
 	if (!ret)
 		out_of_memory("make_exclude");
@@ -81,14 +155,40 @@ static void make_exclude(struct exclude_
 		mflags |= MATCHFLG_DIRECTORY;
 	}
 
-	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
-		ret->slash_cnt++;
+	if (mflags & MATCHFLG_MERGE_FILE) {
+		struct exclude_list_struct *lp
+		    = new_array(struct exclude_list_struct, 1);
+		if (!lp)
+			out_of_memory("make_exclude");
+		lp->head = lp->tail = NULL;
+		if ((cp = strrchr(ret->pattern, '/')) != NULL)
+			cp++;
+		else
+			cp = ret->pattern;
+		if (asprintf(&lp->debug_type, "per-dir %s ", cp) < 0)
+			out_of_memory("make_exclude");
+		ret->u.mergelist = lp;
+		if (mergelist_cnt == mergelist_size) {
+			mergelist_size += 5;
+			mergelist_parents = realloc_array(mergelist_parents,
+						struct exclude_struct *,
+						mergelist_size);
+			if (!mergelist_parents)
+				out_of_memory("make_exclude");
+		}
+		mergelist_parents[mergelist_cnt++] = ret;
+	} else {
+		for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
+			ret->u.slash_cnt++;
+	}
 
 	ret->match_flags = mflags;
 
-	if (!listp->tail)
+	if (!listp->tail) {
+		ret->next = listp->head;
 		listp->head = listp->tail = ret;
-	else {
+	} else {
+		ret->next = listp->tail->next;
 		listp->tail->next = ret;
 		listp->tail = ret;
 	}
@@ -96,22 +196,244 @@ static void make_exclude(struct exclude_
 
 static void free_exclude(struct exclude_struct *ex)
 {
+	if (ex->match_flags & MATCHFLG_MERGE_FILE) {
+		free(ex->u.mergelist->debug_type);
+		free(ex->u.mergelist);
+	}
 	free(ex->pattern);
 	free(ex);
 }
 
-void clear_exclude_list(struct exclude_list_struct *listp)
+static void clear_exclude_list(struct exclude_list_struct *listp)
 {
-	struct exclude_struct *ent, *next;
-
-	for (ent = listp->head; ent; ent = next) {
-		next = ent->next;
-		free_exclude(ent);
+	if (listp->tail) {
+		struct exclude_struct *ent, *next;
+		/* Truncate any inherited items from the local list. */
+		listp->tail->next = NULL;
+		/* Now free everything that is left. */
+		for (ent = listp->head; ent; ent = next) {
+			next = ent->next;
+			free_exclude(ent);
+		}
 	}
 
 	listp->head = listp->tail = NULL;
 }
 
+/* This returns a fully expanded filename for the merge-file name if the
+ * name has any slashes in it, otherwise it returns the original name. */
+static char *parse_merge_name(const char *merge_file, unsigned int *len_ptr)
+{
+	static char buf[MAXPATHLEN];
+	char *fn, tmpbuf[MAXPATHLEN];
+	unsigned int fn_len, cd_len;
+
+	cd_len = dirbuf_offset && *dirbuf == '/' ? 0 : curr_dir_len + 1;
+	if (cd_len && *merge_file != '/') {
+		const char *p;
+		if (len_ptr) {
+			for (p = merge_file + *len_ptr;
+			     --p > merge_file && *p != '/'; ) {}
+		} else
+			p = strchr(merge_file, '/');
+		if (!p || p == merge_file)
+			return (char *)merge_file;
+	}
+
+	fn = *merge_file == '/' ? buf : tmpbuf;
+	if (sanitize_paths) {
+		/* null-terminate the name if it isn't already */
+		if (len_ptr && merge_file[*len_ptr]) {
+			char *to = fn == buf ? tmpbuf : buf;
+			strlcpy(to, merge_file, *len_ptr + 1);
+			merge_file = to;
+		}
+		dirbuf[dirbuf_offset] = '\0';
+		if (!sanitize_path(fn, merge_file, dirbuf)) {
+			rprintf(FERROR, "merge filename overflows: %s\n",
+				merge_file);
+			return NULL;
+		}
+	} else {
+		strlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);
+		clean_fname(fn);
+	}
+	
+	if (*fn == '/')
+		return fn;
+
+	fn_len = strlen(fn);
+	if (cd_len + dirbuf_offset + fn_len >= MAXPATHLEN) {
+		rprintf(FERROR, "merge filename overflows: %s\n", fn);
+		return NULL;
+	}
+	if (cd_len) {
+		memcpy(buf, curr_dir, curr_dir_len);
+		buf[curr_dir_len] = '/';
+	}
+	if (dirbuf_offset)
+		memcpy(buf + cd_len, dirbuf, dirbuf_offset);
+	memcpy(buf + cd_len + dirbuf_offset, fn, fn_len + 1);
+	fn_len = clean_fname(buf);
+	if (len_ptr)
+		*len_ptr = fn_len;
+
+	return buf;
+}
+
+static void prep_merge_file(struct exclude_struct *ex,
+			    struct exclude_list_struct *lp, int flags,
+			    char *dir, unsigned int dirlen)
+{
+	char buf[MAXPATHLEN];
+	char *x, *y, *fn = ex->pattern;
+
+	if (!(fn = parse_merge_name(fn, NULL)) || *fn != '/')
+		return;
+
+	x = strrchr(fn, '/');
+	*x = '\0';
+	if (dir[dirlen]) /* avoid writing to a read-only string */
+		dir[dirlen] = '\0';
+	pathjoin(dirbuf, MAXPATHLEN, curr_dir, dir);
+	if (dirlen == 2 && *dir == '.') {
+		int len = strlen(dirbuf);
+		dirbuf[len-2] = '\0';
+	}
+	if (!*fn)
+		fn = "/";
+	if (*fn == '/')
+		strlcpy(buf, fn, MAXPATHLEN);
+	else
+		pathjoin(buf, MAXPATHLEN, dirbuf, fn);
+	fn = x + 1;
+
+	clean_fname(buf);
+	if (!*buf || buf[1])
+		strlcat(buf, "/", MAXPATHLEN);
+	for (x = buf, y = dirbuf; *x && *x == *y; x++, y++) {}
+	if (*x)
+		y += strlen(y);
+
+	while (*y) {
+		char save[MAXPATHLEN];
+		strlcpy(save, y, MAXPATHLEN);
+		dirbuf_offset = y - dirbuf;
+		strlcpy(x, fn, MAXPATHLEN - (x - buf));
+		lp->tail = NULL;
+		add_exclude_file(lp, buf, flags);
+		strlcpy(y, save, MAXPATHLEN);
+		while ((*x++ = *y++) != '/') {}
+	}
+
+	if (dirlen == 2 && *dir == '.') /* dir[dirlen-1] is always '/' */
+		dirbuf_offset = 0;
+	else
+		dirbuf_offset = dirlen;
+	memcpy(dirbuf, dir, dirbuf_offset);
+
+	x = ex->pattern;
+	ex->pattern = strdup(fn);
+	free(x);
+}
+
+void *push_local_excludes(char *dir, unsigned int dirlen)
+{
+	struct mergelist_save_struct *push;
+	struct exclude_list_struct *ap;
+	int i;
+
+	/* Make it easy to construct the full path for a merge-file that was
+	 * specified with a relative path by saving off the current dir. */
+	if (dirlen == 2 && *dir == '.') /* dir[dirlen-1] is always '/' */
+		dirbuf_offset = 0;
+	else
+		dirbuf_offset = dirlen;
+	memcpy(dirbuf, dir, dirbuf_offset);
+
+
+	if (!(push = new_array(struct mergelist_save_struct, 1)))
+		out_of_memory("push_local_excludes");
+
+	push->count = mergelist_cnt;
+	push->array = new_array(struct exclude_list_struct, mergelist_cnt);
+	if (!push->array)
+		out_of_memory("push_local_excludes");
+
+	for (i = 0, ap = push->array; i < mergelist_cnt; i++) {
+		memcpy(ap++, mergelist_parents[i]->u.mergelist,
+		       sizeof (struct exclude_list_struct));
+	}
+
+	/* Note: add_exclude_file() might increase mergelist_cnt, so keep
+	 * this loop separate from the above loop. */
+	for (i = 0; i < mergelist_cnt; i++) {
+		struct exclude_struct *ex = mergelist_parents[i];
+		struct exclude_list_struct *lp = ex->u.mergelist;
+		int flags;
+
+		if (verbose > 2) {
+			rprintf(FINFO, "[%s] pushing %sexclude list\n",
+				who_am_i(), lp->debug_type);
+		}
+
+		if (ex->match_flags & MATCHFLG_CVSIGNORE)
+			flags = XFLG_WORD_SPLIT | XFLG_WORDS_ONLY;
+		else {
+			flags = ex->match_flags & MATCHFLG_INCLUDE
+			    ? XFLG_DEF_INCLUDE : 0;
+		}
+
+		if (initialized_mergelist_cnt < i) {
+			prep_merge_file(ex, lp, flags, dir, dirlen);
+			initialized_mergelist_cnt = i;
+		}
+
+		if (!(ex->match_flags & MATCHFLG_INHERIT))
+			lp->head = NULL;
+		lp->tail = NULL;
+		if (strlcpy(dirbuf +  dirbuf_offset, ex->pattern,
+		    MAXPATHLEN - dirbuf_offset) < MAXPATHLEN - dirbuf_offset)
+			add_exclude_file(lp, dirbuf, flags);
+		else {
+			io_error |= IOERR_GENERAL;
+			rprintf(FINFO,
+			    "cannot add local excludes in long-named directory %s\n",
+			    full_fname(dirbuf));
+		}
+	}
+
+	return (void*)push;
+}
+
+void pop_local_excludes(void *mem)
+{
+	struct mergelist_save_struct *pop = (struct mergelist_save_struct*)mem;
+	struct exclude_list_struct *ap;
+	int i;
+
+	for (i = mergelist_cnt; i-- > 0; ) {
+		struct exclude_struct *ex = mergelist_parents[i];
+		struct exclude_list_struct *lp = ex->u.mergelist;
+
+		if (verbose > 2) {
+			rprintf(FINFO, "[%s] popping %sexclude list\n",
+				who_am_i(), lp->debug_type);
+		}
+
+		clear_exclude_list(lp);
+	}
+
+	mergelist_cnt = initialized_mergelist_cnt = pop->count;
+	for (i = 0, ap = pop->array; i < mergelist_cnt; i++) {
+		memcpy(mergelist_parents[i]->u.mergelist, ap++,
+		       sizeof (struct exclude_list_struct));
+	}
+
+	free(pop->array);
+	free(pop);
+}
+
 static int check_one_exclude(char *name, struct exclude_struct *ex,
                              int name_is_dir)
 {
@@ -122,7 +444,7 @@ static int check_one_exclude(char *name,
 	/* If the pattern does not have any slashes AND it does not have
 	 * a "**" (which could match a slash), then we just match the
 	 * name portion of the path. */
-	if (!ex->slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
+	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
 	}
@@ -133,7 +455,8 @@ static int check_one_exclude(char *name,
 		name = full_name;
 	}
 
-	if (!name[0]) return 0;
+	if (!name[0])
+		return 0;
 
 	if (ex->match_flags & MATCHFLG_DIRECTORY && !name_is_dir)
 		return 0;
@@ -148,9 +471,9 @@ static int check_one_exclude(char *name,
 	if (ex->match_flags & MATCHFLG_WILD) {
 		/* A non-anchored match with an infix slash and no "**"
 		 * needs to match the last slash_cnt+1 name elements. */
-		if (!match_start && ex->slash_cnt
+		if (!match_start && ex->u.slash_cnt
 		    && !(ex->match_flags & MATCHFLG_WILD2)) {
-			int cnt = ex->slash_cnt + 1;
+			int cnt = ex->u.slash_cnt + 1;
 			for (p = name + strlen(name) - 1; p >= name; p--) {
 				if (*p == '/' && !--cnt)
 					break;
@@ -221,6 +544,13 @@ int check_exclude(struct exclude_list_st
 	struct exclude_struct *ent;
 
 	for (ent = listp->head; ent; ent = ent->next) {
+		if (ent->match_flags & MATCHFLG_MERGE_FILE) {
+			int rc = check_exclude(ent->u.mergelist, name,
+					       name_is_dir);
+			if (rc)
+				return rc;
+			continue;
+		}
 		if (check_one_exclude(name, ent, name_is_dir)) {
 			report_exclude_result(name, ent, name_is_dir,
 					      listp->debug_type);
@@ -253,12 +583,41 @@ static const char *get_exclude_tok(const
 		p = (const char *)s;
 	}
 
-	/* Is this a '+' or '-' followed by a space (not whitespace)? */
+	/* Check for a +/-/. followed by a space (not whitespace). */
 	if (!(xflags & XFLG_WORDS_ONLY)
-	    && (*s == '-' || *s == '+') && s[1] == ' ') {
+	    && (*s == '-' || *s == '+' || *s == '.') && s[1] == ' ') {
 		if (*s == '+')
 			mflags |= MATCHFLG_INCLUDE;
+		else if (*s == '.') {
+			mflags |= MATCHFLG_MERGE_FILE;
+			if (xflags & XFLG_DEF_INCLUDE)
+				mflags |= MATCHFLG_INCLUDE;
+			while (s[2] == '-') {
+				s += 2;
+				do {
+					switch (*++s) {
+					case 'i':
+						mflags |= MATCHFLG_INHERIT;
+						break;
+					case 'p':
+						mflags |= MATCHFLG_PERDIR_MERGE;
+						break;
+					case '-':
+						if (s[1] == ' ')
+							goto done;
+					default:
+						rprintf(FERROR,
+						    "invalid merge options: %s\n",
+						    p);
+						exit_cleanup(RERR_SYNTAX);
+					}
+				} while (s[1] != ' ');
+			}
+		}
+	    done:
 		s += 2;
+		if (mflags & MATCHFLG_MERGE_FILE && *s == '.' && s[1] == '/')
+			s += 2;
 	} else if (xflags & XFLG_DEF_INCLUDE)
 		mflags |= MATCHFLG_INCLUDE;
 
@@ -292,9 +651,15 @@ void add_exclude(struct exclude_list_str
 	cp = pattern;
 	pat_len = 0;
 	while (1) {
+		/* Remember that the returned string is NOT '\0' terminated! */
 		cp = get_exclude_tok(cp + pat_len, &pat_len, &mflags, xflags);
 		if (!pat_len)
 			break;
+		if (pat_len >= MAXPATHLEN) {
+			rprintf(FERROR, "discarding over-long exclude: %s\n",
+				cp);
+			continue;
+		}
 
 		if (mflags & MATCHFLG_CLEAR_LIST) {
 			if (verbose > 2) {
@@ -306,13 +671,23 @@ void add_exclude(struct exclude_list_str
 			continue;
 		}
 
-		make_exclude(listp, cp, pat_len, mflags);
-
-		if (verbose > 2) {
-			rprintf(FINFO, "[%s] add_exclude(%.*s, %s%sclude)\n",
-				who_am_i(), (int)pat_len, cp, listp->debug_type,
-				mflags & MATCHFLG_INCLUDE ? "in" : "ex");
+		if (mflags & MATCHFLG_MERGE_FILE) {
+			if (mflags & MATCHFLG_PERDIR_MERGE) {
+				if (dirbuf_offset && *dirbuf == '/') {
+					if (!(cp = parse_merge_name(cp, &pat_len)))
+						continue;
+					make_exclude(listp, cp, pat_len, mflags);
+					continue;
+				}
+			} else {
+				if (!(cp = parse_merge_name(cp, &pat_len)))
+					continue;
+				add_exclude_file(listp, cp, xflags | XFLG_FATAL_ERRORS);
+				continue;
+			}
 		}
+
+		make_exclude(listp, cp, pat_len, mflags);
 	}
 }
 
@@ -321,7 +696,7 @@ void add_exclude_file(struct exclude_lis
 		      int xflags)
 {
 	FILE *fp;
-	char line[MAXPATHLEN+3]; /* Room for "x " prefix and trailing slash. */
+	char line[MAXPATHLEN+7]; /* Room for prefix chars and trailing slash. */
 	char *eob = line + sizeof line - 1;
 	int word_split = xflags & XFLG_WORD_SPLIT;
 
@@ -343,6 +718,11 @@ void add_exclude_file(struct exclude_lis
 		return;
 	}
 
+	if (verbose > 2) {
+		rprintf(FINFO, "[%s] add_exclude_file(%s,%d)\n",
+			who_am_i(), fname, xflags);
+	}
+
 	while (1) {
 		char *s = line;
 		int ch, overflow = 0;
@@ -402,7 +782,21 @@ void send_exclude_list(int f)
 		if (ent->match_flags & MATCHFLG_INCLUDE) {
 			write_int(f, l + 2);
 			write_buf(f, "+ ", 2);
-		} else if ((*p == '-' || *p == '+') && p[1] == ' ') {
+		} else if (ent->match_flags & MATCHFLG_MERGE_FILE) {
+			char buf[32], *op = buf;
+			*op++ = '.';
+			*op++ = ' ';
+			if (ent->match_flags & MATCHFLG_PERDIR_MERGE) {
+				*op++ = '-';
+				*op++ = 'p';
+				if (ent->match_flags & MATCHFLG_INHERIT)
+					*op++ = 'i';
+				*op++ = ' ';
+			}
+			write_int(f, l + (op - buf));
+			write_buf(f, buf, op - buf);
+		} else if ((*p == '-' || *p == '+' || *p == '.')
+		    && p[1] == ' ') {
 			write_int(f, l + 2);
 			write_buf(f, "- ", 2);
 		} else
@@ -443,6 +837,7 @@ void add_cvs_excludes(void)
 	char fname[MAXPATHLEN];
 	char *p;
 
+	add_exclude(&exclude_list, ". -p .cvsignore", 0);
 	add_exclude(&exclude_list, default_cvsignore,
 		    XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
 
--- orig/flist.c	2004-08-05 21:57:29
+++ flist.c	2004-08-06 20:52:26
@@ -39,10 +39,9 @@ extern int module_id;
 extern int ignore_errors;
 extern int numeric_ids;
 
-extern int cvs_exclude;
-
 extern int recurse;
 extern char curr_dir[MAXPATHLEN];
+extern unsigned int curr_dir_len;
 extern char *files_from;
 extern int filesfrom_fd;
 
@@ -66,7 +65,6 @@ extern int list_only;
 
 extern struct exclude_list_struct exclude_list;
 extern struct exclude_list_struct server_exclude_list;
-extern struct exclude_list_struct local_exclude_list;
 
 int io_error;
 
@@ -221,8 +219,6 @@ int link_stat(const char *path, STRUCT_S
  */
 static int check_exclude_file(char *fname, int is_dir, int exclude_level)
 {
-	int rc;
-
 #if 0 /* This currently never happens, so avoid a useless compare. */
 	if (exclude_level == NO_EXCLUDES)
 		return 0;
@@ -244,10 +240,7 @@ static int check_exclude_file(char *fnam
 	if (exclude_level != ALL_EXCLUDES)
 		return 0;
 	if (exclude_list.head
-	    && (rc = check_exclude(&exclude_list, fname, is_dir)) != 0)
-		return rc < 0;
-	if (local_exclude_list.head
-	    && check_exclude(&local_exclude_list, fname, is_dir) < 0)
+	    && check_exclude(&exclude_list, fname, is_dir) < 0)
 		return 1;
 	return 0;
 }
@@ -954,15 +947,7 @@ void send_file_name(int f, struct file_l
 
 	if (recursive && S_ISDIR(file->mode)
 	    && !(file->flags & FLAG_MOUNT_POINT)) {
-		struct exclude_list_struct last_list = local_exclude_list;
-		local_exclude_list.head = local_exclude_list.tail = NULL;
 		send_directory(f, flist, f_name_to(file, fbuf));
-		if (verbose > 2) {
-			rprintf(FINFO, "[%s] popping %sexclude list\n",
-				who_am_i(), local_exclude_list.debug_type);
-		}
-		clear_exclude_list(&local_exclude_list);
-		local_exclude_list = last_list;
 	}
 }
 
@@ -973,6 +958,7 @@ static void send_directory(int f, struct
 	struct dirent *di;
 	char fname[MAXPATHLEN];
 	unsigned int offset;
+	void *save_excludes;
 	char *p;
 
 	d = opendir(dir);
@@ -996,18 +982,7 @@ static void send_directory(int f, struct
 		offset++;
 	}
 
-	if (cvs_exclude) {
-		if (strlcpy(p, ".cvsignore", MAXPATHLEN - offset)
-		    < MAXPATHLEN - offset) {
-			add_exclude_file(&local_exclude_list, fname,
-					 XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
-		} else {
-			io_error |= IOERR_GENERAL;
-			rprintf(FINFO,
-				"cannot cvs-exclude in long-named directory %s\n",
-				full_fname(fname));
-		}
-	}
+	save_excludes = push_local_excludes(fname, offset);
 
 	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
@@ -1028,6 +1003,8 @@ static void send_directory(int f, struct
 		rsyserr(FERROR, errno, "readdir(%s)", dir);
 	}
 
+	pop_local_excludes(save_excludes);
+
 	closedir(d);
 }
 
@@ -1047,6 +1024,7 @@ struct file_list *send_file_list(int f, 
 	char *p, *dir, olddir[sizeof curr_dir];
 	char lastpath[MAXPATHLEN] = "";
 	struct file_list *flist;
+	void *first_push = NULL;
 	int64 start_write;
 	int use_ff_fd = 0;
 
@@ -1067,6 +1045,14 @@ struct file_list *send_file_list(int f, 
 				exit_cleanup(RERR_FILESELECT);
 			}
 			use_ff_fd = 1;
+			if (curr_dir_len < MAXPATHLEN - 1) {
+				char buf[MAXPATHLEN];
+				strcpy(buf, curr_dir);
+				buf[curr_dir_len] = '/';
+				buf[curr_dir_len+1] = '\0';
+				first_push = push_local_excludes(buf,
+				    curr_dir_len+1);
+			}
 		}
 	}
 
@@ -1097,6 +1083,22 @@ struct file_list *send_file_list(int f, 
 			}
 		}
 
+		if (!first_push) {
+			char ch;
+			if ((p = strrchr(fname, '/')) != NULL) {
+				dir = fname;
+				p++;
+			} else {
+				dir = "./";
+				p = dir + 2;
+			}
+			if ((ch = *p) != '\0')
+				*p = '\0';
+			first_push = push_local_excludes(dir, p - dir);
+			if (ch)
+				*p = ch;
+		}
+
 		if (link_stat(fname, &st, keep_dirlinks) != 0) {
 			if (f != -1) {
 				io_error |= IOERR_GENERAL;
--- orig/options.c	2004-08-05 21:57:29
+++ options.c	2004-08-05 21:57:19
@@ -389,6 +389,7 @@ static struct poptOption long_options[] 
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
+  {0,                 'E', POPT_ARG_NONE,   0,              'E', 0, 0 },
   {0,                 'P', POPT_ARG_NONE,   0,              'P', 0, 0 },
   {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
@@ -589,6 +590,11 @@ int parse_arguments(int *argc, const cha
 			am_sender = 1;
 			break;
 
+		case 'E':
+			add_exclude(&exclude_list,
+				    ". -ip /.rsync-excludes", 0);
+			break;
+
 		case 'P':
 			do_progress = 1;
 			keep_partial = 1;
--- orig/rsync.h	2004-08-03 15:41:32
+++ rsync.h	2004-08-06 06:23:10
@@ -499,11 +499,18 @@ struct map_struct {
 #define MATCHFLG_INCLUDE	(1<<4) /* this is an include, not an exclude */
 #define MATCHFLG_DIRECTORY	(1<<5) /* this matches only directories */
 #define MATCHFLG_CLEAR_LIST 	(1<<6) /* this item is the "!" token */
+#define MATCHFLG_MERGE_FILE	(1<<7) /* specifies a file to merge */
+#define MATCHFLG_CVSIGNORE	(1<<8) /* parse this as a .cvsignore file */
+#define MATCHFLG_PERDIR_MERGE	(1<<9) /* content is inherited by subdirs */
+#define MATCHFLG_INHERIT	(1<<10)/* content is inherited by subdirs */
 struct exclude_struct {
 	struct exclude_struct *next;
 	char *pattern;
 	unsigned int match_flags;
-	int slash_cnt;
+	union {
+		int slash_cnt;
+		struct exclude_list_struct *mergelist;
+	} u;
 };
 
 struct exclude_list_struct {
--- orig/rsync.yo	2004-08-03 15:34:32
+++ rsync.yo	2004-08-06 17:05:29
@@ -335,6 +335,7 @@ verb(
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     don't exclude patterns listed in FILE
      --files-from=FILE       read FILE for list of source-file names
+ -E                          same as --exclude='. -pi /.rsync-excludes'
  -0  --from0                 all file lists are delimited by nulls
      --version               print version number
      --daemon                run as an rsync daemon
@@ -1086,6 +1087,11 @@ itemize(
   then it is always considered an exclude pattern, even if specified as
   part of an include option. The prefix is discarded before matching.
 
+  it() if the pattern starts with ". " (a dot followed by a space) then its
+  pattern is taken to be a merge file that is read in to supplement the
+  current rules.  See the section on MERGING EXCLUDE FILES for more
+  information.
+
   it() if the pattern is a single exclamation mark ! then the current
   include/exclude list is reset, removing all previously defined patterns.
 )
@@ -1138,6 +1144,106 @@ itemize(
   it would be excluded by the "*")
 )
 
+manpagesection(MERGING EXCLUDE FILES)
+
+You can merge whole files into an exclude file by specifying a rule that
+starts with a ". " (a dot followed by a space) and putting a filename in
+place of the pattern.  The filename may be preceded by one or more options:
+
+startdit()
+
+dit(bf(-i)) All subdirectories of the current directory inherit the rules we
+read in from this file.  Only affects a per-directory merge file.  The
+rules read in are prefixed to the inherited rules from a parent directory,
+which gives the newest rules a higher priority than the inherited rules.
+
+Note also that you can eliminate all the inherited rules for a directory
+and its subdirectories by putting the list-clearing token ! at the start of
+a per-directory file.  This only clears the rules in the current sub-list,
+not all the rules.
+
+dit(bf(-p)) Make the file a per-directory merge-file.  Rsync will scan
+every directory that it traverses for the named file, merging its contents
+when the file exists.  Without this option rsync just merges the rules into
+the parent file, giving them the same attributes as the parent.
+
+dit(bf(--)) End the scanning of options.  Useful if you want to specify a
+filename that begins with a dash.
+
+enddit()
+
+Here's an example exclude file (which you'd specify via the normal
+--exclude-from=FILE option):
+
+verb(
+    . /home/user/.global_excludes
+    *.gz
+    . -pi .excl
+    + *.[ch]
+    *.o
+)
+
+This will merge the contents of the /home/user/.global_excludes file at the
+start of the list and also turns the ".excl" filename into a per-directory
+exclude file.  The rules read in from the .global_excludes file affect all
+the directories because it is is being merged into an --exclude-from
+option.  The rules merged from each directory's .excl file are inherited
+by each directory's subdirectories because the -i option was specified
+(without -i the rules would only affect the directory where they were read
+in).  All the merged rules default to being exclude rules because an
+exclude statement was used to specify them.
+
+Note also that the parsing of any merge-file named ".cvsignore" is always
+done in a CVS-compatible manner, even if -C wasn't specified.  This means
+that its rules are always excludes (even if an include option specified the
+file), tokens are split on whitespace, the rules are never inherited, and
+no special characters are honored (e.g. no comments, no "!", etc.).
+
+Additionally, you can affect where the --cvs-exclude (-C) option's
+inclusion of the per-directory .cvsignore file gets placed into your rules
+by adding your own explicit per-directory merge rule for ".cvsignore".
+Without this rsync would add its this rule at the end of all your other
+rules (giving it a lower priority than your command-line rules).  For
+example, specifying this:
+
+verb(
+  rsync -avC --exclude='. -p .cvsignore' --exclude-from=foo a/ b
+)
+
+will merge all the per-directory .cvsignore rules at the start of your list
+rather than at the end.  This allows their dir-specific rules to supersede
+your rules instead of being subservient to them.  (The global rules taken
+from the $HOME/.cvsignore file and from $CVSIGNORE are not repositioned by
+this.)
+
+If a per-directory merge file is specified with a path that is a parent
+directory of the first transfer directory, rsync will scan all the parent
+dirs from that starting point to the transfer directory for the indicated
+per-directory file.  For instance, the -E option is an abbreviation for
+this command:
+
+verb(
+  --exclude='. -pi /.rsync-excludes'
+)
+
+That exclude tells rsync to scan for the file .rsync-excludes in all
+directories from the root up through the source of the transfer.  For an
+rsync daemon, the root dir is always the module's "path" setting, not the
+root of the filesystem (unless the two are the same).
+
+Some examples of this pre-scanning for per-directory files:
+
+verb(
+  rsync -avE /src/path/ /dest/dir
+  rsync -av --exclude='. -p ../../.rsync-excludes' /src/path/ /dest/dir
+  rsync -av --exclude='. -pi .rsync-excludes' /src/path/ /dest/dir
+)
+
+The first two commands above will look for .rsync-excludes in "/" and
+"/src" before the normal scan begins looking for the file in "/src/path"
+and its subdirectories.  The last command above just starts scanning
+from "/src/path".
+
 manpagesection(BATCH MODE)
 
 bf(Note:) Batch mode should be considered experimental in this version
--- orig/testsuite/exclude.test	2004-05-29 21:25:45
+++ testsuite/exclude.test	2004-08-06 09:02:29
@@ -23,19 +23,47 @@ export HOME CVSIGNORE
 makepath "$fromdir/foo/down/to/you"
 makepath "$fromdir/bar/down/to/foo/too"
 makepath "$fromdir/mid/for/foo/and/that/is/who"
+cat >"$fromdir/.excl" <<EOF
+.excl
+*.bak
+*.old
+*.junk
+EOF
 echo kept >"$fromdir/foo/file1"
 echo removed >"$fromdir/foo/file2"
 echo cvsout >"$fromdir/foo/file2.old"
+cat >"$fromdir/foo/.excl" <<EOF
++ .excl
+- file1
+EOF
+cat >"$fromdir/bar/.excl" <<EOF
+home-cvs-exclude
+. -pi .excl2
++ to
+EOF
 echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
+cat >"$fromdir/bar/down/to/.excl2" <<EOF
+.excl2
+EOF
 echo keeper >"$fromdir/bar/down/to/foo/file1"
 echo cvsout >"$fromdir/bar/down/to/foo/file1.bak"
 echo gone >"$fromdir/bar/down/to/foo/file3"
 echo lost >"$fromdir/bar/down/to/foo/file4"
 echo cvsout >"$fromdir/bar/down/to/foo/file4.junk"
 echo smashed >"$fromdir/bar/down/to/foo/to"
+cat >"$fromdir/bar/down/to/foo/.excl2" <<EOF
++ *.junk
+EOF
+# This one should be ineffectual
+cat >"$fromdir/mid/.excl2" <<EOF
+extra
+EOF
 echo cvsout >"$fromdir/mid/one-in-one-out"
 echo one-in-one-out >"$fromdir/mid/.cvsignore"
 echo cvsin >"$fromdir/mid/one-for-all"
+cat >"$fromdir/mid/.excl" <<EOF
+. -p .cvsignore
+EOF
 echo cvsin >"$fromdir/mid/for/one-in-one-out"
 echo expunged >"$fromdir/mid/for/foo/extra"
 echo retained >"$fromdir/mid/for/foo/keep"
@@ -100,5 +128,24 @@ $RSYNC -av --existing --include='*/' --e
 checkit "$RSYNC -avvC --exclude-from=\"$excl\" \
     --delete-excluded \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
 
+# Modify the chk dir for our merge-exclude test and then tweak the dir times.
+
+rm "$chkdir"/.excl
+rm "$chkdir"/foo/file1
+rm "$chkdir"/bar/.excl
+rm "$chkdir"/bar/down/to/.excl2
+rm "$chkdir"/bar/down/to/foo/.excl2
+rm "$chkdir"/mid/.excl
+cp -p "$fromdir"/bar/down/to/foo/*.junk "$chkdir"/bar/down/to/foo
+cp -p "$fromdir"/bar/down/to/foo/to "$chkdir"/bar/down/to/foo
+
+$RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
+
+# Now, test if rsync excludes the same files, this time with a merge-exclude
+# file.
+
+checkit "$RSYNC -avv --exclude='. -pi .excl' --exclude-from=\"$excl\" \
+    --delete-excluded \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
