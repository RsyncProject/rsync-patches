This patch provides --fileflags, which preserves the st_flags stat() field.
Modified from a patch that was written by Rolf Grossmann.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/fileflags.diff
    ./configure                         (optional if already run)
    make

based-on: d4fc18f3755987ccea6e7f43609f862aa0254c5a
diff --git a/compat.c b/compat.c
--- a/compat.c
+++ b/compat.c
@@ -38,12 +38,14 @@ extern int checksum_seed;
 extern int basis_dir_cnt;
 extern int prune_empty_dirs;
 extern int protocol_version;
+extern int force_change;
 extern int protect_args;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_atimes;
 extern int preserve_acls;
 extern int preserve_xattrs;
+extern int preserve_fileflags;
 extern int xfer_flags_as_varint;
 extern int need_messages_from_generator;
 extern int delete_mode, delete_before, delete_during, delete_after;
@@ -75,7 +77,7 @@ int inplace_partial = 0;
 int do_negotiated_strings = 0;
 
 /* These index values are for the file-list's extra-attribute array. */
-int pathname_ndx, depth_ndx, atimes_ndx, uid_ndx, gid_ndx, acls_ndx, xattrs_ndx, unsort_ndx;
+int pathname_ndx, depth_ndx, atimes_ndx, uid_ndx, gid_ndx, fileflags_ndx, acls_ndx, xattrs_ndx, unsort_ndx;
 
 int receiver_symlink_times = 0; /* receiver can set the time on a symlink */
 int sender_symlink_iconv = 0;	/* sender should convert symlink content */
@@ -469,6 +471,8 @@ void setup_protocol(int f_out,int f_in)
 		uid_ndx = ++file_extra_cnt;
 	if (preserve_gid)
 		gid_ndx = ++file_extra_cnt;
+	if (preserve_fileflags || (force_change && !am_sender))
+		fileflags_ndx = ++file_extra_cnt;
 	if (preserve_acls && !am_sender)
 		acls_ndx = ++file_extra_cnt;
 	if (preserve_xattrs)
@@ -624,6 +628,10 @@ void setup_protocol(int f_out,int f_in)
 		want_xattr_optim = protocol_version >= 31 && !(compat_flags & CF_AVOID_XATTR_OPTIM);
 		proper_seed_order = compat_flags & CF_CHKSUM_SEED_FIX ? 1 : 0;
 		xfer_flags_as_varint = compat_flags & CF_VARINT_FLIST_FLAGS ? 1 : 0;
+		if (!xfer_flags_as_varint && preserve_fileflags) {
+			fprintf(stderr, "Both rsync versions must be at least 3.2.0 for --fileflags.\n");
+			exit_cleanup(RERR_PROTOCOL);
+		}
 		if (am_sender) {
 			receiver_symlink_times = am_server
 			    ? strchr(client_info, 'L') != NULL
diff --git a/delete.c b/delete.c
--- a/delete.c
+++ b/delete.c
@@ -25,6 +25,7 @@
 extern int am_root;
 extern int make_backups;
 extern int max_delete;
+extern int force_change;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
@@ -97,8 +98,12 @@ static enum delret delete_dir_contents(char *fname, uint16 flags)
 		}
 
 		strlcpy(p, fp->basename, remainder);
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change)
+			make_mutable(fname, fp->mode, F_FFLAGS(fp), force_change);
+#endif
 		if (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)
-			do_chmod(fname, fp->mode | S_IWUSR);
+			do_chmod(fname, fp->mode | S_IWUSR, NO_FFLAGS);
 		/* Save stack by recursing to ourself directly. */
 		if (S_ISDIR(fp->mode)) {
 			if (delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
@@ -139,11 +144,18 @@ enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
 	}
 
 	if (flags & DEL_NO_UID_WRITE)
-		do_chmod(fbuf, mode | S_IWUSR);
+		do_chmod(fbuf, mode | S_IWUSR, NO_FFLAGS);
 
 	if (S_ISDIR(mode) && !(flags & DEL_DIR_IS_EMPTY)) {
 		/* This only happens on the first call to delete_item() since
 		 * delete_dir_contents() always calls us w/DEL_DIR_IS_EMPTY. */
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change) {
+			STRUCT_STAT st;
+			if (x_lstat(fbuf, &st, NULL) == 0)
+				make_mutable(fbuf, st.st_mode, st.st_flags, force_change);
+		}
+#endif
 		ignore_perishable = 1;
 		/* If DEL_RECURSE is not set, this just reports emptiness. */
 		ret = delete_dir_contents(fbuf, flags);
diff --git a/flist.c b/flist.c
--- a/flist.c
+++ b/flist.c
@@ -52,6 +52,7 @@ extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_specials;
+extern int preserve_fileflags;
 extern int delete_during;
 extern int missing_args;
 extern int eol_nulls;
@@ -382,6 +383,9 @@ static void send_file_entry(int f, const char *fname, struct file_struct *file,
 {
 	static time_t modtime, atime;
 	static mode_t mode;
+#ifdef SUPPORT_FILEFLAGS
+	static uint32 fileflags;
+#endif
 #ifdef SUPPORT_HARD_LINKS
 	static int64 dev;
 #endif
@@ -425,6 +429,14 @@ static void send_file_entry(int f, const char *fname, struct file_struct *file,
 		xflags |= XMIT_SAME_MODE;
 	else
 		mode = file->mode;
+#ifdef SUPPORT_FILEFLAGS
+	if (preserve_fileflags) {
+		if (F_FFLAGS(file) == fileflags)
+			xflags |= XMIT_SAME_FLAGS;
+		else
+			fileflags = F_FFLAGS(file);
+	}
+#endif
 
 	if (preserve_devices && IS_DEVICE(mode)) {
 		if (protocol_version < 28) {
@@ -575,6 +587,10 @@ static void send_file_entry(int f, const char *fname, struct file_struct *file,
 		write_varint(f, F_MOD_NSEC(file));
 	if (!(xflags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
+#ifdef SUPPORT_FILEFLAGS
+	if (preserve_fileflags && !(xflags & XMIT_SAME_FLAGS))
+		write_int(f, (int)fileflags);
+#endif
 	if (atimes_ndx && !S_ISDIR(mode) && !(xflags & XMIT_SAME_ATIME))
 		write_varlong(f, atime, 4);
 	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
@@ -666,6 +682,9 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 {
 	static int64 modtime, atime;
 	static mode_t mode;
+#ifdef SUPPORT_FILEFLAGS
+	static uint32 fileflags;
+#endif
 #ifdef SUPPORT_HARD_LINKS
 	static int64 dev;
 #endif
@@ -775,6 +794,10 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 			mode = first->mode;
 			if (atimes_ndx && !S_ISDIR(mode))
 				atime = F_ATIME(first);
+#ifdef SUPPORT_FILEFLAGS
+			if (preserve_fileflags)
+				fileflags = F_FFLAGS(first);
+#endif
 			if (preserve_uid)
 				uid = F_OWNER(first);
 			if (preserve_gid)
@@ -826,6 +849,10 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 
 	if (chmod_modes && !S_ISLNK(mode) && mode)
 		mode = tweak_mode(mode, chmod_modes);
+#ifdef SUPPORT_FILEFLAGS
+	if (preserve_fileflags && !(xflags & XMIT_SAME_FLAGS))
+		fileflags = (uint32)read_int(f);
+#endif
 
 	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
 		if (protocol_version < 30)
@@ -984,6 +1011,10 @@ static struct file_struct *recv_file_entry(int f, struct file_list *flist, int x
 	}
 #endif
 	file->mode = mode;
+#ifdef SUPPORT_FILEFLAGS
+	if (preserve_fileflags)
+		F_FFLAGS(file) = fileflags;
+#endif
 	if (preserve_uid)
 		F_OWNER(file) = uid;
 	if (preserve_gid) {
@@ -1383,6 +1414,10 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 	}
 #endif
 	file->mode = st.st_mode;
+#if defined SUPPORT_FILEFLAGS || defined SUPPORT_FORCE_CHANGE
+	if (fileflags_ndx)
+		F_FFLAGS(file) = st.st_flags;
+#endif
 	if (preserve_uid)
 		F_OWNER(file) = st.st_uid;
 	if (preserve_gid)
diff --git a/generator.c b/generator.c
--- a/generator.c
+++ b/generator.c
@@ -43,8 +43,10 @@ extern int write_devices;
 extern int preserve_specials;
 extern int preserve_hard_links;
 extern int preserve_executability;
+extern int preserve_fileflags;
 extern int preserve_perms;
 extern int preserve_times;
+extern int force_change;
 extern int delete_mode;
 extern int delete_before;
 extern int delete_during;
@@ -471,6 +473,10 @@ int unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp)
 			return 0;
 		if (perms_differ(file, sxp))
 			return 0;
+#ifdef SUPPORT_FILEFLAGS
+		if (preserve_fileflags && sxp->st.st_flags != F_FFLAGS(file))
+			return 0;
+#endif
 		if (ownership_differs(file, sxp))
 			return 0;
 #ifdef SUPPORT_ACLS
@@ -525,6 +531,11 @@ void itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statre
 		if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP)
 		    && sxp->st.st_gid != (gid_t)F_GROUP(file))
 			iflags |= ITEM_REPORT_GROUP;
+#ifdef SUPPORT_FILEFLAGS
+		if (preserve_fileflags && !S_ISLNK(file->mode)
+		 && sxp->st.st_flags != F_FFLAGS(file))
+			iflags |= ITEM_REPORT_FFLAGS;
+#endif
 #ifdef SUPPORT_ACLS
 		if (preserve_acls && !S_ISLNK(file->mode)) {
 			if (!ACL_READY(*sxp))
@@ -1412,6 +1423,10 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
 			file->mode = dest_mode(file->mode, sx.st.st_mode,
 					       dflt_perms, statret == 0);
 		}
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && !preserve_fileflags)
+			F_FFLAGS(file) = sx.st.st_flags;
+#endif
 		if (statret != 0 && basis_dir[0] != NULL) {
 			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
 					      itemizing, code);
@@ -1456,10 +1471,15 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
 		 * readable and writable permissions during the time we are
 		 * putting files within them.  This is then restored to the
 		 * former permissions after the transfer is done. */
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && F_FFLAGS(file) & force_change
+		 && make_mutable(fname, file->mode, F_FFLAGS(file), force_change))
+			need_retouch_dir_perms = 1;
+#endif
 #ifdef HAVE_CHMOD
 		if (!am_root && (file->mode & S_IRWXU) != S_IRWXU && dir_tweaking) {
 			mode_t mode = file->mode | S_IRWXU;
-			if (do_chmod(fname, mode) < 0) {
+			if (do_chmod(fname, mode, 0) < 0) {
 				rsyserr(FERROR_XFER, errno,
 					"failed to modify permissions on %s",
 					full_fname(fname));
@@ -1495,6 +1515,10 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
 		file->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms,
 				       exists);
 	}
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change && !preserve_fileflags)
+		F_FFLAGS(file) = sx.st.st_flags;
+#endif
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && F_HLINK_NOT_FIRST(file)
@@ -2078,17 +2102,25 @@ static void touch_up_dirs(struct file_list *flist, int ndx)
 			continue;
 		fname = f_name(file, NULL);
 		if (fix_dir_perms)
-			do_chmod(fname, file->mode);
+			do_chmod(fname, file->mode, 0);
 		if (need_retouch_dir_times) {
 			STRUCT_STAT st;
 			if (link_stat(fname, &st, 0) == 0 && time_diff(&st, file)) {
 				st.st_mtime = file->modtime;
 #ifdef ST_MTIME_NSEC
 				st.ST_MTIME_NSEC = F_MOD_NSEC_or_0(file);
+#endif
+#ifdef SUPPORT_FORCE_CHANGE
+				st.st_mode = file->mode;
+				st.st_flags = 0;
 #endif
 				set_times(fname, &st);
 			}
 		}
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && F_FFLAGS(file) & force_change)
+			undo_make_mutable(fname, F_FFLAGS(file));
+#endif
 		if (counter >= loopchk_limit) {
 			if (allowed_lull)
 				maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
diff --git a/log.c b/log.c
--- a/log.c
+++ b/log.c
@@ -721,7 +721,8 @@ static void log_formatted(enum logcode code, const char *format, const char *op,
 			     : S_ISLNK(file->mode) ? 'U' : 'u';
 			c[9] = !(iflags & ITEM_REPORT_ACL) ? '.' : 'a';
 			c[10] = !(iflags & ITEM_REPORT_XATTR) ? '.' : 'x';
-			c[11] = '\0';
+			c[11] = !(iflags & ITEM_REPORT_FFLAGS) ? '.' : 'f';
+			c[12] = '\0';
 
 			if (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {
 				char ch = iflags & ITEM_IS_NEW ? '+' : '?';
diff --git a/main.c b/main.c
--- a/main.c
+++ b/main.c
@@ -26,6 +26,9 @@
 #if defined CONFIG_LOCALE && defined HAVE_LOCALE_H
 #include <locale.h>
 #endif
+#ifdef SUPPORT_FORCE_CHANGE
+#include <sys/sysctl.h>
+#endif
 
 extern int dry_run;
 extern int list_only;
@@ -52,6 +55,7 @@ extern int copy_unsafe_links;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
+extern int force_change;
 extern int file_total;
 extern int recurse;
 extern int xfer_dirs;
@@ -945,6 +949,22 @@ static int do_recv(int f_in, int f_out, char *local_name)
 	 * points to an identical file won't be replaced by the referent. */
 	copy_links = copy_dirlinks = copy_unsafe_links = 0;
 
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change & SYS_IMMUTABLE) {
+		/* Determine whether we'll be able to unlock a system immutable item. */
+		int mib[2];
+		int securityLevel = 0;
+		size_t len = sizeof securityLevel;
+
+		mib[0] = CTL_KERN;
+		mib[1] = KERN_SECURELVL;
+		if (sysctl(mib, 2, &securityLevel, &len, NULL, 0) == 0 && securityLevel > 0) {
+			rprintf(FERROR, "System security level is too high to force mutability on system immutable files and directories.\n");
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+	}
+#endif
+
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && !inc_recurse)
 		match_hard_links(first_flist);
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -56,6 +56,7 @@ int preserve_hard_links = 0;
 int preserve_acls = 0;
 int preserve_xattrs = 0;
 int preserve_perms = 0;
+int preserve_fileflags = 0;
 int preserve_executability = 0;
 int preserve_devices = 0;
 int preserve_specials = 0;
@@ -92,6 +93,7 @@ int numeric_ids = 0;
 int msgs2stderr = 0;
 int allow_8bit_chars = 0;
 int force_delete = 0;
+int force_change = 0;
 int io_timeout = 0;
 int prune_empty_dirs = 0;
 int use_qsort = 0;
@@ -647,6 +649,11 @@ static void print_capabilities(enum logcode f)
 #endif
 			"SIMD",
 
+#ifndef SUPPORT_FILEFLAGS
+		"no "
+#endif
+			"file-flags",
+
 		NULL
 	};
 
@@ -779,6 +786,8 @@ static struct poptOption long_options[] = {
   {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
   {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+  {"fileflags",        0,  POPT_ARG_VAL,    &preserve_fileflags, 1, 0, 0 },
+  {"no-fileflags",     0,  POPT_ARG_VAL,    &preserve_fileflags, 0, 0, 0 },
   {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
   {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
   {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
@@ -872,6 +881,12 @@ static struct poptOption long_options[] = {
   {"remove-source-files",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },
   {"force",            0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },
   {"no-force",         0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },
+  {"force-delete",     0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },
+  {"no-force-delete",  0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },
+  {"force-change",     0,  POPT_ARG_VAL,    &force_change, ALL_IMMUTABLE, 0, 0 },
+  {"no-force-change",  0,  POPT_ARG_VAL,    &force_change, 0, 0, 0 },
+  {"force-uchange",    0,  POPT_ARG_VAL,    &force_change, USR_IMMUTABLE, 0, 0 },
+  {"force-schange",    0,  POPT_ARG_VAL,    &force_change, SYS_IMMUTABLE, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_VAL,    &ignore_errors, 1, 0, 0 },
   {"no-ignore-errors", 0,  POPT_ARG_VAL,    &ignore_errors, 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
@@ -1152,6 +1167,14 @@ static void set_refuse_options(void)
 #ifndef HAVE_SETVBUF
 	parse_one_refuse_match(0, "outbuf", list_end);
 #endif
+#ifndef SUPPORT_FILEFLAGS
+	parse_one_refuse_match(0, "fileflags", list_end);
+#endif
+#ifndef SUPPORT_FORCE_CHANGE
+	parse_one_refuse_match(0, "force-change", list_end);
+	parse_one_refuse_match(0, "force-uchange", list_end);
+	parse_one_refuse_match(0, "force-schange", list_end);
+#endif
 
 	/* Now we use the descrip values to actually mark the options for refusal. */
 	for (op = long_options; op != list_end; op++) {
@@ -2591,6 +2614,9 @@ void server_options(char **args, int *argc_p)
 	if (xfer_dirs && !recurse && delete_mode && am_sender)
 		args[ac++] = "--no-r";
 
+	if (preserve_fileflags)
+		args[ac++] = "--fileflags";
+
 	if (do_compression && do_compression_level != CLVL_NOT_SPECIFIED) {
 		if (asprintf(&arg, "--compress-level=%d", do_compression_level) < 0)
 			goto oom;
@@ -2694,6 +2720,16 @@ void server_options(char **args, int *argc_p)
 			args[ac++] = "--delete-excluded";
 		if (force_delete)
 			args[ac++] = "--force";
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change) {
+			if (force_change == ALL_IMMUTABLE)
+				args[ac++] = "--force-change";
+			else if (force_change == USR_IMMUTABLE)
+				args[ac++] = "--force-uchange";
+			else if (force_change == SYS_IMMUTABLE)
+				args[ac++] = "--force-schange";
+		}
+#endif
 		if (write_batch < 0)
 			args[ac++] = "--only-write-batch=X";
 		if (am_root > 1)
diff --git a/rsync.1.md b/rsync.1.md
--- a/rsync.1.md
+++ b/rsync.1.md
@@ -359,6 +359,7 @@ detailed description below for a complete description.
 --keep-dirlinks, -K      treat symlinked dir on receiver as dir
 --hard-links, -H         preserve hard links
 --perms, -p              preserve permissions
+--fileflags              preserve file-flags (aka chflags)
 --executability, -E      preserve executability
 --chmod=CHMOD            affect file and/or directory permissions
 --acls, -A               preserve ACLs (implies --perms)
@@ -398,7 +399,10 @@ detailed description below for a complete description.
 --ignore-missing-args    ignore missing source args without error
 --delete-missing-args    delete missing source args from destination
 --ignore-errors          delete even if there are I/O errors
---force                  force deletion of dirs even if not empty
+--force-delete           force deletion of directories even if not empty
+--force-change           affect user-/system-immutable files/dirs
+--force-uchange          affect user-immutable files/dirs
+--force-schange          affect system-immutable files/dirs
 --max-delete=NUM         don't delete more than NUM files
 --max-size=SIZE          don't transfer any file larger than SIZE
 --min-size=SIZE          don't transfer any file smaller than SIZE
@@ -694,6 +698,8 @@ your home directory (remove the '=' for that).
 
     Note that `-a` **does not preserve hardlinks**, because finding
     multiply-linked files is expensive.  You must separately specify `-H`.
+    Note also that for backward compatibility, `-a` currently does **not**
+    imply the `--fileflags` option.
 
 0.  `--no-OPTION`
 
@@ -1032,7 +1038,7 @@ your home directory (remove the '=' for that).
     Without this option, if the sending side has replaced a directory with a
     symlink to a directory, the receiving side will delete anything that is in
     the way of the new symlink, including a directory hierarchy (as long as
-    `--force` or `--delete` is in effect).
+    `--force-delete` or `--delete` is in effect).
 
     See also `--keep-dirlinks` for an analogous option for the receiving side.
 
@@ -1218,6 +1224,29 @@ your home directory (remove the '=' for that).
     those used by `--fake-super`) unless you repeat the option (e.g. `-XX`).
     This "copy all xattrs" mode cannot be used with `--fake-super`.
 
+0.  `--fileflags` This option causes rsync to update the file-flags to be the
+    same as the source files and directories (if your OS supports the
+    **chflags**(2) system call).   Some flags can only be altered by the
+    super-user and some might only be unset below a certain secure-level
+    (usually single-user mode). It will not make files alterable that are set
+    to immutable on the receiver.  To do that, see `--force-change`,
+    `--force-uchange`, and `--force-schange`.
+
+0.  `--force-change` This option causes rsync to disable both user-immutable
+    and system-immutable flags on files and directories that are being updated
+    or deleted on the receiving side.  This option overrides `--force-uchange`
+    and `--force-schange`.
+
+0.  `--force-uchange` This option causes rsync to disable user-immutable flags
+    on files and directories that are being updated or deleted on the receiving
+    side.  It does not try to affect system flags.  This option overrides
+    `--force-change` and `--force-schange`.
+
+0.  `--force-schange` This option causes rsync to disable system-immutable
+    flags on files and directories that are being updated or deleted on the
+    receiving side.  It does not try to affect user flags.  This option
+    overrides `--force-change` and `--force-uchange`.
+
 0.  `--chmod`
 
     This option tells rsync to apply one or more comma-separated "chmod" modes
@@ -1677,7 +1706,7 @@ your home directory (remove the '=' for that).
     option a step farther: each missing arg will become a deletion request of
     the corresponding destination file on the receiving side (should it exist).
     If the destination file is a non-empty directory, it will only be
-    successfully deleted if `--force` or `--delete` are in effect.  Other than
+    successfully deleted if `--force-delee` or `--delete` are in effect.  Other than
     that, this option is independent of any other type of delete processing.
 
     The missing source files are represented by special file-list entries which
@@ -1688,15 +1717,16 @@ your home directory (remove the '=' for that).
     Tells `--delete` to go ahead and delete files even when there are I/O
     errors.
 
-0.  `--force`
+0.  `--force-delee`
 
     This option tells rsync to delete a non-empty directory when it is to be
     replaced by a non-directory.  This is only relevant if deletions are not
     active (see `--delete` for details).
 
-    Note for older rsync versions: `--force` used to still be required when
-    using `--delete-after`, and it used to be non-functional unless the
-    `--recursive` option was also enabled.
+    This option can be abbreviated `--force` for backward compatibility.  Note
+    that some older rsync versions used to still require `--force` when using
+    `--delete-after`, and it used to be non-functional unless the `--recursive`
+    option was also enabled.
 
 0.  `--max-delete=NUM`
 
@@ -2504,7 +2534,7 @@ your home directory (remove the '=' for that).
     output of other verbose messages).
 
     The "%i" escape has a cryptic output that is 11 letters long.  The general
-    format is like the string `YXcstpoguax`, where **Y** is replaced by the type
+    format is like the string `YXcstpoguaxf`, where **Y** is replaced by the type
     of update being done, **X** is replaced by the file-type, and the other
     letters represent attributes that may be output if they are being modified.
 
diff --git a/rsync.c b/rsync.c
--- a/rsync.c
+++ b/rsync.c
@@ -31,6 +31,7 @@ extern int dry_run;
 extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_perms;
+extern int preserve_fileflags;
 extern int preserve_executability;
 extern int preserve_times;
 extern int am_root;
@@ -468,6 +469,39 @@ mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,
 	return new_mode;
 }
 
+#if defined SUPPORT_FILEFLAGS || defined SUPPORT_FORCE_CHANGE
+/* Set a file's st_flags. */
+static int set_fileflags(const char *fname, uint32 fileflags)
+{
+	if (do_chflags(fname, fileflags) != 0) {
+		rsyserr(FERROR_XFER, errno,
+			"failed to set file flags on %s",
+			full_fname(fname));
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Remove immutable flags from an object, so it can be altered/removed. */
+int make_mutable(const char *fname, mode_t mode, uint32 fileflags, uint32 iflags)
+{
+	if (S_ISLNK(mode) || !(fileflags & iflags))
+		return 0;
+	if (!set_fileflags(fname, fileflags & ~iflags))
+		return -1;
+	return 1;
+}
+
+/* Undo a prior make_mutable() call that returned a 1. */
+int undo_make_mutable(const char *fname, uint32 fileflags)
+{
+	if (!set_fileflags(fname, fileflags))
+		return -1;
+	return 1;
+}
+#endif
+
 int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 		   const char *fnamecmp, int flags)
 {
@@ -529,7 +563,7 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 		if (am_root >= 0) {
 			uid_t uid = change_uid ? (uid_t)F_OWNER(file) : sxp->st.st_uid;
 			gid_t gid = change_gid ? (gid_t)F_GROUP(file) : sxp->st.st_gid;
-			if (do_lchown(fname, uid, gid) != 0) {
+			if (do_lchown(fname, uid, gid, sxp->st.st_mode, ST_FLAGS(sxp->st)) != 0) {
 				/* We shouldn't have attempted to change uid
 				 * or gid unless have the privilege. */
 				rsyserr(FERROR_XFER, errno, "%s %s failed",
@@ -620,7 +654,7 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 
 #ifdef HAVE_CHMOD
 	if (!BITS_EQUAL(sxp->st.st_mode, new_mode, CHMOD_BITS)) {
-		int ret = am_root < 0 ? 0 : do_chmod(fname, new_mode);
+		int ret = am_root < 0 ? 0 : do_chmod(fname, new_mode, ST_FLAGS(sxp->st));
 		if (ret < 0) {
 			rsyserr(FERROR_XFER, errno,
 				"failed to set permissions on %s",
@@ -632,6 +666,19 @@ int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 	}
 #endif
 
+#ifdef SUPPORT_FILEFLAGS
+	if (preserve_fileflags && !S_ISLNK(sxp->st.st_mode)
+	 && sxp->st.st_flags != F_FFLAGS(file)) {
+		uint32 fileflags = F_FFLAGS(file);
+		if (flags & ATTRS_DELAY_IMMUTABLE)
+			fileflags &= ~ALL_IMMUTABLE;
+		if (sxp->st.st_flags != fileflags
+		 && !set_fileflags(fname, fileflags))
+			goto cleanup;
+		updated = 1;
+	}
+#endif
+
 	if (INFO_GTE(NAME, 2) && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
@@ -709,7 +756,8 @@ int finish_transfer(const char *fname, const char *fnametmp,
 
 	/* Change permissions before putting the file into place. */
 	set_file_attrs(fnametmp, file, NULL, fnamecmp,
-		       ok_to_set_time ? ATTRS_SET_NANO : ATTRS_SKIP_MTIME | ATTRS_SKIP_ATIME);
+		       ATTRS_DELAY_IMMUTABLE
+		       | (ok_to_set_time ? ATTRS_SET_NANO : ATTRS_SKIP_MTIME | ATTRS_SKIP_ATIME));
 
 	/* move tmp file over real file */
 	if (DEBUG_GTE(RECV, 1))
@@ -726,6 +774,10 @@ int finish_transfer(const char *fname, const char *fnametmp,
 	}
 	if (ret == 0) {
 		/* The file was moved into place (not copied), so it's done. */
+#ifdef SUPPORT_FILEFLAGS
+		if (preserve_fileflags && F_FFLAGS(file) & ALL_IMMUTABLE)
+			set_fileflags(fname, F_FFLAGS(file));
+#endif
 		return 1;
 	}
 	/* The file was copied, so tweak the perms of the copied file.  If it
diff --git a/rsync.h b/rsync.h
--- a/rsync.h
+++ b/rsync.h
@@ -68,7 +68,7 @@
 
 /* The following XMIT flags require an rsync that uses a varint for the flag values */
 
-#define XMIT_RESERVED_16 (1<<16) 	/* reserved for future fileflags use */
+#define XMIT_SAME_FLAGS (1<<16) 	/* any protocol - restricted by command-line option */
 #define XMIT_RESERVED_17 (1<<17) 	/* reserved for future crtimes use */
 
 /* These flags are used in the live flist data. */
@@ -177,6 +177,7 @@
 #define ATTRS_SKIP_MTIME	(1<<1)
 #define ATTRS_SET_NANO		(1<<2)
 #define ATTRS_SKIP_ATIME	(1<<3)
+#define ATTRS_DELAY_IMMUTABLE	(1<<4)
 
 #define MSG_FLUSH	2
 #define FULL_FLUSH	1
@@ -204,6 +205,7 @@
 #define ITEM_REPORT_GROUP (1<<6)
 #define ITEM_REPORT_ACL (1<<7)
 #define ITEM_REPORT_XATTR (1<<8)
+#define ITEM_REPORT_FFLAGS (1<<9)
 #define ITEM_BASIS_TYPE_FOLLOWS (1<<11)
 #define ITEM_XNAME_FOLLOWS (1<<12)
 #define ITEM_IS_NEW (1<<13)
@@ -544,6 +546,28 @@ typedef unsigned int size_t;
 #endif
 #endif
 
+#define NO_FFLAGS ((uint32)-1)
+
+#ifdef HAVE_CHFLAGS
+#define SUPPORT_FILEFLAGS 1
+#define SUPPORT_FORCE_CHANGE 1
+#endif
+
+#if defined SUPPORT_FILEFLAGS || defined SUPPORT_FORCE_CHANGE
+#ifndef UF_NOUNLINK
+#define UF_NOUNLINK 0
+#endif
+#ifndef SF_NOUNLINK
+#define SF_NOUNLINK 0
+#endif
+#define USR_IMMUTABLE (UF_IMMUTABLE|UF_NOUNLINK|UF_APPEND)
+#define SYS_IMMUTABLE (SF_IMMUTABLE|SF_NOUNLINK|SF_APPEND)
+#define ALL_IMMUTABLE (USR_IMMUTABLE|SYS_IMMUTABLE)
+#define ST_FLAGS(st) ((st).st_flags)
+#else
+#define ST_FLAGS(st) NO_FFLAGS
+#endif
+
 /* Find a variable that is either exactly 32-bits or longer.
  * If some code depends on 32-bit truncation, it will need to
  * take special action in a "#if SIZEOF_INT32 > 4" section. */
@@ -754,6 +778,7 @@ extern int pathname_ndx;
 extern int depth_ndx;
 extern int uid_ndx;
 extern int gid_ndx;
+extern int fileflags_ndx;
 extern int acls_ndx;
 extern int xattrs_ndx;
 
@@ -804,6 +829,11 @@ extern int xattrs_ndx;
 /* When the associated option is on, all entries will have these present: */
 #define F_OWNER(f) REQ_EXTRA(f, uid_ndx)->unum
 #define F_GROUP(f) REQ_EXTRA(f, gid_ndx)->unum
+#if defined SUPPORT_FILEFLAGS || defined SUPPORT_FORCE_CHANGE
+#define F_FFLAGS(f) REQ_EXTRA(f, fileflags_ndx)->unum
+#else
+#define F_FFLAGS(f) NO_FFLAGS
+#endif
 #define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num
 #define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num
 #define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num
diff --git a/syscall.c b/syscall.c
--- a/syscall.c
+++ b/syscall.c
@@ -38,6 +38,7 @@ extern int am_root;
 extern int am_sender;
 extern int read_only;
 extern int list_only;
+extern int force_change;
 extern int inplace;
 extern int preallocate_files;
 extern int preserve_perms;
@@ -68,7 +69,23 @@ int do_unlink(const char *fname)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
-	return unlink(fname);
+	if (unlink(fname) == 0)
+		return 0;
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change && errno == EPERM) {
+		STRUCT_STAT st;
+
+		if (x_lstat(fname, &st, NULL) == 0
+		 && make_mutable(fname, st.st_mode, st.st_flags, force_change) > 0) {
+			if (unlink(fname) == 0)
+				return 0;
+			undo_make_mutable(fname, st.st_flags);
+		}
+		/* TODO: handle immutable directories */
+		errno = EPERM;
+	}
+#endif
+	return -1;
 }
 
 #ifdef SUPPORT_LINKS
@@ -129,14 +146,35 @@ int do_link(const char *fname1, const char *fname2)
 }
 #endif
 
-int do_lchown(const char *path, uid_t owner, gid_t group)
+int do_lchown(const char *path, uid_t owner, gid_t group, UNUSED(mode_t mode), UNUSED(uint32 fileflags))
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 #ifndef HAVE_LCHOWN
 #define lchown chown
 #endif
-	return lchown(path, owner, group);
+	if (lchown(path, owner, group) == 0)
+		return 0;
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change && errno == EPERM) {
+		if (fileflags == NO_FFLAGS) {
+			STRUCT_STAT st;
+			if (x_lstat(path, &st, NULL) == 0) {
+				mode = st.st_mode;
+				fileflags = st.st_flags;
+			}
+		}
+		if (fileflags != NO_FFLAGS
+		 && make_mutable(path, mode, fileflags, force_change) > 0) {
+			int ret = lchown(path, owner, group);
+			undo_make_mutable(path, fileflags);
+			if (ret == 0)
+				return 0;
+		}
+		errno = EPERM;
+	}
+#endif
+	return -1;
 }
 
 int do_mknod(const char *pathname, mode_t mode, dev_t dev)
@@ -176,7 +214,7 @@ int do_mknod(const char *pathname, mode_t mode, dev_t dev)
 			return -1;
 		close(sock);
 #ifdef HAVE_CHMOD
-		return do_chmod(pathname, mode);
+		return do_chmod(pathname, mode, 0);
 #else
 		return 0;
 #endif
@@ -193,7 +231,22 @@ int do_rmdir(const char *pathname)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
-	return rmdir(pathname);
+	if (rmdir(pathname) == 0)
+		return 0;
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change && errno == EPERM) {
+		STRUCT_STAT st;
+
+		if (x_lstat(pathname, &st, NULL) == 0
+		 && make_mutable(pathname, st.st_mode, st.st_flags, force_change) > 0) {
+			if (rmdir(pathname) == 0)
+				return 0;
+			undo_make_mutable(pathname, st.st_flags);
+		}
+		errno = EPERM;
+	}
+#endif
+	return -1;
 }
 
 int do_open(const char *pathname, int flags, mode_t mode)
@@ -212,7 +265,7 @@ int do_open(const char *pathname, int flags, mode_t mode)
 }
 
 #ifdef HAVE_CHMOD
-int do_chmod(const char *path, mode_t mode)
+int do_chmod(const char *path, mode_t mode, UNUSED(uint32 fileflags))
 {
 	int code;
 	if (dry_run) return 0;
@@ -235,17 +288,72 @@ int do_chmod(const char *path, mode_t mode)
 	} else
 		code = chmod(path, mode & CHMOD_BITS); /* DISCOURAGED FUNCTION */
 #endif /* !HAVE_LCHMOD */
+#ifdef SUPPORT_FORCE_CHANGE
+	if (code < 0 && force_change && errno == EPERM && !S_ISLNK(mode)) {
+		if (fileflags == NO_FFLAGS) {
+			STRUCT_STAT st;
+			if (x_lstat(path, &st, NULL) == 0)
+				fileflags = st.st_flags;
+		}
+		if (fileflags != NO_FFLAGS
+		 && make_mutable(path, mode, fileflags, force_change) > 0) {
+			code = chmod(path, mode & CHMOD_BITS);
+			undo_make_mutable(path, fileflags);
+			if (code == 0)
+				return 0;
+		}
+		errno = EPERM;
+	}
+#endif
 	if (code != 0 && (preserve_perms || preserve_executability))
 		return code;
 	return 0;
 }
 #endif
 
+#ifdef HAVE_CHFLAGS
+int do_chflags(const char *path, uint32 fileflags)
+{
+	if (dry_run) return 0;
+	RETURN_ERROR_IF_RO_OR_LO;
+	return chflags(path, fileflags);
+}
+#endif
+
 int do_rename(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
-	return rename(fname1, fname2);
+	if (rename(fname1, fname2) == 0)
+		return 0;
+#ifdef SUPPORT_FORCE_CHANGE
+	if (force_change && errno == EPERM) {
+		STRUCT_STAT st1, st2;
+		int became_mutable;
+
+		if (x_lstat(fname1, &st1, NULL) != 0)
+			goto failed;
+		became_mutable = make_mutable(fname1, st1.st_mode, st1.st_flags, force_change) > 0;
+		if (became_mutable && rename(fname1, fname2) == 0)
+			goto success;
+		if (x_lstat(fname2, &st2, NULL) == 0
+		 && make_mutable(fname2, st2.st_mode, st2.st_flags, force_change) > 0) {
+			if (rename(fname1, fname2) == 0) {
+			  success:
+				if (became_mutable) /* Yes, use fname2 and st1! */
+					undo_make_mutable(fname2, st1.st_flags);
+				return 0;
+			}
+			undo_make_mutable(fname2, st2.st_flags);
+		}
+		/* TODO: handle immutable directories */
+		if (became_mutable)
+			undo_make_mutable(fname1, st1.st_flags);
+	  failed:
+		errno = EPERM;
+	}
+#endif
+	return -1;
 }
 
 #ifdef HAVE_FTRUNCATE
diff --git a/t_stub.c b/t_stub.c
--- a/t_stub.c
+++ b/t_stub.c
@@ -28,6 +28,8 @@ int protect_args = 0;
 int module_id = -1;
 int relative_paths = 0;
 int module_dirlen = 0;
+int force_change = 0;
+int preserve_acls = 0;
 int preserve_times = 0;
 int preserve_xattrs = 0;
 int preserve_perms = 0;
@@ -109,3 +111,23 @@ filter_rule_list daemon_filter_list;
 {
 	return cst ? 0 : 0;
 }
+
+#if defined SUPPORT_FILEFLAGS || defined SUPPORT_FORCE_CHANGE
+ int make_mutable(UNUSED(const char *fname), UNUSED(mode_t mode), UNUSED(uint32 fileflags), UNUSED(uint32 iflags))
+{
+	return 0;
+}
+
+/* Undo a prior make_mutable() call that returned a 1. */
+ int undo_make_mutable(UNUSED(const char *fname), UNUSED(uint32 fileflags))
+{
+	return 0;
+}
+#endif
+
+#ifdef SUPPORT_XATTRS
+ int x_lstat(UNUSED(const char *fname), UNUSED(STRUCT_STAT *fst), UNUSED(STRUCT_STAT *xst))
+{
+	return -1;
+}
+#endif
diff --git a/testsuite/rsync.fns b/testsuite/rsync.fns
--- a/testsuite/rsync.fns
+++ b/testsuite/rsync.fns
@@ -23,9 +23,9 @@ todir="$tmpdir/to"
 chkdir="$tmpdir/chk"
 
 # For itemized output:
-all_plus='+++++++++'
-allspace='         '
-dots='.....' # trailing dots after changes
+all_plus='++++++++++'
+allspace='          '
+dots='......' # trailing dots after changes
 tab_ch='	' # a single tab character
 
 # Berkley's nice.
diff --git a/util.c b/util.c
--- a/util.c
+++ b/util.c
@@ -33,6 +33,7 @@ extern int relative_paths;
 extern int preserve_times;
 extern int preserve_xattrs;
 extern int preallocate_files;
+extern int force_change;
 extern char *module_dir;
 extern unsigned int module_dirlen;
 extern char *partial_dir;
@@ -115,6 +116,33 @@ void print_child_argv(const char *prefix, char **cmd)
 	rprintf(FCLIENT, " (%d args)\n", cnt);
 }
 
+#ifdef SUPPORT_FORCE_CHANGE
+static int try_a_force_change(const char *fname, STRUCT_STAT *stp)
+{
+	uint32 fileflags = ST_FLAGS(*stp);
+	if (fileflags == NO_FFLAGS) {
+		STRUCT_STAT st;
+		if (x_lstat(fname, &st, NULL) == 0)
+			fileflags = st.st_flags;
+	}
+	if (fileflags != NO_FFLAGS && make_mutable(fname, stp->st_mode, fileflags, force_change) > 0) {
+		int ret, save_force_change = force_change;
+
+		force_change = 0; /* Make certain we can't come back here. */
+		ret = set_times(fname, stp);
+		force_change = save_force_change;
+
+		undo_make_mutable(fname, fileflags);
+
+		return ret;
+	}
+
+	errno = EPERM;
+
+	return -1;
+}
+#endif
+
 /* This returns 0 for success, 1 for a symlink if symlink time-setting
  * is not possible, or -1 for any other error. */
 int set_times(const char *fname, STRUCT_STAT *stp)
@@ -142,6 +170,10 @@ int set_times(const char *fname, STRUCT_STAT *stp)
 #include "case_N.h"
 		if (do_utimensat(fname, stp) == 0)
 			break;
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && errno == EPERM && try_a_force_change(fname, stp) == 0)
+			break;
+#endif
 		if (errno != ENOSYS)
 			return -1;
 		switch_step++;
@@ -151,6 +183,10 @@ int set_times(const char *fname, STRUCT_STAT *stp)
 #include "case_N.h"
 		if (do_lutimes(fname, stp) == 0)
 			break;
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && errno == EPERM && try_a_force_change(fname, stp) == 0)
+			break;
+#endif
 		if (errno != ENOSYS)
 			return -1;
 		switch_step++;
@@ -172,6 +208,10 @@ int set_times(const char *fname, STRUCT_STAT *stp)
 		if (do_utime(fname, stp) == 0)
 			break;
 #endif
+#ifdef SUPPORT_FORCE_CHANGE
+		if (force_change && errno == EPERM && try_a_force_change(fname, stp) == 0)
+			break;
+#endif
 
 		return -1;
 	}
diff --git a/xattrs.c b/xattrs.c
--- a/xattrs.c
+++ b/xattrs.c
@@ -1224,7 +1224,7 @@ int set_stat_xattr(const char *fname, struct file_struct *file, mode_t new_mode)
 	mode = (fst.st_mode & _S_IFMT) | (fmode & ACCESSPERMS)
 	     | (S_ISDIR(fst.st_mode) ? 0700 : 0600);
 	if (fst.st_mode != mode)
-		do_chmod(fname, mode);
+		do_chmod(fname, mode, ST_FLAGS(fst));
 	if (!IS_DEVICE(fst.st_mode))
 		fst.st_rdev = 0; /* just in case */
 
