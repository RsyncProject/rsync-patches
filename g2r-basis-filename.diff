Added a pipe from the generator to the receiver that communicates
what basis file we used to generate the file data (if it was not
the default name).  This optimizes away the basis-file search in
the receiver and makes future options that do more basis-file
searching more efficient (such as the --fuzzy option and the
support for multiple --compare-dest options).

You must run "make proto" before compiling.

--- orig/generator.c	2004-07-29 16:08:03
+++ generator.c	2004-07-28 10:14:15
@@ -259,9 +259,9 @@ static void generate_and_send_sums(int f
  * out.  It might be wrong.
  */
 static void recv_generator(char *fname, struct file_struct *file, int i,
-			   int f_out)
+			   int f_out, int f_out_name)
 {
-	int fd;
+	int fd = -1;
 	STRUCT_STAT st;
 	int statret, stat_errno;
 	char *fnamecmp;
@@ -437,13 +437,16 @@ static void recv_generator(char *fname, 
 							safe_fname(fname));
 					}
 					fnamecmp = fnamecmpbuf;
-				}
+				} else
+					*fnamecmpbuf = '\0';
 			} else
 #endif
 				fnamecmp = fnamecmpbuf;
 			statret = 0;
-		}
-	}
+		} else
+			*fnamecmpbuf = '\0';
+	} else
+		*fnamecmpbuf = '\0';
 
 	if (statret == 0 && !S_ISREG(st.st_mode)) {
 		if (delete_file(fname) != 0)
@@ -455,11 +458,9 @@ static void recv_generator(char *fname, 
 	if (statret == -1) {
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
-		if (stat_errno == ENOENT) {
-			write_int(f_out,i);
-			if (!dry_run && !read_batch)
-				write_sum_head(f_out, NULL);
-		} else if (verbose > 1) {
+		if (stat_errno == ENOENT)
+			goto notify_others;
+		if (verbose > 1) {
 			rsyserr(FERROR, stat_errno,
 				"recv_generator: failed to stat %s",
 				full_fname(fname));
@@ -467,13 +468,13 @@ static void recv_generator(char *fname, 
 		return;
 	}
 
-	if (opt_ignore_existing && fnamecmp == fname) {
+	if (opt_ignore_existing && !*fnamecmpbuf) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s exists\n", safe_fname(fname));
 		return;
 	}
 
-	if (update_only && fnamecmp == fname
+	if (update_only && !*fnamecmpbuf
 	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
@@ -481,21 +482,17 @@ static void recv_generator(char *fname, 
 	}
 
 	if (skip_file(fname, file, &st)) {
-		if (fnamecmp == fname)
+		if (!*fnamecmpbuf)
 			set_perms(fname, file, &st, PERMS_REPORT);
 		return;
 	}
 
-	if (dry_run || read_batch) {
-		write_int(f_out,i);
-		return;
-	}
-
-	if (whole_file > 0) {
-		write_int(f_out,i);
-		write_sum_head(f_out, NULL);
-		return;
+	if (dry_run || whole_file) {
+		statret = -1;
+		goto notify_others;
 	}
+	if (read_batch)
+		goto notify_others;
 
 	if (partial_dir) {
 		STRUCT_STAT st2;
@@ -516,9 +513,8 @@ static void recv_generator(char *fname, 
 		/* pretend the file didn't exist */
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
-		write_int(f_out,i);
-		write_sum_head(f_out, NULL);
-		return;
+		statret = -1;
+		goto notify_others;
 	}
 
 	if (verbose > 3) {
@@ -529,14 +525,41 @@ static void recv_generator(char *fname, 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
-	write_int(f_out,i);
-	generate_and_send_sums(fd, st.st_size, f_out);
+notify_others:
+	if (f_out_name >= 0) {
+		uchar lenbuf[3], *lb = lenbuf;
+		int len = statret == -1 ? 0 : strlen(fnamecmpbuf);
+		if (len > 0x7F) {
+#if MAXPATHLEN > 0x7FFF
+			*lb++ = len / 0x10000 + 0x80;
+			*lb++ = len / 0x100;
+#else
+			*lb++ = len / 0x100 + 0x80;
+#endif
+		}
+		*lb = len;
+		write_buf(f_out_name, lenbuf, lb - lenbuf + 1);
+		if (len)
+			write_buf(f_out_name, fnamecmpbuf, len);
+		io_flush(NORMAL_FLUSH); /* XXX make this more efficient! */
+	}
+
+	write_int(f_out, i);
+
+	if (dry_run || read_batch)
+		return;
 
-	close(fd);
+	if (statret == 0) {
+		generate_and_send_sums(fd, st.st_size, f_out);
+
+		close(fd);
+	} else
+		write_sum_head(f_out, NULL);
 }
 
 
-void generate_files(int f_out, struct file_list *flist, char *local_name)
+void generate_files(int f_out, struct file_list *flist, char *local_name,
+		    int f_out_name)
 {
 	int i;
 	int phase = 0;
@@ -577,7 +600,7 @@ void generate_files(int f_out, struct fi
 		}
 
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f_out);
+			       file, i, f_out, f_out_name);
 	}
 
 	phase++;
@@ -594,7 +617,7 @@ void generate_files(int f_out, struct fi
 	while ((i = get_redo_num()) != -1) {
 		struct file_struct *file = flist->files[i];
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f_out);
+			       file, i, f_out, f_out_name);
 	}
 
 	phase++;
@@ -613,7 +636,7 @@ void generate_files(int f_out, struct fi
 		if (!file->basename || !S_ISDIR(file->mode))
 			continue;
 		recv_generator(local_name ? local_name : f_name(file),
-			       file, i, -1);
+			       file, i, -1, -1);
 	}
 
 	if (verbose > 2)
--- orig/main.c	2004-07-29 16:08:03
+++ main.c	2004-07-22 00:10:43
@@ -58,6 +58,7 @@ extern int filesfrom_fd;
 extern pid_t cleanup_child_pid;
 extern char *files_from;
 extern char *remote_filesfrom_file;
+extern char *compare_dest;
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
@@ -456,7 +457,8 @@ static int do_recv(int f_in,int f_out,st
 {
 	int pid;
 	int status = 0;
-	int error_pipe[2];
+	int error_pipe[2], name_pipe[2];
+	BOOL need_name_pipe = compare_dest && !dry_run;
 
 	if (preserve_hard_links)
 		init_hard_links(flist);
@@ -467,8 +469,9 @@ static int do_recv(int f_in,int f_out,st
 			delete_files(flist);
 	}
 
-	if (fd_pair(error_pipe) < 0) {
-		rprintf(FERROR,"error pipe failed in do_recv\n");
+	if (fd_pair(error_pipe) < 0
+	    || (need_name_pipe && fd_pair(name_pipe) < 0)) {
+		rprintf(FERROR, "fd_pair() failed in do_recv\n");
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
@@ -476,6 +479,11 @@ static int do_recv(int f_in,int f_out,st
 
 	if ((pid = do_fork()) == 0) {
 		close(error_pipe[0]);
+		if (need_name_pipe) {
+			close(name_pipe[1]);
+			set_blocking(name_pipe[0]);
+		} else
+			name_pipe[0] = -1;
 		if (f_in != f_out)
 			close(f_out);
 
@@ -485,7 +493,7 @@ static int do_recv(int f_in,int f_out,st
 		/* set place to send errors */
 		set_msg_fd_out(error_pipe[1]);
 
-		recv_files(f_in,flist,local_name);
+		recv_files(f_in, flist, local_name, name_pipe[0]);
 		io_flush(FULL_FLUSH);
 		report(f_in);
 
@@ -504,6 +512,11 @@ static int do_recv(int f_in,int f_out,st
 		stop_write_batch();
 
 	close(error_pipe[1]);
+	if (need_name_pipe) {
+		close(name_pipe[0]);
+		set_nonblocking(name_pipe[1]);
+	} else
+		name_pipe[1] = -1;
 	if (f_in != f_out)
 		close(f_in);
 
@@ -511,7 +524,7 @@ static int do_recv(int f_in,int f_out,st
 
 	set_msg_fd_in(error_pipe[0]);
 
-	generate_files(f_out, flist, local_name);
+	generate_files(f_out, flist, local_name, name_pipe[1]);
 
 	get_redo_num(); /* Read final MSG_DONE and any prior messages. */
 	report(-1);
--- orig/receiver.c	2004-07-29 16:08:03
+++ receiver.c	2004-07-23 21:59:07
@@ -323,6 +323,30 @@ static int receive_data(int f_in, char *
 }
 
 
+static char *read_gen_name(int fd, char *buf, char *realname)
+{
+	int len = read_byte(fd);
+	if (len & 0x80) {
+#if MAXPATHLEN > 32767
+		uchar lenbuf[2];
+		read_buf(fd, (char *)lenbuf, 2);
+		len = (len & ~0x80) * 0x10000 + lenbuf[0] * 0x100 + lenbuf[1];
+#else
+		len = (len & ~0x80) * 0x100 + read_byte(fd);
+#endif
+	}
+	if (len) {
+		if (len >= MAXPATHLEN) {
+			rprintf(FERROR, "bogus data on generator name pipe\n");
+			exit_cleanup(RERR_PROTOCOL);
+		}
+		read_sbuf(fd, buf, len);
+		return buf;
+	}
+	return realname;
+}
+
+
 static void discard_receive_data(int f_in, OFF_T length)
 {
 	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
@@ -333,7 +357,8 @@ static void discard_receive_data(int f_i
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in, struct file_list *flist, char *local_name)
+int recv_files(int f_in, struct file_list *flist, char *local_name,
+	       int f_in_name)
 {
 	int next_gen_i = -1;
 	int fd1,fd2;
@@ -362,8 +387,15 @@ int recv_files(int f_in, struct file_lis
 		i = read_int(f_in);
 		if (i == -1) {
 			if (read_batch) {
-				if (next_gen_i != flist->count)
-					while (read_int(batch_gen_fd) != -1) {}
+				while (next_gen_i < flist->count) {
+					if (f_in_name >= 0 && next_gen_i >= 0) {
+						read_gen_name(f_in_name,
+							fnamecmpbuf, NULL);
+					}
+					next_gen_i = read_int(batch_gen_fd);
+					if (next_gen_i < 0)
+						break;
+				}
 				next_gen_i = -1;
 			}
 
@@ -411,6 +443,10 @@ int recv_files(int f_in, struct file_lis
 
 		if (read_batch) {
 			while (i > next_gen_i) {
+				if (f_in_name >= 0 && next_gen_i >= 0) {
+					read_gen_name(f_in_name, fnamecmpbuf,
+						      NULL);
+				}
 				next_gen_i = read_int(batch_gen_fd);
 				if (next_gen_i == -1)
 					next_gen_i = flist->count;
@@ -421,8 +457,14 @@ int recv_files(int f_in, struct file_lis
 				discard_receive_data(f_in, file->length);
 				continue;
 			}
+			next_gen_i = -1;
 		}
 
+		if (f_in_name >= 0)
+			fnamecmp = read_gen_name(f_in_name, fnamecmpbuf, fname);
+		else
+			fnamecmp = fname;
+
 		if (server_exclude_list.head
 		    && check_exclude(&server_exclude_list, fname,
 				     S_ISDIR(file->mode)) < 0) {
@@ -435,13 +477,7 @@ int recv_files(int f_in, struct file_lis
 			continue;
 		}
 
-		if (partial_dir) {
-			if ((partialptr = partial_dir_fname(fname)) != NULL)
-				fnamecmp = partialptr;
-			else
-				fnamecmp = fname;
-		} else
-			fnamecmp = partialptr = fname;
+		partialptr = partial_dir ? partial_dir_fname(fname) : fname;
 
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
@@ -451,14 +487,6 @@ int recv_files(int f_in, struct file_lis
 			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 		}
 
-		if (fd1 == -1 && compare_dest != NULL) {
-			/* try the file at compare_dest instead */
-			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
-				 compare_dest, fname);
-			fnamecmp = fnamecmpbuf;
-			fd1 = do_open(fnamecmp, O_RDONLY, 0);
-		}
-
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
 			rsyserr(FERROR, errno, "fstat %s failed",
 				full_fname(fnamecmp));
