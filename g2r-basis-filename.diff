Added a pipe from the generator to the receiver that communicates
what basis file we used to generate the file data (if it was not
the default name).  This optimizes away the basis-file search in
the receiver and makes future options that do more basis-file
searching more efficient (such as the --fuzzy option and the
support for multiple --compare-dest options).

You must run "make proto" before compiling.

--- orig/generator.c	2004-08-05 18:24:21
+++ generator.c	2004-07-30 07:18:03
@@ -249,13 +249,13 @@ static void generate_and_send_sums(int f
  * out.  It might be wrong.
  */
 static void recv_generator(char *fname, struct file_struct *file, int i,
-			   int f_out)
+			   int f_out, int f_out_name)
 {
-	int fd;
+	int fd = -1;
 	STRUCT_STAT st;
 	int statret, stat_errno;
-	char *fnamecmp;
-	char fnamecmpbuf[MAXPATHLEN];
+	char *fnamecmp, fnamecmpbuf[MAXPATHLEN];
+	uchar fnamecmp_type;
 
 	if (list_only)
 		return;
@@ -417,6 +417,7 @@ static void recv_generator(char *fname, 
 	}
 
 	fnamecmp = fname;
+	fnamecmp_type = G2R_FNAME;
 
 	if (statret == -1 && compare_dest != NULL) {
 		/* try the file at compare_dest instead */
@@ -433,10 +434,14 @@ static void recv_generator(char *fname, 
 							safe_fname(fname));
 					}
 					fnamecmp = fnamecmpbuf;
+					fnamecmp_type = 0;
 				}
 			} else
 #endif
+			{
 				fnamecmp = fnamecmpbuf;
+				fnamecmp_type = 0;
+			}
 			statret = 0;
 		}
 	}
@@ -451,11 +456,9 @@ static void recv_generator(char *fname, 
 	if (statret == -1) {
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
-		if (stat_errno == ENOENT) {
-			write_int(f_out,i);
-			if (!dry_run && !read_batch)
-				write_sum_head(f_out, NULL);
-		} else if (verbose > 1) {
+		if (stat_errno == ENOENT)
+			goto notify_others;
+		if (verbose > 1) {
 			rsyserr(FERROR, stat_errno,
 				"recv_generator: failed to stat %s",
 				full_fname(fname));
@@ -463,13 +466,13 @@ static void recv_generator(char *fname, 
 		return;
 	}
 
-	if (opt_ignore_existing && fnamecmp == fname) {
+	if (opt_ignore_existing && fnamecmp_type == G2R_FNAME) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s exists\n", safe_fname(fname));
 		return;
 	}
 
-	if (update_only && fnamecmp == fname
+	if (update_only && fnamecmp_type == G2R_FNAME
 	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
@@ -477,21 +480,17 @@ static void recv_generator(char *fname, 
 	}
 
 	if (skip_file(fnamecmp, file, &st)) {
-		if (fnamecmp == fname)
+		if (fnamecmp_type == G2R_FNAME)
 			set_perms(fname, file, &st, PERMS_REPORT);
 		return;
 	}
 
-	if (dry_run || read_batch) {
-		write_int(f_out,i);
-		return;
-	}
-
-	if (whole_file > 0) {
-		write_int(f_out,i);
-		write_sum_head(f_out, NULL);
-		return;
+	if (dry_run || whole_file) {
+		statret = -1;
+		goto notify_others;
 	}
+	if (read_batch)
+		goto notify_others;
 
 	if (partial_dir) {
 		STRUCT_STAT st2;
@@ -500,6 +499,7 @@ static void recv_generator(char *fname, 
 		    && S_ISREG(st2.st_mode)) {
 			st = st2;
 			fnamecmp = partialptr;
+			fnamecmp_type = G2R_PARTIAL_DIR;
 		}
 	}
 
@@ -512,9 +512,8 @@ static void recv_generator(char *fname, 
 		/* pretend the file didn't exist */
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
-		write_int(f_out,i);
-		write_sum_head(f_out, NULL);
-		return;
+		statret = -1;
+		goto notify_others;
 	}
 
 	if (verbose > 3) {
@@ -525,14 +524,28 @@ static void recv_generator(char *fname, 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
-	write_int(f_out,i);
-	generate_and_send_sums(fd, st.st_size, f_out);
+notify_others:
+	if (f_out_name >= 0) {
+		write_byte(f_out_name, fnamecmp_type);
+		io_flush(NORMAL_FLUSH); /* XXX make this more efficient! */
+	}
+
+	write_int(f_out, i);
 
-	close(fd);
+	if (dry_run || read_batch)
+		return;
+
+	if (statret == 0) {
+		generate_and_send_sums(fd, st.st_size, f_out);
+
+		close(fd);
+	} else
+		write_sum_head(f_out, NULL);
 }
 
 
-void generate_files(int f_out, struct file_list *flist, char *local_name)
+void generate_files(int f_out, struct file_list *flist, char *local_name,
+		    int f_out_name)
 {
 	int i;
 	int phase = 0;
@@ -573,7 +586,7 @@ void generate_files(int f_out, struct fi
 		}
 
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f_out);
+			       file, i, f_out, f_out_name);
 	}
 
 	phase++;
@@ -590,7 +603,7 @@ void generate_files(int f_out, struct fi
 	while ((i = get_redo_num()) != -1) {
 		struct file_struct *file = flist->files[i];
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f_out);
+			       file, i, f_out, f_out_name);
 	}
 
 	phase++;
@@ -609,7 +622,7 @@ void generate_files(int f_out, struct fi
 		if (!file->basename || !S_ISDIR(file->mode))
 			continue;
 		recv_generator(local_name ? local_name : f_name(file),
-			       file, i, -1);
+			       file, i, -1, -1);
 	}
 
 	if (verbose > 2)
--- orig/main.c	2004-08-05 18:24:21
+++ main.c	2004-07-22 00:10:43
@@ -59,6 +59,7 @@ extern int filesfrom_fd;
 extern pid_t cleanup_child_pid;
 extern char *files_from;
 extern char *remote_filesfrom_file;
+extern char *compare_dest;
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
@@ -461,7 +462,8 @@ static int do_recv(int f_in,int f_out,st
 {
 	int pid;
 	int status = 0;
-	int error_pipe[2];
+	int error_pipe[2], name_pipe[2];
+	BOOL need_name_pipe = compare_dest && !dry_run;
 
 	/* The receiving side mustn't obey this, or an existing symlink that
 	 * points to an identical file won't be replaced by the referent. */
@@ -476,8 +478,9 @@ static int do_recv(int f_in,int f_out,st
 			delete_files(flist);
 	}
 
-	if (fd_pair(error_pipe) < 0) {
-		rprintf(FERROR,"error pipe failed in do_recv\n");
+	if (fd_pair(error_pipe) < 0
+	    || (need_name_pipe && fd_pair(name_pipe) < 0)) {
+		rprintf(FERROR, "fd_pair() failed in do_recv\n");
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
@@ -485,6 +488,11 @@ static int do_recv(int f_in,int f_out,st
 
 	if ((pid = do_fork()) == 0) {
 		close(error_pipe[0]);
+		if (need_name_pipe) {
+			close(name_pipe[1]);
+			set_blocking(name_pipe[0]);
+		} else
+			name_pipe[0] = -1;
 		if (f_in != f_out)
 			close(f_out);
 
@@ -494,7 +502,7 @@ static int do_recv(int f_in,int f_out,st
 		/* set place to send errors */
 		set_msg_fd_out(error_pipe[1]);
 
-		recv_files(f_in,flist,local_name);
+		recv_files(f_in, flist, local_name, name_pipe[0]);
 		io_flush(FULL_FLUSH);
 		report(f_in);
 
@@ -513,6 +521,11 @@ static int do_recv(int f_in,int f_out,st
 		stop_write_batch();
 
 	close(error_pipe[1]);
+	if (need_name_pipe) {
+		close(name_pipe[0]);
+		set_nonblocking(name_pipe[1]);
+	} else
+		name_pipe[1] = -1;
 	if (f_in != f_out)
 		close(f_in);
 
@@ -520,7 +533,7 @@ static int do_recv(int f_in,int f_out,st
 
 	set_msg_fd_in(error_pipe[0]);
 
-	generate_files(f_out, flist, local_name);
+	generate_files(f_out, flist, local_name, name_pipe[1]);
 
 	get_redo_num(); /* Read final MSG_DONE and any prior messages. */
 	report(-1);
--- orig/receiver.c	2004-08-03 15:34:32
+++ receiver.c	2004-07-30 07:17:48
@@ -333,7 +333,8 @@ static void discard_receive_data(int f_i
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in, struct file_list *flist, char *local_name)
+int recv_files(int f_in, struct file_list *flist, char *local_name,
+	       int f_in_name)
 {
 	int next_gen_i = -1;
 	int fd1,fd2;
@@ -362,8 +363,13 @@ int recv_files(int f_in, struct file_lis
 		i = read_int(f_in);
 		if (i == -1) {
 			if (read_batch) {
-				if (next_gen_i != flist->count)
-					while (read_int(batch_gen_fd) != -1) {}
+				if (next_gen_i != flist->count) {
+					do {
+						if (f_in_name >= 0
+						    && next_gen_i >= 0)
+							read_byte(f_in_name);
+					} while (read_int(batch_gen_fd) != -1);
+				}
 				next_gen_i = -1;
 			}
 
@@ -411,6 +417,8 @@ int recv_files(int f_in, struct file_lis
 
 		if (read_batch) {
 			while (i > next_gen_i) {
+				if (f_in_name >= 0 && next_gen_i >= 0)
+					read_byte(f_in_name);
 				next_gen_i = read_int(batch_gen_fd);
 				if (next_gen_i == -1)
 					next_gen_i = flist->count;
@@ -421,6 +429,7 @@ int recv_files(int f_in, struct file_lis
 				discard_receive_data(f_in, file->length);
 				continue;
 			}
+			next_gen_i = -1;
 		}
 
 		if (server_exclude_list.head
@@ -430,30 +439,28 @@ int recv_files(int f_in, struct file_lis
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
-		if (partial_dir) {
-			if ((partialptr = partial_dir_fname(fname)) != NULL)
-				fnamecmp = partialptr;
-			else
+		partialptr = partial_dir ? partial_dir_fname(fname) : fname;
+
+		if (f_in_name >= 0) {
+			switch (read_byte(f_in_name)) {
+			case G2R_FNAME:
 				fnamecmp = fname;
+				break;
+			case G2R_PARTIAL_DIR:
+				fnamecmp = partialptr ? partialptr : fname;
+				break;
+			default:
+				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
+					 compare_dest, fname);
+				fnamecmp = fnamecmpbuf;
+				break;
+			}
 		} else
-			fnamecmp = partialptr = fname;
+			fnamecmp = fname;
 
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
-		if (fd1 == -1 && fnamecmp != fname) {
-			fnamecmp = fname;
-			fd1 = do_open(fnamecmp, O_RDONLY, 0);
-		}
-
-		if (fd1 == -1 && compare_dest != NULL) {
-			/* try the file at compare_dest instead */
-			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
-				 compare_dest, fname);
-			fnamecmp = fnamecmpbuf;
-			fd1 = do_open(fnamecmp, O_RDONLY, 0);
-		}
-
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
 			rsyserr(FERROR, errno, "fstat %s failed",
 				full_fname(fnamecmp));
--- orig/rsync.h	2004-08-03 15:41:32
+++ rsync.h	2004-07-30 07:16:38
@@ -118,6 +118,9 @@
 #define PDIR_CREATE	1
 #define PDIR_DELETE	0
 
+#define G2R_FNAME	0x80
+#define G2R_PARTIAL_DIR	0x81
+
 
 /* Log-message categories.  FLOG is only used on the daemon side to
  * output messages to the log file. */
