Depends-On-Patch: acls.diff

After applying this patch, run these commands for a successful build:

    ./prepare-source
    ./configure --enable-acl-support --enable-xattr-support
    make

--- old/Makefile.in
+++ new/Makefile.in
@@ -27,13 +27,13 @@ VERSION=@VERSION@
 
 HEADERS=byteorder.h config.h errcode.h proto.h rsync.h smb_acls.h lib/pool_alloc.h
 LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
-	lib/permstring.o lib/pool_alloc.o lib/sysacls.o @LIBOBJS@
+	lib/permstring.o lib/pool_alloc.o lib/sysacls.o lib/sysxattr.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
 	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
 OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 	main.o checksum.o match.o syscall.o log.o backup.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
-	fileio.o batch.o clientname.o chmod.o acls.o
+	fileio.o batch.o clientname.o chmod.o acls.o xattr.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
--- old/backup.c
+++ new/backup.c
@@ -29,6 +29,7 @@ extern char *backup_dir;
 
 extern int am_root;
 extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_links;
@@ -137,6 +138,10 @@ static int make_bak_dir(char *fullpath)
 				if (preserve_acls)
 					dup_acl(end, fullpath, st.st_mode);
 #endif
+#ifdef SUPPORT_XATTRS
+				if (preserve_xattrs)
+					dup_xattr(end, fullpath );
+#endif
 			}
 		}
 		*p = '/';
@@ -194,6 +199,10 @@ static int keep_backup(char *fname)
 	if (preserve_acls)
 		push_keep_backup_acl(file, fname, buf);
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		push_keep_backup_xattr(file, fname, buf);
+#endif
 
 	/* Check to see if this is a device file, or link */
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
@@ -274,6 +283,10 @@ static int keep_backup(char *fname)
 	if (preserve_acls)
 		cleanup_keep_backup_acl();
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		cleanup_keep_backup_xattr();
+#endif
 	free(file);
 
 	if (verbose > 1) {
--- old/configure.in
+++ new/configure.in
@@ -823,6 +823,30 @@ samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_
   AC_MSG_RESULT(no)
 )
 
+AC_CHECK_HEADERS(attr/xattr.h)
+AC_MSG_CHECKING(whether to support extended attributes)
+AC_ARG_ENABLE(xattr-support,
+AC_HELP_STRING([--enable-xattr-support], [Include extended attribute support (default=no)]),
+[ case "$enableval" in
+  yes)
+      case "$host_os" in
+      *linux*)
+            AC_MSG_RESULT(Using Linux xattrs)
+            AC_DEFINE(HAVE_LINUX_XATTRS, 1, [True if you have Linux xattrs])
+            ;;
+      *)
+            AC_MSG_RESULT(Xattrs requested but not linux.  Good luck)
+            ;;
+      esac
+      ;;
+  *)
+      AC_MSG_RESULT(no)
+      AC_DEFINE(HAVE_NA_XATTRS, 1, [True if you don't have extended attributes])
+  esac ],
+  AC_MSG_RESULT(no)
+  AC_DEFINE(HAVE_NO_XATTRL, 1, [True if you don't have extended attributes])
+)
+
 AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
 AC_OUTPUT
 
--- old/flist.c
+++ new/flist.c
@@ -45,6 +45,7 @@ extern int one_file_system;
 extern int copy_dirlinks;
 extern int keep_dirlinks;
 extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
@@ -975,6 +976,10 @@ static struct file_struct *send_file_nam
 	if (preserve_acls && make_acl(file, fname) < 0)
 		return NULL;
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs && make_xattr(file, fname) < 0)
+		return NULL;
+#endif
 
 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
 
@@ -987,12 +992,20 @@ static struct file_struct *send_file_nam
 		if (preserve_acls)
 			send_acl(file, f);
 #endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			send_xattr(file, f);
+#endif
 	} else {
 #ifdef SUPPORT_ACLS
 		/* Cleanup unsent ACL(s). */
 		if (preserve_acls)
 			send_acl(file, -1);
 #endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			send_xattr(file, -1);
+#endif
 	}
 	return file;
 }
@@ -1385,6 +1398,10 @@ struct file_list *recv_file_list(int f)
 		if (preserve_acls)
 			receive_acl(file, f);
 #endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			receive_xattr(file, f );
+#endif
 
 		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
 			stats.total_size += file->length;
@@ -1412,6 +1429,10 @@ struct file_list *recv_file_list(int f)
 	if (preserve_acls)
 		sort_file_acl_index_lists();
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		sort_file_xattr_index_lists();
+#endif
 
 	if (f >= 0) {
 		recv_uid_list(f, flist);
--- old/lib/sysxattr.c
+++ new/lib/sysxattr.c
@@ -0,0 +1,41 @@
+/* Extended attribute support for rsync. */
+/* This file Copyright (C) 2004 Red Hat, Inc. */
+/* Written by Jay Fenlason */
+
+/* This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "rsync.h"
+
+#if defined HAVE_LINUX_XATTRS
+
+ssize_t sys_lgetxattr(const char *path, const char *name, void *value, size_t size)
+{
+	return lgetxattr(path, name, value, size);
+}
+
+int sys_lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags)
+{
+	return lsetxattr(path, name, value, size, flags);
+}
+
+ssize_t sys_llistxattr(const char *path, char *list, size_t size)
+{
+	return llistxattr(path, list, size);
+}
+
+#else
+
+#endif /* No xattrs */
--- old/lib/sysxattr.h
+++ new/lib/sysxattr.h
@@ -0,0 +1,9 @@
+#if defined HAVE_LINUX_XATTRS
+
+ssize_t sys_lgetxattr(const char *path, const char *name, void *value, size_t size);
+int sys_lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags);
+ssize_t sys_llistxattr(const char *path, char *list, size_t size);
+
+#else
+
+#endif /* No xattrs */
--- old/options.c
+++ new/options.c
@@ -46,6 +46,7 @@ int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_acls = 0;
+int preserve_xattrs = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
 int preserve_devices = 0;
@@ -194,6 +195,7 @@ static void print_rsync_version(enum log
 	char const *have_inplace = "no ";
 	char const *hardlinks = "no ";
 	char const *acls = "no ";
+	char const *xattrs = "no ";
 	char const *links = "no ";
 	char const *ipv6 = "no ";
 	STRUCT_STAT *dumstat;
@@ -213,7 +215,9 @@ static void print_rsync_version(enum log
 #ifdef SUPPORT_ACLS
 	acls = "";
 #endif
-
+#ifdef SUPPORT_XATTRS
+	xattrs = "";
+#endif
 #ifdef SUPPORT_LINKS
 	links = "";
 #endif
@@ -227,9 +231,9 @@ static void print_rsync_version(enum log
 	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
 	rprintf(f, "<http://rsync.samba.org/>\n");
 	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
-		"%shard links, %sACLs, %ssymlinks, batchfiles,\n",
+		"%shard links, %sACLs, %sxattrs, %ssymlinks, batchfiles,\n",
 		(int) (sizeof (OFF_T) * 8),
-		got_socketpair, hardlinks, acls, links);
+		got_socketpair, hardlinks, acls, xattrs, links);
 
 	/* Note that this field may not have type ino_t.  It depends
 	 * on the complicated interaction between largefile feature
@@ -302,6 +306,9 @@ void usage(enum logcode F)
 #ifdef SUPPORT_ACLS
   rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
 #endif
+#ifdef SUPPORT_XATTRS
+  rprintf(F," -X, --xattrs                preserve extended attributes (implies --perms)\n");
+#endif
   rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
   rprintf(F," -g, --group                 preserve group\n");
@@ -420,6 +427,9 @@ static struct poptOption long_options[] 
   {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
   {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
   {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
+  {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
+  {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
+  {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
@@ -1095,6 +1105,17 @@ int parse_arguments(int *argc, const cha
 			return 0;
 #endif
 
+		case 'X':
+#ifdef SUPPORT_XATTRS
+			preserve_xattrs = 1;
+			preserve_perms = 1;
+			break;
+#else
+			snprintf(err_buf,sizeof(err_buf),
+				 "extended attributes are not supported on this %s\n",
+				 am_server ? "server" : "client");
+			return 0;
+#endif /* SUPPORT_XATTRS */
 
 		default:
 			/* A large opt value means that set_refuse_options()
@@ -1542,6 +1563,10 @@ void server_options(char **args,int *arg
 	if (preserve_acls)
 		argstr[x++] = 'A';
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		argstr[x++] = 'X';
+#endif
 	if (preserve_uid)
 		argstr[x++] = 'o';
 	if (preserve_gid)
--- old/rsync.c
+++ new/rsync.c
@@ -34,6 +34,7 @@ extern int verbose;
 extern int dry_run;
 extern int daemon_log_format_has_i;
 extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_perms;
 extern int preserve_executability;
 extern int preserve_times;
@@ -215,6 +216,10 @@ int set_file_attrs(char *fname, struct f
 	if (preserve_acls && set_acl(fname, file, &st->st_mode) == 0)
 		updated = 1;
 #endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs && set_xattr(fname, file) == 0)
+		updated = 1;
+#endif
 
 #ifdef HAVE_CHMOD
 	if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
--- old/rsync.h
+++ new/rsync.h
@@ -674,6 +674,14 @@ struct chmod_mode_struct;
 #endif
 #include "smb_acls.h"
 
+#ifdef HAVE_LINUX_XATTRS
+#define SUPPORT_XATTRS 1
+#endif
+
+#if defined SUPPORT_XATTRS && defined HAVE_ATTR_XATTR_H
+#include <attr/xattr.h>
+#endif
+
 #include "proto.h"
 
 /* We have replacement versions of these if they're missing. */
--- old/rsync.yo
+++ new/rsync.yo
@@ -322,6 +322,7 @@ to the detailed description below for a 
  -p, --perms                 preserve permissions
  -E, --executability         preserve executability
  -A, --acls                  preserve ACLs (implies -p) [non-standard]
+ -X, --xattrs                preserve extended attrs (implies -p) [n.s.]
      --chmod=CHMOD           change destination permissions
  -o, --owner                 preserve owner (super-user only)
  -g, --group                 preserve group
@@ -807,6 +808,11 @@ version makes it incompatible with sendi
 rsync unless you double the bf(--acls) option (e.g. bf(-AA)).  This
 doubling is not needed when pulling files from an older rsync.
 
+dit(bf(-X, --xattrs)) This option causes rsync to update the remote
+extended attributes to be the same as the local ones.  This will work
+only if the remote machine's rsync supports this option also. This is
+a non-standard option.
+
 dit(bf(--chmod)) This option tells rsync to apply one or more
 comma-separated "chmod" strings to the permission of the files in the
 transfer.  The resulting value is treated as though it was the permissions
--- old/xattr.c
+++ new/xattr.c
@@ -0,0 +1,523 @@
+/* Extended Attribute support for rsync */
+/* Copyright (C) 2004 Red Hat, Inc */
+/* Written by Jay Fenlason, vaguely based on the ACLs patch */
+
+/* This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "rsync.h"
+#include "lib/sysxattr.h"
+
+#ifdef SUPPORT_XATTRS
+
+extern int dry_run;
+
+#define RSYNC_XAL_INITIAL 5
+#define RSYNC_XAL_LIST_INITIAL 100
+
+typedef struct {
+	size_t name_len;
+	char *name;
+	size_t datum_len;
+	char *datum;
+} rsync_xa;
+
+typedef struct {
+	size_t count;
+	size_t alloc;
+	rsync_xa *rxas;
+} rsync_xal;
+
+typedef struct {
+	size_t count;
+	size_t alloc;
+	rsync_xal *rxals;
+} rsync_xal_list;
+
+static size_t namebuf_len = 0;
+static char *namebuf = NULL;
+
+static size_t datumbuf_len = 0;
+static char *datumbuf = NULL;
+
+static rsync_xal curr_rsync_xal = { 0, 0, NULL };
+static rsync_xal_list rsync_xal_l = { 0, 0, NULL };
+
+
+/* ------------------------------------------------------------------------- */
+
+/* the below stuff is only used by the receiver */
+
+/* structure to hold index to rsync_xal_l member corresponding to
+ * flist->files[i] */
+
+typedef struct {
+	const struct file_struct *file;
+	int xalidx;
+} file_xal_index;
+
+typedef struct {
+	size_t count;
+	size_t alloc;
+	file_xal_index *filexalidxs;
+} file_xal_index_list;
+
+static file_xal_index_list fxil = {0, 0, NULL };
+
+/* stuff for redirecting calls to set_acl() from set_perms()
+ * for keep_backup() */
+static const struct file_struct *backup_orig_file = NULL;
+static const char null_string[] = "";
+static const char *backup_orig_fname = null_string;
+static const char *backup_dest_fname = null_string;
+static rsync_xal backup_xal;
+
+/* ------------------------------------------------------------------------- */
+
+static void rsync_xal_free(rsync_xal *x)
+{
+	size_t i;
+
+	for (i = 0; i < x->count; i++) {
+		free(x->rxas[i].name);
+		/* free(x->rxas[i].value); */
+	}
+	x->count = 0;
+}
+
+static int rsync_xal_compare_names(const void *x1, const void *x2)
+{
+	const rsync_xa *xa1;
+	const rsync_xa *xa2;
+
+	xa1 = x1;
+	xa2 = x2;
+	return strcmp(xa1->name, xa2->name);
+}
+
+static int rsync_xal_get(const char *fname, rsync_xal *x)
+{
+	ssize_t name_size;
+	ssize_t datum_size;
+	ssize_t left;
+	char *name;
+	size_t len;
+	char *ptr;
+
+	if (!namebuf) {
+		namebuf_len = 100;
+		namebuf = new_array(char, namebuf_len);
+		datumbuf_len = 100;
+		datumbuf = new_array(char, datumbuf_len);
+		if (!namebuf || !datumbuf)
+			out_of_memory("rsync_xal_get");
+	}
+
+	name_size = sys_llistxattr(fname, namebuf, namebuf_len);
+	if (name_size > (ssize_t)namebuf_len) {
+		name_size = -1;
+		errno = ERANGE;
+	}
+	if (name_size < 0) {
+		if (errno == ENOTSUP)
+			return -1;
+		if (errno == ERANGE) {
+			name_size = sys_llistxattr(fname, NULL, 0);
+			if (name_size < 0) {
+				rprintf(FERROR, "%s: rsync_xal_get: llistxattr: %s\n",
+					fname, strerror(errno));
+				return -1;
+			}
+			namebuf = realloc_array(namebuf, char, name_size + 1);
+			if (!namebuf)
+				out_of_memory("rsync_xal_get");
+			namebuf_len = name_size;
+			name_size = sys_llistxattr(fname, namebuf, namebuf_len);
+			if (name_size < 0) {
+				rprintf(FERROR,
+				    "%s: rsync_xal_get: re-llistxattr failed: %s\n",
+				    fname, strerror(errno));
+				return -1;
+			}
+		} else {
+			rprintf(FERROR,
+			    "%s: rsync_xal_get: llistxattr failed: %s\n",
+			    fname, strerror(errno));
+			return -1;
+		}
+	}
+	rsync_xal_free(x);
+	if (name_size == 0)
+		return 0;
+	for (left = name_size, name = namebuf; left > 0 ; left -= len, name += len) {
+		len = strlen(name) + 1;
+
+		if (x->count >= x->alloc) {
+			size_t new_alloc;
+			rsync_xa *new_rxas;
+
+			new_alloc = x->alloc < RSYNC_XAL_INITIAL ? RSYNC_XAL_INITIAL : x->alloc * 2;
+			new_rxas = realloc_array(x->rxas, rsync_xa, new_alloc);
+			if (!new_rxas)
+				out_of_memory("rsync_xal_get");
+			x->alloc = new_alloc;
+			x->rxas = new_rxas;
+		}
+		datum_size = sys_lgetxattr(fname, name, datumbuf, datumbuf_len);
+		if (datum_size > (ssize_t)datumbuf_len) {
+			datum_size = -1;
+			errno = ERANGE;
+		}
+		if (datum_size < 0) {
+			if (errno == ENOTSUP)
+				return -1;
+			if (errno == ERANGE) {
+				datum_size = sys_lgetxattr(fname, name, NULL, 0);
+				if (datum_size < 0) {
+					rprintf(FERROR,
+					    "%s: rsync_xal_get: lgetxattr %s failed: %s\n",
+					    fname, name, strerror(errno));
+					return -1;
+				}
+				datumbuf = realloc_array(datumbuf, char, datum_size + 1);
+				if (!datumbuf)
+					out_of_memory("rsync_xal_get");
+				datumbuf_len = datum_size;
+				datum_size = sys_lgetxattr(fname, name, datumbuf, datumbuf_len);
+				if (datum_size < 0) {
+					rprintf(FERROR,
+					    "%s: rsync_xal_get: re-lgetxattr of %s failed: %s\n",
+					    name, fname, strerror(errno));
+					return -1;
+				}
+			} else {
+				rprintf(FERROR,
+				    "%s: rsync_xal_get: lgetxattr %s failed: %s\n",
+				    fname, name, strerror(errno));
+				return -1;
+			}
+		}
+		ptr = new_array(char, len + datum_size);
+		if (!ptr)
+			out_of_memory("rsync_xal_get");
+		strcpy(ptr, name);
+		if (datum_size)
+			memcpy(ptr + len, datumbuf, datum_size);
+		x->rxas[curr_rsync_xal.count].name_len = len;
+		x->rxas[curr_rsync_xal.count].name = ptr;
+		x->rxas[curr_rsync_xal.count].datum_len = datum_size;
+		x->rxas[curr_rsync_xal.count].datum = ptr + len;
+		x->count++;
+	}
+	if (x->count > 1) {
+		qsort(x->rxas, x->count, sizeof (rsync_xa), rsync_xal_compare_names);
+	}
+	return 0;
+}
+
+
+/* generate the xattr(s) for this flist entry;
+ * xattr(s) are either sent or cleaned-up by send_xattr() below */
+
+int make_xattr(UNUSED(const struct file_struct *file), const char *fname)
+{
+	rsync_xal_get(fname, &curr_rsync_xal);
+	return 0; /* TODO:  This needs to return 1 if no xattrs changed! */
+}
+
+static ssize_t rsync_xal_find_matching(void)
+{
+	size_t i;
+	size_t j;
+
+	for (i = 0; i < rsync_xal_l.count; i++) {
+		/* Wrong number of elements? */
+		if (rsync_xal_l.rxals[i].count != curr_rsync_xal.count)
+			continue;
+		/* any elements different? */
+		for (j = 0; j < curr_rsync_xal.count; j++) {
+			if (rsync_xal_l.rxals[i].rxas[j].name_len != curr_rsync_xal.rxas[j].name_len
+			 || rsync_xal_l.rxals[i].rxas[j].datum_len != curr_rsync_xal.rxas[j].datum_len
+			 || strcmp(rsync_xal_l.rxals[i].rxas[j].name, curr_rsync_xal.rxas[j].name)
+			 || memcmp(rsync_xal_l.rxals[i].rxas[j].datum, curr_rsync_xal.rxas[j].datum, curr_rsync_xal.rxas[j].datum_len))
+				break;
+		}
+		/* no differences found.  This is The One! */
+		if (j == curr_rsync_xal.count)
+			break;
+	}
+	if (i < rsync_xal_l.count)
+		return i;
+	return (ssize_t)-1;
+}
+
+/* Store curr_rsync_xal on the end of rsync_xal_l */
+static void rsync_xal_store(void)
+{
+	if (rsync_xal_l.count <= rsync_xal_l.alloc) {
+		size_t new_alloc;
+		void *new_xal;
+
+		new_alloc = rsync_xal_l.count < RSYNC_XAL_LIST_INITIAL ? RSYNC_XAL_LIST_INITIAL : rsync_xal_l.count * 2;
+		new_xal = realloc_array(rsync_xal_l.rxals, rsync_xal, new_alloc);
+		if (!new_xal)
+			out_of_memory("rsync_xal_store");
+		rsync_xal_l.alloc = new_alloc;
+		rsync_xal_l.rxals = new_xal;
+	}
+	rsync_xal_l.rxals[rsync_xal_l.count] = curr_rsync_xal;
+	rsync_xal_l.count++;
+	curr_rsync_xal.count = 0;
+	curr_rsync_xal.alloc = 0;
+}
+
+/* send the make_xattr()-generated xattr list for this flist entry,
+ * or clean up after an flist entry that's not being sent (f == -1) */
+
+void send_xattr(UNUSED(const struct file_struct *file), int f)
+{
+	ssize_t index;
+
+	if (f == -1) {
+		rsync_xal_free(&curr_rsync_xal);
+		return;
+	}
+	index = rsync_xal_find_matching();
+	if (index != -1) {
+		write_byte(f, 'x');
+		write_int(f, index);
+		rsync_xal_free(&curr_rsync_xal);
+	} else {
+		rsync_xa *rxa;
+		size_t count;
+
+		count = curr_rsync_xal.count;
+		write_byte(f, 'X');
+		write_int(f, count);
+		for (rxa = curr_rsync_xal.rxas; count--; rxa++) {
+			write_int(f, rxa->name_len);
+			write_int(f, rxa->datum_len);
+			write_buf(f, rxa->name, rxa->name_len);
+			write_buf(f, rxa->datum, rxa->datum_len);
+		}
+		rsync_xal_store();
+	}
+}
+
+
+/* ------------------------------------------------------------------------- */
+/* receive and build the rsync_xattr_lists */
+
+void receive_xattr(struct file_struct *file, int f)
+{
+	char *fname;
+	int tag;
+
+	fname = f_name(file, NULL);
+	tag = read_byte(f);
+	if (tag != 'X' && tag != 'x') {
+		rprintf(FERROR,
+		    "%s: receive_xattr: unknown extended attribute type tag: %c\n",
+		    fname, tag);
+		exit_cleanup(RERR_STREAMIO);
+	}
+
+	if (fxil.alloc <= fxil.count) {
+		void *new_ptr;
+		size_t new_alloc;
+
+		if (fxil.count <  RSYNC_XAL_LIST_INITIAL)
+			new_alloc = fxil.alloc + RSYNC_XAL_LIST_INITIAL;
+		else
+			new_alloc = fxil.alloc * 2;
+		new_ptr = realloc_array(fxil.filexalidxs, file_xal_index, new_alloc);
+		if (!new_ptr)
+			out_of_memory("receive_xattr");
+		if (verbose >= 3) {
+			rprintf(FINFO, "receive_xattr to %lu bytes, %s move\n",
+				(unsigned long)(new_alloc * sizeof (file_xal_index)),
+				fxil.filexalidxs == new_ptr ? "did not" : "did");
+		}
+
+		fxil.filexalidxs = new_ptr;
+		fxil.alloc = new_alloc;
+	}
+
+	fxil.filexalidxs[fxil.count].file = file;
+	if (tag == 'X') {
+		size_t count;
+		size_t i;
+
+		fxil.filexalidxs[fxil.count].xalidx = rsync_xal_l.count;
+
+		count = read_int(f);
+		curr_rsync_xal.count = count;
+		curr_rsync_xal.alloc = count;
+		curr_rsync_xal.rxas = new_array(rsync_xa, count);
+		if (!curr_rsync_xal.rxas)
+			out_of_memory("receive_xattr");
+		for (i = 0; i < count; i++) {
+			size_t name_len;
+			size_t datum_len;
+			char *ptr;
+
+			name_len = read_int(f);
+			datum_len = read_int(f);
+			if (name_len + datum_len < name_len)
+				out_of_memory("receive_xattr"); /* overflow */
+			ptr = new_array(char, name_len + datum_len);
+			if (!ptr)
+				out_of_memory("receive_xattr");
+			read_buf(f, ptr, name_len);
+			read_buf(f, ptr + name_len, datum_len);
+			curr_rsync_xal.rxas[i].name_len = name_len;
+			curr_rsync_xal.rxas[i].datum_len = datum_len;
+			curr_rsync_xal.rxas[i].name = ptr;
+			curr_rsync_xal.rxas[i].datum = ptr + name_len;
+		}
+		rsync_xal_store();
+	} else {
+		size_t index;
+
+		index = read_int(f);
+		if (index >= rsync_xal_l.count) {
+			rprintf(FERROR, "%s: receive_xattr: xa index %lu out of range\n",
+				fname, (unsigned long)index);
+			exit_cleanup(RERR_STREAMIO);
+		}
+		fxil.filexalidxs[fxil.count].xalidx = index;
+	}
+	fxil.count++;
+}
+
+static int rsync_xal_set(const char *fname, rsync_xal *x)
+{
+	size_t i;
+	int ret = 0;
+
+	for (i = 0; i < x->count; i++) {
+		int status = sys_lsetxattr(fname, x->rxas[i].name, x->rxas[i].datum, x->rxas[i].datum_len, 0);
+		if (status < 0) {
+			rprintf(FERROR, "%s: rsync_xal_set: lsetxattr %s failed: %s\n",
+				fname, x->rxas[i].name, strerror(errno));
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+/* for duplicating xattrs on backups when using backup_dir */
+
+int dup_xattr(const char *orig, const char *bak)
+{
+	int ret;
+
+	if (rsync_xal_get(orig, &backup_xal) < 0)
+		ret = rsync_xal_set(bak, &backup_xal);
+	else
+		ret = 0;
+	rsync_xal_free(&backup_xal);
+
+	return ret;
+}
+
+void push_keep_backup_xattr(const struct file_struct *file, const char *orig, const char *dest)
+{
+	backup_orig_file = file;
+	backup_orig_fname = orig;
+	backup_dest_fname = dest;
+	rsync_xal_get(orig, &backup_xal);
+}
+
+static int set_keep_backup_xal(void)
+{
+	return rsync_xal_set(backup_dest_fname, &backup_xal);
+}
+
+void cleanup_keep_backup_xattr(void)
+{
+	backup_orig_file = NULL;
+	backup_orig_fname = null_string;
+	backup_dest_fname = null_string;
+	rsync_xal_free(&backup_xal);
+}
+
+static int file_xal_index_compare(const void *x1, const void *x2)
+{
+	const file_xal_index *xa1;
+	const file_xal_index *xa2;
+
+	xa1 = x1;
+	xa2 = x2;
+	return xa1->file == xa2->file ? 0 : xa1->file < xa2->file ? -1 : 1;
+}
+
+void sort_file_xattr_index_lists(void)
+{
+	qsort(fxil.filexalidxs, fxil.count, sizeof (file_xal_index), file_xal_index_compare);
+}
+
+static int find_file_xal_index(const struct file_struct *file)
+{
+	int low = 0, high = fxil.count;
+	const struct file_struct *file_mid;
+
+	if (!high--) {
+		rprintf(FERROR, "find_file_xal_index: no entries\n");
+		exit_cleanup(RERR_STREAMIO);
+		return -1;
+	}
+	do {
+		int mid = (high + low) / 2;
+		file_mid = fxil.filexalidxs[mid].file;
+		if (file_mid == file)
+			return fxil.filexalidxs[mid].xalidx;
+		if (file_mid > file)
+			high = mid - 1;
+		else
+			low = mid + 1;
+	} while (low < high);
+	if (low == high) {
+		file_mid = fxil.filexalidxs[low].file;
+		if (file_mid == file)
+			return fxil.filexalidxs[low].xalidx;
+	}
+	rprintf(FERROR,
+		"find_file_xal_index: can't find entry for file in list\n");
+	exit_cleanup(RERR_STREAMIO);
+	return -1;
+}
+
+/* set extended attributes on rsync-ed or keep_backup-ed file */
+
+int set_xattr(const char *fname, const struct file_struct *file)
+{
+	int xalidx;
+	rsync_xal *x;
+
+	if (dry_run)
+		return 1; /* FIXME: --dry-run needs to compute this value */
+
+	if (file == backup_orig_file) {
+		if (!strcmp(fname, backup_dest_fname))
+			return set_keep_backup_xal();
+	}
+	xalidx = find_file_xal_index(file);
+	x = &(rsync_xal_l.rxals[xalidx]);
+
+	return rsync_xal_set(fname, x);
+}
+
+#endif /* SUPPORT_XATTRS */
