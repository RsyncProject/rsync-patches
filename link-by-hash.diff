Jason M. Felice wrote:

This patch adds the --link-by-hash=DIR option, which hard links received files
in a link farm arranged by MD4 or MD5 file hash.  The result is that the system
will only store one copy of the unique contents of each file, regardless of the
file's name.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/link-by-hash.diff
    ./prepare-source
    ./configure
    make

based-on: ee51a745c163f3c422a30b22f4beda0e1ead7c20
diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -37,7 +37,7 @@ OBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \
 	util.o main.o checksum.o match.o syscall.o log.o backup.o delete.o
 OBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \
 	fileio.o batch.o clientname.o chmod.o acls.o xattrs.o
-OBJS3=progress.o pipe.o
+OBJS3=progress.o pipe.o hashlink.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o
diff --git a/checksum.c b/checksum.c
--- a/checksum.c
+++ b/checksum.c
@@ -21,6 +21,7 @@
 
 #include "rsync.h"
 
+extern int checksum_len;
 extern int checksum_seed;
 extern int protocol_version;
 
@@ -221,3 +222,24 @@ int sum_end(char *sum)
 
 	return MD4_DIGEST_LEN;
 }
+
+const char *sum_as_hex(const char *sum)
+{
+	static char buf[MAX_DIGEST_LEN*2+1];
+	int i, x1, x2;
+	char *c = buf + checksum_len*2;
+
+	assert(c - buf < (int)sizeof buf);
+
+	*c = '\0';
+
+	for (i = checksum_len; --i >= 0; ) {
+		x1 = CVAL(sum, i);
+		x2 = x1 >> 4;
+		x1 &= 0xF;
+		*--c = x1 <= 9 ? x1 + '0' : x1 + 'a' - 10;
+		*--c = x2 <= 9 ? x2 + '0' : x2 + 'a' - 10;
+	}
+
+	return buf;
+}
diff --git a/clientserver.c b/clientserver.c
--- a/clientserver.c
+++ b/clientserver.c
@@ -50,6 +50,7 @@ extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
 extern char *bind_address;
 extern char *config_file;
+extern char *link_by_hash_dir;
 extern char *logfile_format;
 extern char *files_from;
 extern char *tmpdir;
@@ -548,6 +549,9 @@ static int rsync_module(int f_in, int f_out, int i, const char *addr, const char
 		return -1;
 	}
 
+	if (*lp_link_by_hash_dir(i))
+		link_by_hash_dir = lp_link_by_hash_dir(i);
+
 	if (am_daemon && am_server) {
 		rprintf(FLOG, "rsync allowed access on module %s from %s (%s)\n",
 			name, host, addr);
diff --git a/compat.c b/compat.c
--- a/compat.c
+++ b/compat.c
@@ -55,6 +55,7 @@ extern char *partial_dir;
 extern char *dest_option;
 extern char *files_from;
 extern char *filesfrom_host;
+extern char *link_by_hash_dir;
 extern filter_rule_list filter_list;
 extern int need_unsorted_flist;
 #ifdef ICONV_OPTION
@@ -328,4 +329,8 @@ void setup_protocol(int f_out,int f_in)
 	} else {
 		checksum_seed = read_int(f_in);
 	}
+	if (!am_sender && link_by_hash_dir && protocol_version < 30 && checksum_seed != 1) {
+		rprintf(FERROR, "You must specify --checksum-seed=1 when using --link-by-hash with an old version of rsync.\n");
+		exit_cleanup(RERR_PROTOCOL);
+	}
 }
diff --git a/hashlink.c b/hashlink.c
new file mode 100644
--- /dev/null
+++ b/hashlink.c
@@ -0,0 +1,334 @@
+/*
+   Copyright (C) Cronosys, LLC 2004
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* This file contains code used by the --link-by-hash option. */
+
+#include "rsync.h"
+
+extern char *link_by_hash_dir;
+extern char sender_file_sum[MAX_DIGEST_LEN];
+
+#ifdef HAVE_LINK
+
+/* This function is always called after a file is received, so the
+ * sender_file_sum buffer has whatever the last checksum was for the
+ * transferred file. */
+static char *make_hash_name(void)
+{
+	const char *hex = sum_as_hex(sender_file_sum);
+	char *dst;
+
+	if (asprintf(&dst, "%s/%.8s/%s", link_by_hash_dir, hex, hex+8) < 0)
+		out_of_memory("make_hash_name");
+
+	return dst;
+}
+
+
+static void kill_hashfile(struct hashfile_struct *hashfile)
+{
+	if (!hashfile)
+		return;
+	free(hashfile->name);
+	close(hashfile->fd);
+	free(hashfile);
+}
+
+
+static void kill_hashfiles(struct hashfile_struct *hashfiles)
+{
+	struct hashfile_struct *iter, *next;
+	if ((iter = hashfiles) != NULL) {
+		do {
+			next = iter->next;
+			kill_hashfile(iter);
+			iter = next;
+		} while (iter != hashfiles);
+	}
+}
+
+
+static struct hashfile_struct *find_hashfiles(char *hashname, int64 size, long *fnbr)
+{
+	DIR *d;
+	struct dirent *di;
+	struct hashfile_struct *hashfiles = NULL, *hashfile;
+	STRUCT_STAT st;
+	long this_fnbr;
+
+	*fnbr = 0;
+
+	/* Build a list of potential candidates and open
+	 * them. */
+	if ((d = opendir(hashname)) == NULL) {
+		rsyserr(FERROR, errno, "opendir failed: \"%s\"", hashname);
+		free(hashname);
+		return NULL;
+	}
+	while ((di = readdir(d)) != NULL) {
+		if (!strcmp(di->d_name,".") || !strcmp(di->d_name,"..")) {
+			continue;
+		}
+
+		/* We need to have the largest fnbr in case we need to store
+		 * a new file. */
+		this_fnbr = atol(di->d_name);
+		if (this_fnbr > *fnbr)
+			*fnbr = this_fnbr;
+
+		hashfile = new_array(struct hashfile_struct, 1);
+		if (asprintf(&hashfile->name,"%s/%s",hashname, di->d_name) < 0)
+			out_of_memory("find_hashfiles");
+		if (do_stat(hashfile->name,&st) == -1) {
+			rsyserr(FERROR, errno, "stat failed: %s", hashfile->name);
+			kill_hashfile(hashfile);
+			continue;
+		}
+		if (st.st_size != size) {
+			kill_hashfile(hashfile);
+			continue;
+		}
+		hashfile->nlink = st.st_nlink;
+		hashfile->fd = open(hashfile->name,O_RDONLY|O_BINARY);
+		if (hashfile->fd == -1) {
+			rsyserr(FERROR, errno, "open failed: %s", hashfile->name);
+			kill_hashfile(hashfile);
+			continue;
+		}
+		if (hashfiles == NULL)
+			hashfiles = hashfile->next = hashfile->prev = hashfile;
+		else {
+			hashfile->next = hashfiles;
+			hashfile->prev = hashfiles->prev;
+			hashfile->next->prev = hashfile;
+			hashfile->prev->next = hashfile;
+		}
+	}
+	closedir(d);
+
+	return hashfiles;
+}
+
+
+static struct hashfile_struct *compare_hashfiles(int fd,struct hashfile_struct *files)
+{
+	int amt, hamt;
+	char buffer[BUFSIZ], cmpbuffer[BUFSIZ];
+	struct hashfile_struct *iter, *next, *best;
+	uint32 nlink;
+
+	if (!files)
+		return NULL;
+
+	iter = files; /* in case files are 0 bytes */
+	while ((amt = read(fd, buffer, BUFSIZ)) > 0) {
+		iter = files;
+		do {
+			/* Icky bit to resync when we steal the first node. */
+			if (!files)
+				files = iter;
+
+			next = iter->next;
+
+			hamt = read(iter->fd, cmpbuffer, BUFSIZ);
+			if (amt != hamt || memcmp(buffer, cmpbuffer, amt)) {
+				if (iter == files) {
+					files = files->prev;
+				}
+				if (iter->next == iter) {
+					files = next = NULL;
+				} else {
+					next = iter->next;
+					if (iter == files) {
+						/* So we know to resync */
+						files = NULL;
+					}
+				}
+				iter->next->prev = iter->prev;
+				iter->prev->next = iter->next;
+				kill_hashfile(iter);
+			}
+
+			iter = next;
+		} while (iter != files);
+
+		if (iter == NULL && files == NULL) {
+			/* There are no matches. */
+			return NULL;
+		}
+	}
+
+	if (amt == -1) {
+		rsyserr(FERROR, errno, "read failed in compare_hashfiles()");
+		kill_hashfiles(files);
+		return NULL;
+	}
+
+	/* If we only have one file left, use it. */
+	if (files == files->next) {
+		return files;
+	}
+
+	/* All files which remain in the list are identical and should have
+	 * the same size.  We pick the one with the lowest link count (we
+	 * may have rolled over because we hit the maximum link count for
+	 * the filesystem). */
+	best = iter = files;
+	nlink = iter->nlink;
+	do {
+		if (iter->nlink < nlink) {
+			nlink = iter->nlink;
+			best = iter;
+		}
+		iter = iter->next;
+	} while (iter != files);
+
+	best->next->prev = best->prev;
+	best->prev->next = best->next;
+	if (files == best)
+		files = files->next;
+	kill_hashfiles(files);
+	return best;
+}
+
+
+int link_by_hash(const char *fnametmp, const char *fname, struct file_struct *file)
+{
+	STRUCT_STAT st;
+	char *hashname = make_hash_name();
+	int first = 0, rc;
+	char *linkname;
+	long last_fnbr;
+
+	if (F_LENGTH(file) == 0)
+		return robust_rename(fnametmp, fname, NULL, 0644);
+
+	if (do_stat(hashname, &st) == -1) {
+		char *dirname;
+
+		/* Directory does not exist. */
+		dirname = strdup(hashname);
+		*strrchr(dirname,'/') = 0;
+		if (do_mkdir(dirname, 0755) == -1 && errno != EEXIST) {
+			rsyserr(FERROR, errno, "mkdir failed: %s", dirname);
+			free(hashname);
+			free(dirname);
+			return robust_rename(fnametmp, fname, NULL, 0644);
+		}
+		free(dirname);
+
+		if (do_mkdir(hashname, 0755) == -1 && errno != EEXIST) {
+			rsyserr(FERROR, errno, "mkdir failed: %s", hashname);
+			free(hashname);
+			return robust_rename(fnametmp, fname, NULL, 0644);
+		}
+
+		first = 1;
+		if (asprintf(&linkname,"%s/0",hashname) < 0)
+			out_of_memory("link_by_hash");
+		if (DEBUG_GTE(HASHLINK, 2))
+			rprintf(FINFO, "(1) linkname = %s\n", linkname);
+	} else {
+		struct hashfile_struct *hashfiles, *hashfile;
+
+		if (do_stat(fnametmp,&st) == -1) {
+			rsyserr(FERROR, errno, "stat failed: %s", fname);
+			return -1;
+		}
+		hashfiles = find_hashfiles(hashname, st.st_size, &last_fnbr);
+
+		if (hashfiles == NULL) {
+			first = 1;
+			if (asprintf(&linkname,"%s/0",hashname) < 0)
+				out_of_memory("link_by_hash");
+			if (DEBUG_GTE(HASHLINK, 2))
+				rprintf(FINFO, "(2) linkname = %s\n", linkname);
+		} else {
+			int fd;
+			/* Search for one identical to us. */
+			if ((fd = open(fnametmp,O_RDONLY|O_BINARY)) == -1) {
+				rsyserr(FERROR, errno, "open failed: %s", fnametmp);
+				kill_hashfiles(hashfiles);
+				return -1;
+			}
+			hashfile = compare_hashfiles(fd, hashfiles);
+			hashfiles = NULL;
+			close(fd);
+
+			if (hashfile) {
+				first = 0;
+				linkname = strdup(hashfile->name);
+				if (DEBUG_GTE(HASHLINK, 2))
+					rprintf(FINFO, "(3) linkname = %s\n", linkname);
+				kill_hashfile(hashfile);
+			} else {
+				first = 1;
+				if (asprintf(&linkname, "%s/%ld", hashname, last_fnbr + 1) < 0)
+					out_of_memory("link_by_hash");
+				if (DEBUG_GTE(HASHLINK, 2))
+					rprintf(FINFO, "(4) linkname = %s\n", linkname);
+			}
+		}
+	}
+
+	if (!first) {
+		if (DEBUG_GTE(HASHLINK, 2))
+			rprintf(FINFO, "link-by-hash (existing): \"%s\" -> %s\n", linkname, full_fname(fname));
+		robust_unlink(fname);
+		rc = do_link(linkname, fname);
+		if (rc == -1) {
+			if (errno == EMLINK) {
+				first = 1;
+				free(linkname);
+				if (asprintf(&linkname,"%s/%ld",hashname, last_fnbr + 1) < 0)
+					out_of_memory("link_by_hash");
+				if (DEBUG_GTE(HASHLINK, 2))
+					rprintf(FINFO, "(5) linkname = %s\n", linkname);
+				if (DEBUG_GTE(HASHLINK, 1))
+					rprintf(FINFO, "link-by-hash: max link count exceeded, starting new file \"%s\".\n", linkname);
+			} else {
+				rsyserr(FERROR, errno, "link \"%s\" -> \"%s\"",
+					linkname, full_fname(fname));
+				rc = robust_rename(fnametmp, fname, NULL, 0644);
+			}
+		} else {
+			do_unlink(fnametmp);
+		}
+	}
+
+	if (first) {
+		if (DEBUG_GTE(HASHLINK, 2))
+			rprintf(FINFO, "link-by-hash (new): %s -> \"%s\"\n", full_fname(fname),linkname);
+
+		rc = robust_rename(fnametmp, fname, NULL, 0644);
+		if (rc != 0) {
+			rsyserr(FERROR, errno, "rename \"%s\" -> \"%s\"",
+				full_fname(fnametmp), full_fname(fname));
+		}
+		rc = do_link(fname,linkname);
+		if (rc != 0) {
+			rsyserr(FERROR, errno, "link \"%s\" -> \"%s\"",
+				full_fname(fname), linkname);
+		}
+	}
+
+	free(linkname);
+	free(hashname);
+	return rc;
+}
+#endif
diff --git a/loadparm.c b/loadparm.c
--- a/loadparm.c
+++ b/loadparm.c
@@ -119,6 +119,7 @@ typedef struct {
 	char *include;
 	char *include_from;
 	char *incoming_chmod;
+	char *link_by_hash_dir;
 	char *lock_file;
 	char *log_file;
 	char *log_format;
@@ -195,6 +196,7 @@ static const all_vars Defaults = {
  /* include; */			NULL,
  /* include_from; */		NULL,
  /* incoming_chmod; */		NULL,
+ /* link_by_hash_dir; */	NULL,
  /* lock_file; */		DEFAULT_LOCK_FILE,
  /* log_file; */		NULL,
  /* log_format; */		"%o %h [%a] %m (%u) %f %l",
@@ -336,6 +338,7 @@ static struct parm_struct parm_table[] =
  {"include from",      P_STRING, P_LOCAL, &Vars.l.include_from,        NULL,0},
  {"include",           P_STRING, P_LOCAL, &Vars.l.include,             NULL,0},
  {"incoming chmod",    P_STRING, P_LOCAL, &Vars.l.incoming_chmod,      NULL,0},
+ {"link by hash dir",  P_STRING, P_LOCAL, &Vars.l.link_by_hash_dir,    NULL,0},
  {"list",              P_BOOL,   P_LOCAL, &Vars.l.list,                NULL,0},
  {"lock file",         P_STRING, P_LOCAL, &Vars.l.lock_file,           NULL,0},
  {"log file",          P_STRING, P_LOCAL, &Vars.l.log_file,            NULL,0},
@@ -464,6 +467,7 @@ FN_LOCAL_STRING(lp_hosts_deny, hosts_deny)
 FN_LOCAL_STRING(lp_include, include)
 FN_LOCAL_STRING(lp_include_from, include_from)
 FN_LOCAL_STRING(lp_incoming_chmod, incoming_chmod)
+FN_LOCAL_STRING(lp_link_by_hash_dir, link_by_hash_dir)
 FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_STRING(lp_log_file, log_file)
 FN_LOCAL_STRING(lp_log_format, log_format)
diff --git a/log.c b/log.c
--- a/log.c
+++ b/log.c
@@ -683,23 +683,14 @@ static void log_formatted(enum logcode code, const char *format, const char *op,
 			if (protocol_version >= 30
 			 && (iflags & ITEM_TRANSFER
 			  || (always_checksum && S_ISREG(file->mode)))) {
-				int i, x1, x2;
 				const char *sum = iflags & ITEM_TRANSFER
 						? sender_file_sum : F_SUM(file);
-				c = buf2 + checksum_len*2;
-				*c = '\0';
-				for (i = checksum_len; --i >= 0; ) {
-					x1 = CVAL(sum, i);
-					x2 = x1 >> 4;
-					x1 &= 0xF;
-					*--c = x1 <= 9 ? x1 + '0' : x1 + 'a' - 10;
-					*--c = x2 <= 9 ? x2 + '0' : x2 + 'a' - 10;
-				}
+				n = sum_as_hex(sum);
 			} else {
 				memset(buf2, ' ', checksum_len*2);
 				buf2[checksum_len*2] = '\0';
+				n = buf2;
 			}
-			n = buf2;
 			break;
 		case 'i':
 			if (iflags & ITEM_DELETED) {
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -159,6 +159,7 @@ char *backup_suffix = NULL;
 char *tmpdir = NULL;
 char *partial_dir = NULL;
 char *basis_dir[MAX_BASIS_DIRS+1];
+char *link_by_hash_dir = NULL;
 char *config_file = NULL;
 char *shell_cmd = NULL;
 char *logfile_name = NULL;
@@ -208,7 +209,7 @@ static const char *debug_verbosity[] = {
 	/*2*/ "BIND,CMD,CONNECT,DEL,DELTASUM,DUP,FILTER,FLIST,ICONV",
 	/*3*/ "ACL,BACKUP,CONNECT2,DELTASUM2,DEL2,EXIT,FILTER2,FLIST2,FUZZY,GENR,OWN,RECV,SEND,TIME",
 	/*4*/ "CMD2,DELTASUM3,DEL3,EXIT2,FLIST3,ICONV2,OWN2,PROTO,TIME2",
-	/*5*/ "CHDIR,DELTASUM4,FLIST4,FUZZY2,HASH,HLINK",
+	/*5*/ "CHDIR,DELTASUM4,FLIST4,FUZZY2,HASH,HASHLINK,HLINK",
 };
 
 #define MAX_VERBOSITY ((int)(sizeof debug_verbosity / sizeof debug_verbosity[0]) - 1)
@@ -278,6 +279,7 @@ static struct output_struct debug_words[COUNT_DEBUG+1] = {
 	DEBUG_WORD(FUZZY, W_REC, "Debug fuzzy scoring (levels 1-2)"),
 	DEBUG_WORD(GENR, W_REC, "Debug generator functions"),
 	DEBUG_WORD(HASH, W_SND|W_REC, "Debug hashtable code"),
+	DEBUG_WORD(HASHLINK, W_REC, "Debug hashlink code (levels 1-2)"),
 	DEBUG_WORD(HLINK, W_SND|W_REC, "Debug hard-link actions (levels 1-3)"),
 	DEBUG_WORD(ICONV, W_CLI|W_SRV, "Debug iconv character conversions (levels 1-2)"),
 	DEBUG_WORD(IO, W_CLI|W_SRV, "Debug I/O routines (levels 1-4)"),
@@ -760,6 +762,7 @@ void usage(enum logcode F)
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
   rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
+  rprintf(F,"     --link-by-hash=DIR      create hardlinks by hash into DIR\n");
   rprintf(F," -z, --compress              compress file data during the transfer\n");
   rprintf(F,"     --compress-level=NUM    explicitly set compression level\n");
   rprintf(F,"     --skip-compress=LIST    skip compressing files with a suffix in LIST\n");
@@ -815,7 +818,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG,
+      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG, OPT_LINK_BY_HASH,
       OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT,
       OPT_SERVER, OPT_REFUSED_BASE = 9000};
 
@@ -959,6 +962,7 @@ static struct poptOption long_options[] = {
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
+  {"link-by-hash",     0,  POPT_ARG_STRING, 0, OPT_LINK_BY_HASH, 0, 0},
   {"fuzzy",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },
   {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
   {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
@@ -1306,6 +1310,9 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 		iconv_opt = strdup(arg);
 #endif
 
+	if (*lp_link_by_hash_dir(module_id))
+		set_refuse_options("link-by-hash");
+
 	/* TODO: Call poptReadDefaultConfig; handle errors. */
 
 	/* The context leaks in case of an error, but if there's a
@@ -1792,6 +1799,21 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 			return 0;
 #endif
 
+                case OPT_LINK_BY_HASH:
+#ifdef HAVE_LINK
+			arg = poptGetOptArg(pc);
+			if (sanitize_paths)
+				arg = sanitize_path(NULL, arg, NULL, 0, SP_DEFAULT);
+			link_by_hash_dir = (char *)arg;
+			break;
+#else
+			snprintf(err_buf, sizeof err_buf,
+				 "hard links are not supported on this %s\n",
+				 am_server ? "server" : "client");
+			rprintf(FERROR, "ERROR: %s", err_buf);
+			return 0;
+#endif
+
 		default:
 			/* A large opt value means that set_refuse_options()
 			 * turned this option off. */
@@ -2721,6 +2743,11 @@ void server_options(char **args, int *argc_p)
 	} else if (inplace)
 		args[ac++] = "--inplace";
 
+	if (link_by_hash_dir && am_sender) {
+		args[ac++] = "--link-by-hash";
+		args[ac++] = link_by_hash_dir;
+	}
+
 	if (files_from && (!am_sender || filesfrom_host)) {
 		if (filesfrom_host) {
 			args[ac++] = "--files-from";
diff --git a/rsync.c b/rsync.c
--- a/rsync.c
+++ b/rsync.c
@@ -48,6 +48,7 @@ extern int flist_eof;
 extern int file_old_total;
 extern int keep_dirlinks;
 extern int make_backups;
+extern char *link_by_hash_dir;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct chmod_mode_struct *daemon_chmod_modes;
 #ifdef ICONV_OPTION
@@ -653,7 +654,12 @@ int finish_transfer(const char *fname, const char *fnametmp,
 	/* move tmp file over real file */
 	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
-	ret = robust_rename(fnametmp, fname, temp_copy_name, file->mode);
+#ifdef HAVE_LINK
+	if (link_by_hash_dir)
+		ret = link_by_hash(fnametmp, fname, file);
+	else
+#endif
+		ret = robust_rename(fnametmp, fname, temp_copy_name, file->mode);
 	if (ret < 0) {
 		rsyserr(FERROR_XFER, errno, "%s %s -> \"%s\"",
 			ret == -2 ? "copy" : "rename",
diff --git a/rsync.h b/rsync.h
--- a/rsync.h
+++ b/rsync.h
@@ -909,6 +909,14 @@ struct stats {
 	int xferred_files;
 };
 
+struct hashfile_struct {
+	struct hashfile_struct *next;
+	struct hashfile_struct *prev;
+	char *name;
+	int fd;
+	uint32 nlink;
+};
+
 struct chmod_mode_struct;
 
 struct flist_ndx_item {
@@ -1263,7 +1271,8 @@ extern short info_levels[], debug_levels[];
 #define DEBUG_FUZZY (DEBUG_FLIST+1)
 #define DEBUG_GENR (DEBUG_FUZZY+1)
 #define DEBUG_HASH (DEBUG_GENR+1)
-#define DEBUG_HLINK (DEBUG_HASH+1)
+#define DEBUG_HASHLINK (DEBUG_HASH+1)
+#define DEBUG_HLINK (DEBUG_HASHLINK+1)
 #define DEBUG_ICONV (DEBUG_HLINK+1)
 #define DEBUG_IO (DEBUG_ICONV+1)
 #define DEBUG_OWN (DEBUG_IO+1)
diff --git a/rsync.yo b/rsync.yo
--- a/rsync.yo
+++ b/rsync.yo
@@ -416,6 +416,7 @@ to the detailed description below for a complete description.  verb(
      --compare-dest=DIR      also compare received files relative to DIR
      --copy-dest=DIR         ... and include copies of unchanged files
      --link-dest=DIR         hardlink to files in DIR when unchanged
+     --link-by-hash=DIR      create hardlinks by hash into DIR
  -z, --compress              compress file data during the transfer
      --compress-level=NUM    explicitly set compression level
      --skip-compress=LIST    skip compressing files with suffix in LIST
@@ -1840,6 +1841,19 @@ bf(--link-dest) from working properly for a non-super-user when bf(-o) was
 specified (or implied by bf(-a)).  You can work-around this bug by avoiding
 the bf(-o) option when sending to an old rsync.
 
+dit(bf(--link-by-hash=DIR)) This option hard links the destination files into
+em(DIR), a link farm arranged by MD5 file hash (or sometimes MD4). The result
+is that the system will only store one copy of the unique contents of each
+file, regardless of the file's name.
+
+For a modern rsync (3.0.0 and newer), the link farm's directory hierarchy is
+determined by the file's MD5 hash.  It is recommended that you don't use this
+option with any rsync older than that.  However, if you really need to be able
+to interact with an older rsync on the sending side, you can use the options
+bf(--checksum-seed=1) and bf(--protocol=29) to force a consistent MD4 file
+checksum that will be used instead of MD5.  Note that this MD4 checksum is not
+compatible with older versions of this patch (prior to 3.1.0).
+
 dit(bf(-z, --compress)) With this option, rsync compresses the file data
 as it is sent to the destination machine, which reduces the amount of data
 being transmitted -- something that is useful over a slow connection.
diff --git a/rsyncd.conf.yo b/rsyncd.conf.yo
--- a/rsyncd.conf.yo
+++ b/rsyncd.conf.yo
@@ -283,6 +283,13 @@ message telling them to try later.  The default is 0, which means no limit.
 A negative value disables the module.
 See also the "lock file" parameter.
 
+dit(bf(link by hash dir)) When the "link by hash dir" parameter is set to a
+non-empty string, received files will be hard linked into em(DIR), a link farm
+arranged by MD5 file hash (or sometimes MD4). See the bf(--link-by-hash) option
+for a full explaination.  If this parameter is set it will disable the
+bf(--link-by-hash) command-line option. The default is for this parameter to be
+unset.
+
 dit(bf(log file)) When the "log file" parameter is set to a non-empty
 string, the rsync daemon will log messages to the indicated file rather
 than using syslog. This is particularly useful on systems (such as AIX)
