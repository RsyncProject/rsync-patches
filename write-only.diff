After applying this patch and running configure, you MUST run this
command before "make":

    make proto

peter pan (lanwanhr@yahoo.com) writes:

I've added a write only option to rsyncd.conf which is essentially the opposite
of read only.  This means that although it's possible someone on our allowed IP
range could overwrite (or delete) files on the rsync share, they would not be
allowed to download any files (my primary concern).


--- loadparm.c	4 Feb 2004 07:31:29 -0000	1.50
+++ loadparm.c	15 May 2004 20:50:11 -0000
@@ -119,6 +119,7 @@ typedef struct
 	char *comment;
 	char *lock_file;
 	BOOL read_only;
+	BOOL write_only;
 	BOOL list;
 	BOOL use_chroot;
 	BOOL transfer_logging;
@@ -151,6 +152,7 @@ static service sDefault =
 	NULL,    /* comment */
 	DEFAULT_LOCK_FILE,    /* lock file */
 	True,    /* read only */
+	False,   /* write only */
 	True,    /* list */
 	True,    /* use chroot */
 	False,   /* transfer logging */
@@ -277,6 +279,7 @@ static struct parm_struct parm_table[] =
   {"lock file",        P_STRING,  P_LOCAL,  &sDefault.lock_file,   NULL,   0},
   {"path",             P_PATH,    P_LOCAL,  &sDefault.path,        NULL,   0},
   {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
+  {"write only",       P_BOOL,    P_LOCAL,  &sDefault.write_only,  NULL,   0},
   {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
   {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
   {"ignore nonreadable",P_BOOL,   P_LOCAL,  &sDefault.ignore_nonreadable,  NULL,   0},
@@ -356,6 +359,7 @@ FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_BOOL(lp_read_only, read_only)
+FN_LOCAL_BOOL(lp_write_only, write_only)
 FN_LOCAL_BOOL(lp_list, list)
 FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
 FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
--- main.c	15 May 2004 19:31:10 -0000	1.194
+++ main.c	15 May 2004 20:50:11 -0000
@@ -369,6 +369,12 @@ static void do_server_sender(int f_in, i
 			(long)getpid());
 	}
 
+	if (am_daemon && lp_write_only(module_id) && !am_sender) {
+		rprintf(FERROR, "ERROR: module is write only\n");
+		exit_cleanup(RERR_SYNTAX);
+		return;
+	}
+
 	if (!relative_paths && !push_dir(dir)) {
 		rsyserr(FERROR, errno, "push_dir#3 %s failed",
 			full_fname(dir));
