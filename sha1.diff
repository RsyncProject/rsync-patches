This patch adds sha1 to the checksum code when the openssl library is available.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/sha1.diff
    make

based-on: 9cb7529ba60cd59519489ad0fc7fbb69ced6411f
diff --git a/checksum.c b/checksum.c
--- a/checksum.c
+++ b/checksum.c
@@ -51,6 +51,9 @@ struct name_num_obj valid_checksums = {
 #ifdef SUPPORT_XXHASH
 		{ CSUM_XXH64, "xxh64", NULL },
 		{ CSUM_XXH64, "xxhash", NULL },
+#endif
+#ifdef USE_OPENSSL
+		{ CSUM_SHA1, "sha1", NULL },
 #endif
 		{ CSUM_MD5, "md5", NULL },
 		{ CSUM_MD4, "md4", NULL },
@@ -143,6 +146,8 @@ int csum_len_for_type(int cst, BOOL flist_csum)
 		return MD4_DIGEST_LEN;
 	  case CSUM_MD5:
 		return MD5_DIGEST_LEN;
+	  case CSUM_SHA1:
+		return SHA_DIGEST_LENGTH;
 	  case CSUM_XXH64:
 	  case CSUM_XXH3_64:
 		return 64/8;
@@ -168,6 +173,7 @@ int canonical_checksum(int csum_type)
 		break;
 	  case CSUM_MD4:
 	  case CSUM_MD5:
+	  case CSUM_SHA1:
 		return -1;
 	  case CSUM_XXH64:
 	  case CSUM_XXH3_64:
@@ -220,6 +226,18 @@ void get_checksum2(char *buf, int32 len, char *sum)
 		SIVAL64(sum, 8, digest.high64);
 		break;
 	  }
+#endif
+#ifdef USE_OPENSSL
+	  case CSUM_SHA1: {
+		SHA_CTX sha;
+		uchar seedbuf[4];
+		SHA1_Init(&sha);
+		SIVALu(seedbuf, 0, checksum_seed);
+		SHA1_Update(&sha, seedbuf, 4);
+		SHA1_Update(&sha, (uchar *)buf, len);
+		SHA1_Final((uchar *)sum, &sha);
+		break;
+	  }
 #endif
 	  case CSUM_MD5: {
 		md5_context m5;
@@ -372,6 +390,23 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
 		SIVAL64(sum, 8, digest.high64);
 		break;
 	  }
+#endif
+#ifdef USE_OPENSSL
+	  case CSUM_SHA1: {
+		SHA_CTX sha;
+
+		SHA1_Init(&sha);
+
+		for (i = 0; i + CHUNK_SIZE <= len; i += CHUNK_SIZE)
+			SHA1_Update(&sha, (uchar *)map_ptr(buf, i, CHUNK_SIZE), CHUNK_SIZE);
+
+		remainder = (int32)(len - i);
+		if (remainder > 0)
+			SHA1_Update(&sha, (uchar *)map_ptr(buf, i, remainder), remainder);
+
+		SHA1_Final((uchar *)sum, &sha);
+		break;
+	  }
 #endif
 	  case CSUM_MD5: {
 		md5_context m5;
@@ -442,6 +477,7 @@ static union {
 	md_context md;
 #ifdef USE_OPENSSL
 	MD4_CTX m4;
+	SHA_CTX sha;
 #endif
 	md5_context m5;
 } ctx;
@@ -480,6 +516,11 @@ void sum_init(int csum_type, int seed)
 			out_of_memory("sum_init");
 		XXH3_128bits_reset(xxh3_state);
 		break;
+#endif
+#ifdef USE_OPENSSL
+	  case CSUM_SHA1:
+		SHA1_Init(&ctx.sha);
+		break;
 #endif
 	  case CSUM_MD5:
 		md5_begin(&ctx.m5);
@@ -530,6 +571,11 @@ void sum_update(const char *p, int32 len)
 	  case CSUM_XXH3_128:
 		XXH3_128bits_update(xxh3_state, p, len);
 		break;
+#endif
+#ifdef USE_OPENSSL
+	  case CSUM_SHA1:
+		SHA1_Update(&ctx.sha, (uchar *)p, len);
+		break;
 #endif
 	  case CSUM_MD5:
 		md5_update(&ctx.m5, (uchar *)p, len);
@@ -595,6 +641,11 @@ int sum_end(char *sum)
 		SIVAL64(sum, 8, digest.high64);
 		break;
 	  }
+#endif
+#ifdef USE_OPENSSL
+	  case CSUM_SHA1:
+		SHA1_Final((uchar *)sum, &ctx.sha);
+		break;
 #endif
 	  case CSUM_MD5:
 		md5_result(&ctx.m5, (uchar *)sum);
diff --git a/compat.c b/compat.c
--- a/compat.c
+++ b/compat.c
@@ -54,6 +54,7 @@ extern int do_compression;
 extern int do_compression_level;
 extern int saw_stderr_opt;
 extern int msgs2stderr;
+extern int xfersum_type;
 extern char *shell_cmd;
 extern char *partial_dir;
 extern char *files_from;
@@ -78,6 +79,8 @@ int proper_seed_order = 0;
 int inplace_partial = 0;
 int do_negotiated_strings = 0;
 int xmit_id0_names = 0;
+int xattr_sum_type = 0;
+int xattr_sum_len = 0;
 
 /* These index values are for the file-list's extra-attribute array. */
 int pathname_ndx, depth_ndx, atimes_ndx, crtimes_ndx, uid_ndx, gid_ndx, acls_ndx, xattrs_ndx, unsort_ndx;
@@ -115,6 +118,7 @@ struct name_num_obj valid_compressions = {
 #define CF_INPLACE_PARTIAL_DIR (1<<6)
 #define CF_VARINT_FLIST_FLAGS (1<<7)
 #define CF_ID0_NAMES (1<<8)
+#define CF_XATTR_SUM_CHOICE (1<<9)
 
 static const char *client_info;
 
@@ -716,6 +720,8 @@ void setup_protocol(int f_out,int f_in)
 				do_negotiated_strings = 1;
 				compat_flags |= CF_VARINT_FLIST_FLAGS;
 			}
+			if (strchr(client_info, 'X') != NULL)
+				compat_flags |= CF_XATTR_SUM_CHOICE;
 			if (strchr(client_info, 'V') != NULL) { /* Support a pre-release 'V' that got superseded */
 				if (!write_batch)
 					compat_flags |= CF_VARINT_FLIST_FLAGS;
@@ -804,6 +810,12 @@ void setup_protocol(int f_out,int f_in)
 	parse_checksum_choice(1); /* Sets checksum_type & xfersum_type */
 	parse_compress_choice(1); /* Sets do_compression */
 
+	if (compat_flags & CF_XATTR_SUM_CHOICE)
+		xattr_sum_type = xfersum_type;
+	else
+		xattr_sum_type = parse_csum_name(NULL, 0);
+	xattr_sum_len = csum_len_for_type(xattr_sum_type, 0);
+
 	if (write_batch && !am_server)
 		write_batch_shell_file();
 
diff --git a/lib/md-defines.h b/lib/md-defines.h
--- a/lib/md-defines.h
+++ b/lib/md-defines.h
@@ -2,7 +2,11 @@
 
 #define MD4_DIGEST_LEN 16
 #define MD5_DIGEST_LEN 16
+#ifdef USE_OPENSSL
+#define MAX_DIGEST_LEN SHA_DIGEST_LENGTH
+#else
 #define MAX_DIGEST_LEN MD5_DIGEST_LEN
+#endif
 
 #define CSUM_CHUNK 64
 
@@ -15,3 +19,4 @@
 #define CSUM_XXH64 6
 #define CSUM_XXH3_64 7
 #define CSUM_XXH3_128 8
+#define CSUM_SHA1 9
diff --git a/lib/mdigest.h b/lib/mdigest.h
--- a/lib/mdigest.h
+++ b/lib/mdigest.h
@@ -3,6 +3,7 @@
 #ifdef USE_OPENSSL
 #include "openssl/md4.h"
 #include "openssl/md5.h"
+#include <openssl/sha.h>
 #endif
 #include "md-defines.h"
 
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -3006,6 +3006,7 @@ int maybe_add_e_option(char *buf, int buf_len)
 		buf[x++] = 'I'; /* support inplace_partial behavior */
 		buf[x++] = 'v'; /* use varint for flist & compat flags; negotiate checksum */
 		buf[x++] = 'u'; /* include name of uid 0 & gid 0 in the id map */
+		buf[x++] = 'X'; /* xattr checksums use negotiated checksum not protocol default */
 
 		/* NOTE: Avoid using 'V' -- it was represented with the high bit of a write_byte() that became a write_varint(). */
 	}
diff --git a/xattrs.c b/xattrs.c
--- a/xattrs.c
+++ b/xattrs.c
@@ -38,6 +38,8 @@ extern int preserve_devices;
 extern int preserve_specials;
 extern int checksum_seed;
 extern int saw_xattr_filter;
+extern int xattr_sum_type;
+extern int xattr_sum_len;
 
 #define RSYNC_XAL_INITIAL 5
 #define RSYNC_XAL_LIST_INITIAL 100
@@ -270,7 +272,7 @@ static int rsync_xal_get(const char *fname, item_list *xalp)
 		if (datum_len > MAX_FULL_DATUM) {
 			/* For large datums, we store a flag and a checksum. */
 			name_offset = 1 + MAX_DIGEST_LEN;
-			sum_init(-1, checksum_seed);
+			sum_init(xattr_sum_type, checksum_seed);
 			sum_update(ptr, datum_len);
 			free(ptr);
 
@@ -382,7 +384,7 @@ static int64 xattr_lookup_hash(const item_list *xalp)
 	for (i = 0; i < xalp->count; i++) {
 		key += hashlittle(rxas[i].name, rxas[i].name_len);
 		if (rxas[i].datum_len > MAX_FULL_DATUM)
-			key += hashlittle(rxas[i].datum, MAX_DIGEST_LEN);
+			key += hashlittle(rxas[i].datum, xattr_sum_len);
 		else
 			key += hashlittle(rxas[i].datum, rxas[i].datum_len);
 	}
@@ -435,7 +437,7 @@ static int find_matching_xattr(const item_list *xalp)
 			if (rxas1[j].datum_len > MAX_FULL_DATUM) {
 				if (memcmp(rxas1[j].datum + 1,
 					   rxas2[j].datum + 1,
-					   MAX_DIGEST_LEN) != 0)
+					   xattr_sum_len) != 0)
 					break;
 			} else {
 				if (memcmp(rxas1[j].datum, rxas2[j].datum,
@@ -535,7 +537,7 @@ int send_xattr(int f, stat_x *sxp)
 #endif
 			write_buf(f, name, name_len);
 			if (rxa->datum_len > MAX_FULL_DATUM)
-				write_buf(f, rxa->datum + 1, MAX_DIGEST_LEN);
+				write_buf(f, rxa->datum + 1, xattr_sum_len);
 			else
 				write_bigbuf(f, rxa->datum, rxa->datum_len);
 		}
@@ -588,7 +590,7 @@ int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)
 		else if (snd_rxa->datum_len > MAX_FULL_DATUM) {
 			same = cmp == 0 && snd_rxa->datum_len == rec_rxa->datum_len
 			    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,
-				      MAX_DIGEST_LEN) == 0;
+				      xattr_sum_len) == 0;
 			/* Flag unrequested items that we need. */
 			if (!same && find_all && snd_rxa->datum[0] == XSTATE_ABBREV)
 				snd_rxa->datum[0] = XSTATE_TODO;
@@ -797,7 +799,7 @@ void receive_xattr(int f, struct file_struct *file)
 		rsync_xa *rxa;
 		size_t name_len = read_varint(f);
 		size_t datum_len = read_varint(f);
-		size_t dget_len = datum_len > MAX_FULL_DATUM ? 1 + MAX_DIGEST_LEN : datum_len;
+		size_t dget_len = datum_len > MAX_FULL_DATUM ? 1 + (size_t)xattr_sum_len : datum_len;
 		size_t extra_len = MIGHT_NEED_RPRE ? RPRE_LEN : 0;
 		if (SIZE_MAX - dget_len < extra_len || SIZE_MAX - dget_len - extra_len < name_len)
 			overflow_exit("receive_xattr");
@@ -812,7 +814,7 @@ void receive_xattr(int f, struct file_struct *file)
 			read_buf(f, ptr, dget_len);
 		else {
 			*ptr = XSTATE_ABBREV;
-			read_buf(f, ptr + 1, MAX_DIGEST_LEN);
+			read_buf(f, ptr + 1, xattr_sum_len);
 		}
 
 		if (saw_xattr_filter) {
@@ -958,7 +960,6 @@ static int rsync_xal_set(const char *fname, item_list *xalp,
 		name = rxas[i].name;
 
 		if (XATTR_ABBREV(rxas[i])) {
-			int sum_len;
 			/* See if the fnamecmp version is identical. */
 			len = name_len = rxas[i].name_len;
 			if ((ptr = get_xattr_data(fnamecmp, name, &len, 1)) == NULL) {
@@ -975,10 +976,10 @@ static int rsync_xal_set(const char *fname, item_list *xalp,
 				goto still_abbrev;
 			}
 
-			sum_init(-1, checksum_seed);
+			sum_init(xattr_sum_type, checksum_seed);
 			sum_update(ptr, len);
-			sum_len = sum_end(sum);
-			if (memcmp(sum, rxas[i].datum + 1, sum_len) != 0) {
+			sum_end(sum);
+			if (memcmp(sum, rxas[i].datum + 1, xattr_sum_len) != 0) {
 				free(ptr);
 				goto still_abbrev;
 			}
