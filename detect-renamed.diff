This patch adds the --detect-renamed option which makes rsync notice files
that either (1) match in size & modify-time (plus the basename, if possible)
or (2) match in size & checksum (when --checksum was also specified) and use
each match as an alternate basis file to speed up the transfer.

The algorithm attempts to scan the receiving-side's files in an efficient
manner.  If --delete[-before] is enabled, we'll take advantage of the
pre-transfer delete pass to prepare any alternate-basis-file matches we
might find.  If --delete-before is not enabled, rsync does the rename scan
during the regular file-sending scan (scanning each directory right before
the generator starts updating files from that dir).  In this latter mode,
rsync might delay the updating of a file (if no alternate-basis match was
yet found) until the full scan of the receiving side is complete, at which
point any delayed files are processed.

I chose to hard-link the alternate-basis files into a ".~tmp~" subdir that
takes advantage of rsync's pre-existing partial-dir logic.  This uses less
memory than trying to keep track of the matches internally, and also allows
any deletions or file-updates to occur normally without interfering with
these alternate-basis discoveries.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/detect-renamed.diff
    ./configure                                 (optional if already run)
    make

TODO:

  We need to never return a match from fattr_find() that has a basis
  file.  This will ensure that we don't try to give a renamed file to
  a file that can't use it, while missing out on giving it to a file
  that could use it.

--- old/compat.c
+++ new/compat.c
@@ -41,6 +41,7 @@ extern int checksum_seed;
 extern int basis_dir_cnt;
 extern int prune_empty_dirs;
 extern int protocol_version;
+extern int detect_renamed;
 extern int protect_args;
 extern int preserve_uid;
 extern int preserve_gid;
@@ -105,7 +106,7 @@ static void check_sub_protocol(void)
 void set_allow_inc_recurse(void)
 {
 	if (!recurse || delete_before || delete_after || use_qsort
-	 || (!am_sender && (delay_updates || prune_empty_dirs)))
+	 || (!am_sender && (delay_updates || prune_empty_dirs || detect_renamed)))
 		allow_inc_recurse = 0;
 	else if (am_server && !local_server
 	 && (!shell_cmd || strchr(shell_cmd, 'i') == NULL))
--- old/flist.c
+++ new/flist.c
@@ -61,6 +61,7 @@ extern int non_perishable_cnt;
 extern int prune_empty_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
+extern int detect_renamed;
 extern int protocol_version;
 extern int sanitize_paths;
 extern struct stats stats;
@@ -113,6 +114,8 @@ static int64 tmp_dev, tmp_ino;
 #endif
 static char tmp_sum[MAX_DIGEST_LEN];
 
+struct file_list the_fattr_list;
+
 static char empty_sum[MAX_DIGEST_LEN];
 static int flist_count_offset; /* for --delete --progress */
 static int dir_count = 0;
@@ -252,6 +255,45 @@ static int is_excluded(char *fname, int 
 	return 0;
 }
 
+static int fattr_compare(struct file_struct **file1, struct file_struct **file2)
+{
+	struct file_struct *f1 = *file1;
+	struct file_struct *f2 = *file2;
+	int64 len1 = F_LENGTH(f1), len2 = F_LENGTH(f2);
+	int diff;
+
+	if (!f1->basename || !S_ISREG(f1->mode) || !len1) {
+		if (!f2->basename || !S_ISREG(f2->mode) || !len2)
+			return 0;
+		return 1;
+	}
+	if (!f2->basename || !S_ISREG(f2->mode) || !len2)
+		return -1;
+
+	/* Don't use diff for values that are longer than an int. */
+	if (len1 != len2)
+		return len1 < len2 ? -1 : 1;
+
+	if (always_checksum) {
+		diff = u_memcmp(F_SUM(f1), F_SUM(f2), checksum_len);
+		if (diff)
+			return diff;
+	} else if (f1->modtime != f2->modtime)
+		return f1->modtime < f2->modtime ? -1 : 1;
+
+	diff = u_strcmp(f1->basename, f2->basename);
+	if (diff)
+		return diff;
+
+	if (f1->dirname == f2->dirname)
+		return 0;
+	if (!f1->dirname)
+		return -1;
+	if (!f2->dirname)
+		return 1;
+	return u_strcmp(f1->dirname, f2->dirname);
+}
+
 static void send_directory(int f, struct file_list *flist,
 			   char *fbuf, int len, int flags);
 
@@ -2154,6 +2196,25 @@ struct file_list *recv_file_list(int f)
 
 	clean_flist(flist, relative_paths);
 
+	if (detect_renamed) {
+		int j = flist->used;
+		the_fattr_list.used = j;
+		the_fattr_list.files = new_array(struct file_struct *, j);
+		if (!the_fattr_list.files)
+			out_of_memory("recv_file_list");
+		memcpy(the_fattr_list.files, flist->files,
+		       j * sizeof (struct file_struct *));
+		qsort(the_fattr_list.files, j,
+		      sizeof the_fattr_list.files[0], (int (*)())fattr_compare);
+		the_fattr_list.low = 0;
+		while (j-- > 0) {
+			struct file_struct *fp = the_fattr_list.files[j];
+			if (fp->basename && S_ISREG(fp->mode) && F_LENGTH(fp))
+				break;
+		}
+		the_fattr_list.high = j;
+	}
+
 	if (protocol_version < 30) {
 		/* Recv the io_error flag */
 		if (ignore_errors)
--- old/generator.c
+++ new/generator.c
@@ -79,6 +79,7 @@ extern char *basis_dir[];
 extern int compare_dest;
 extern int copy_dest;
 extern int link_dest;
+extern int detect_renamed;
 extern int whole_file;
 extern int list_only;
 extern int read_batch;
@@ -95,6 +96,7 @@ extern char *backup_suffix;
 extern int backup_suffix_len;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct filter_list_struct server_filter_list;
+extern struct file_list the_fattr_list;
 #ifdef ICONV_OPTION
 extern int ic_ndx;
 #endif
@@ -105,6 +107,7 @@ int maybe_ATTRS_REPORT = 0;
 
 static dev_t dev_zero;
 static int deletion_count = 0; /* used to implement --max-delete */
+static int unexplored_dirs = 1;
 static int deldelay_size = 0, deldelay_cnt = 0;
 static char *deldelay_buf = NULL;
 static int deldelay_fd = -1;
@@ -114,7 +117,8 @@ static int need_retouch_dir_times;
 static int need_retouch_dir_perms;
 static const char *solo_file = NULL;
 
-/* For calling delete_item() and delete_dir_contents(). */
+/* For calling delete_item(), delete_dir_contents(), and delete_in_dir(). */
+#define DEL_NO_DELETIONS	(1<<0)
 #define DEL_RECURSE		(1<<1) /* recurse */
 #define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
 
@@ -136,11 +140,121 @@ static int is_backup_file(char *fn)
 	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
 }
 
+/* Search for a regular file that matches either (1) the size & modified
+ * time (plus the basename, if possible) or (2) the size & checksum.  If
+ * we find an exact match down to the dirname, return -1 because we found
+ * an up-to-date file in the transfer, not a renamed file. */
+static int fattr_find(struct file_struct *f, char *fname)
+{
+	int low = the_fattr_list.low, high = the_fattr_list.high;
+	int mid, ok_match = -1, good_match = -1;
+	struct file_struct *fmid;
+	int diff;
+
+	while (low <= high) {
+		mid = (low + high) / 2;
+		fmid = the_fattr_list.files[mid];
+		if (F_LENGTH(fmid) != F_LENGTH(f)) {
+			if (F_LENGTH(fmid) < F_LENGTH(f))
+				low = mid + 1;
+			else
+				high = mid - 1;
+			continue;
+		}
+		if (always_checksum) {
+			/* We use the FLAG_FILE_SENT flag to indicate when we
+			 * have computed the checksum for an entry. */
+			if (!(f->flags & FLAG_FILE_SENT)) {
+				if (fmid->modtime == f->modtime
+				 && f_name_cmp(fmid, f) == 0)
+					return -1; /* assume we can't help */
+				file_checksum(fname, F_SUM(f), F_LENGTH(f));
+				f->flags |= FLAG_FILE_SENT;
+			}
+			diff = u_memcmp(F_SUM(fmid), F_SUM(f), checksum_len);
+			if (diff) {
+				if (diff < 0)
+					low = mid + 1;
+				else
+					high = mid - 1;
+				continue;
+			}
+		} else {
+			if (fmid->modtime != f->modtime) {
+				if (fmid->modtime < f->modtime)
+					low = mid + 1;
+				else
+					high = mid - 1;
+				continue;
+			}
+		}
+		ok_match = mid;
+		diff = u_strcmp(fmid->basename, f->basename);
+		if (diff == 0) {
+			good_match = mid;
+			if (fmid->dirname == f->dirname)
+				return -1; /* file is up-to-date */
+			if (!fmid->dirname) {
+				low = mid + 1;
+				continue;
+			}
+			if (!f->dirname) {
+				high = mid - 1;
+				continue;
+			}
+			diff = u_strcmp(fmid->dirname, f->dirname);
+			if (diff == 0)
+				return -1; /* file is up-to-date */
+		}
+		if (diff < 0)
+			low = mid + 1;
+		else
+			high = mid - 1;
+	}
+
+	return good_match >= 0 ? good_match : ok_match;
+}
+
+static void look_for_rename(struct file_struct *file, char *fname)
+{
+	struct file_struct *fp;
+	char *partialptr, *fn;
+	STRUCT_STAT st;
+	int ndx;
+
+	if (!partial_dir || (ndx = fattr_find(file, fname)) < 0)
+		return;
+
+	fp = the_fattr_list.files[ndx];
+	fn = f_name(fp, NULL);
+	/* We don't provide an alternate-basis file if there is a basis file. */
+	if (link_stat(fn, &st, 0) == 0)
+		return;
+
+	if (!dry_run) {
+		if ((partialptr = partial_dir_fname(fn)) == NULL
+		 || !handle_partial_dir(partialptr, PDIR_CREATE))
+			return;
+		/* We only use the file if we can hard-link it into our tmp dir. */
+		if (link(fname, partialptr) != 0) {
+			if (errno != EEXIST)
+				handle_partial_dir(partialptr, PDIR_DELETE);
+			return;
+		}
+	}
+
+	/* I think this falls into the -vv category with "%s is uptodate", etc. */
+	if (verbose > 1)
+		rprintf(FINFO, "found renamed: %s => %s\n", fname, fn);
+}
+
 /* Delete a file or directory.  If DEL_RECURSE is set in the flags, this will
  * delete recursively.
  *
  * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's
  * a directory! (The buffer is used for recursion, but returned unchanged.)
+ *
+ * Also note: --detect-rename may use this routine with DEL_NO_DELETIONS set!
  */
 static enum delret delete_item(char *fbuf, int mode, char *replace, int flags)
 {
@@ -162,6 +276,8 @@ static enum delret delete_item(char *fbu
 			goto check_ret;
 		/* OK: try to delete the directory. */
 	}
+	if (flags & DEL_NO_DELETIONS)
+		return DR_SUCCESS;
 
 	if (!replace && max_delete >= 0 && ++deletion_count > max_delete)
 		return DR_AT_LIMIT;
@@ -208,6 +324,8 @@ static enum delret delete_item(char *fbu
  * its contents, otherwise just checks for content.  Returns DR_SUCCESS or
  * DR_NOT_EMPTY.  Note that fname must point to a MAXPATHLEN buffer!  (The
  * buffer is used for recursion, but returned unchanged.)
+ *
+ * Note: --detect-rename may use this routine with DEL_NO_DELETIONS set!
  */
 static enum delret delete_dir_contents(char *fname, int flags)
 {
@@ -227,7 +345,9 @@ static enum delret delete_dir_contents(c
 	save_filters = push_local_filters(fname, dlen);
 
 	non_perishable_cnt = 0;
+	file_extra_cnt += SUM_EXTRA_CNT;
 	dirlist = get_dirlist(fname, dlen, 0);
+	file_extra_cnt -= SUM_EXTRA_CNT;
 	ret = non_perishable_cnt ? DR_NOT_EMPTY : DR_SUCCESS;
 
 	if (!dirlist->used)
@@ -264,6 +384,8 @@ static enum delret delete_dir_contents(c
 		if (S_ISDIR(fp->mode)
 		 && delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
 			ret = DR_NOT_EMPTY;
+		if (detect_renamed && S_ISREG(fp->mode))
+			look_for_rename(fp, fname);
 		if (delete_item(fname, fp->mode, NULL, flags) != DR_SUCCESS)
 			ret = DR_NOT_EMPTY;
 	}
@@ -416,13 +538,18 @@ static void do_delayed_deletions(char *d
  * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
  * MAXPATHLEN buffer with the name of the directory in it (the functions we
  * call will append names onto the end, but the old dir value will be restored
- * on exit). */
-static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t *fs_dev)
+ * on exit).
+ *
+ * Note:  --detect-rename may use this routine with DEL_NO_DELETIONS set!
+ */
+static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t *fs_dev,
+			  int flags)
 {
 	static int already_warned = 0;
 	struct file_list *dirlist;
-	char delbuf[MAXPATHLEN];
-	int dlen, i;
+	char *p, delbuf[MAXPATHLEN];
+	unsigned remainder;
+	int dlen, i, restore_dot = 0;
 
 	if (!fbuf) {
 		change_local_filter_dir(NULL, 0, 0);
@@ -432,21 +559,28 @@ static void delete_in_dir(char *fbuf, st
 	if (verbose > 2)
 		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
 
+	flags |= DEL_RECURSE;
+
 	if (allowed_lull)
 		maybe_send_keepalive();
 
 	if (io_error && !ignore_errors) {
-		if (already_warned)
+		if (!already_warned) {
+			rprintf(FINFO,
+			    "IO error encountered -- skipping file deletion\n");
+			already_warned = 1;
+		}
+		if (!detect_renamed)
 			return;
-		rprintf(FINFO,
-			"IO error encountered -- skipping file deletion\n");
-		already_warned = 1;
-		return;
+		flags |= DEL_NO_DELETIONS;
 	}
 
 	dlen = strlen(fbuf);
 	change_local_filter_dir(fbuf, dlen, F_DEPTH(file));
 
+	if (detect_renamed)
+		unexplored_dirs--;
+
 	if (one_file_system) {
 		if (file->flags & FLAG_TOP_DIR)
 			filesystem_dev = *fs_dev;
@@ -456,6 +590,14 @@ static void delete_in_dir(char *fbuf, st
 
 	dirlist = get_dirlist(fbuf, dlen, 0);
 
+	p = fbuf + dlen;
+	if (dlen == 1 && *fbuf == '.') {
+		restore_dot = 1;
+		p = fbuf;
+	} else if (dlen != 1 || *fbuf != '/')
+		*p++ = '/';
+	remainder = MAXPATHLEN - (p - fbuf);
+
 	/* If an item in dirlist is not found in flist, delete it
 	 * from the filesystem. */
 	for (i = dirlist->used; i--; ) {
@@ -468,16 +610,25 @@ static void delete_in_dir(char *fbuf, st
 					f_name(fp, NULL));
 			continue;
 		}
+		if (detect_renamed && S_ISREG(fp->mode)) {
+			strlcpy(p, fp->basename, remainder);
+			look_for_rename(fp, fbuf);
+		}
 		if (flist_find(cur_flist, fp) < 0) {
 			f_name(fp, delbuf);
-			if (delete_during == 2) {
+			if (delete_during == 2 && !(flags & DEL_NO_DELETIONS)) {
 				if (!remember_delete(fp, delbuf))
 					break;
 			} else
-				delete_item(delbuf, fp->mode, NULL, DEL_RECURSE);
-		}
+				delete_item(delbuf, fp->mode, NULL, flags);
+		} else if (detect_renamed && S_ISDIR(fp->mode))
+			unexplored_dirs++;
 	}
 
+	if (restore_dot)
+		fbuf[0] = '.';
+	fbuf[dlen] = '\0';
+
 	flist_free(dirlist);
 }
 
@@ -507,9 +658,9 @@ static void do_delete_pass(void)
 		 || !S_ISDIR(st.st_mode))
 			continue;
 
-		delete_in_dir(fbuf, file, &st.st_dev);
+		delete_in_dir(fbuf, file, &st.st_dev, 0);
 	}
-	delete_in_dir(NULL, NULL, &dev_zero);
+	delete_in_dir(NULL, NULL, &dev_zero, 0);
 
 	if (do_progress && !am_server)
 		rprintf(FINFO, "                    \r");
@@ -1106,6 +1257,7 @@ static void list_file_entry(struct file_
 	}
 }
 
+static struct bitbag *delayed_bits = NULL;
 static int phase = 0;
 static int dflt_perms;
 
@@ -1350,8 +1502,12 @@ static void recv_generator(char *fname, 
 			}
 		}
 		else if (delete_during && f_out != -1 && !phase && dry_run < 2
-		    && (file->flags & FLAG_CONTENT_DIR))
-			delete_in_dir(fname, file, &real_sx.st.st_dev);
+		    && (file->flags & FLAG_CONTENT_DIR)) {
+			if (detect_renamed && real_ret != 0)
+				unexplored_dirs++;
+			delete_in_dir(fname, file, &real_sx.st.st_dev,
+				      delete_during < 0 ? DEL_NO_DELETIONS : 0);
+		}
 		goto cleanup;
 	}
 
@@ -1629,8 +1785,14 @@ static void recv_generator(char *fname, 
 			goto cleanup;
 		}
 #endif
-		if (stat_errno == ENOENT)
+		if (stat_errno == ENOENT) {
+			if (detect_renamed && unexplored_dirs > 0
+			 && F_LENGTH(file)) {
+				bitbag_set_bit(delayed_bits, ndx);
+				return;
+			}
 			goto notify_others;
+		}
 		rsyserr(FERROR, stat_errno, "recv_generator: failed to stat %s",
 			full_fname(fname));
 		goto cleanup;
@@ -1966,6 +2128,12 @@ void generate_files(int f_out, const cha
 	if (verbose > 2)
 		rprintf(FINFO, "generator starting pid=%ld\n", (long)getpid());
 
+	if (detect_renamed) {
+		delayed_bits = bitbag_create(cur_flist->used);
+		if (!delete_before && !delete_during)
+			delete_during = -1;
+	}
+
 	if (delete_before && !solo_file && cur_flist->used > 0)
 		do_delete_pass();
 	if (delete_during == 2) {
@@ -1976,7 +2144,7 @@ void generate_files(int f_out, const cha
 	}
 	do_progress = 0;
 
-	if (append_mode > 0 || whole_file < 0)
+	if (append_mode > 0 || detect_renamed || whole_file < 0)
 		whole_file = 0;
 	if (verbose >= 2) {
 		rprintf(FINFO, "delta-transmission %s\n",
@@ -2014,7 +2182,7 @@ void generate_files(int f_out, const cha
 						dirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
 					} else
 						dirdev = MAKEDEV(0, 0);
-					delete_in_dir(f_name(fp, fbuf), fp, &dirdev);
+					delete_in_dir(f_name(fp, fbuf), fp, &dirdev, 0);
 				}
 			}
 		}
@@ -2059,7 +2227,21 @@ void generate_files(int f_out, const cha
 	} while ((cur_flist = cur_flist->next) != NULL);
 
 	if (delete_during)
-		delete_in_dir(NULL, NULL, &dev_zero);
+		delete_in_dir(NULL, NULL, &dev_zero, 0);
+	if (detect_renamed) {
+		if (delete_during < 0)
+			delete_during = 0;
+		detect_renamed = 0;
+
+		for (i = -1; (i = bitbag_next_bit(delayed_bits, i)) >= 0; ) {
+			struct file_struct *file = cur_flist->files[i];
+			if (local_name)
+				strlcpy(fbuf, local_name, sizeof fbuf);
+			else
+				f_name(file, fbuf);
+			recv_generator(fbuf, file, i, itemizing, code, f_out);
+		}
+	}
 	phase++;
 	if (verbose > 2)
 		rprintf(FINFO, "generate_files phase=%d\n", phase);
--- old/options.c
+++ new/options.c
@@ -80,6 +80,7 @@ int am_generator = 0;
 int am_starting_up = 1;
 int relative_paths = -1;
 int implied_dirs = 1;
+int detect_renamed = 0;
 int numeric_ids = 0;
 int allow_8bit_chars = 0;
 int force_delete = 0;
@@ -383,6 +384,7 @@ void usage(enum logcode F)
   rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
+  rprintf(F,"     --detect-renamed        try to find renamed files to speed up the transfer\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
   rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
@@ -561,6 +563,7 @@ static struct poptOption long_options[] 
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
+  {"detect-renamed",   0,  POPT_ARG_NONE,   &detect_renamed, 0, 0, 0 },
   {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
   {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
   {"no-compress",      0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
@@ -1532,7 +1535,7 @@ int parse_arguments(int *argc_p, const c
 		inplace = 1;
 	}
 
-	if (delay_updates && !partial_dir)
+	if ((delay_updates || detect_renamed) && !partial_dir)
 		partial_dir = tmp_partialdir;
 
 	if (inplace) {
@@ -1541,6 +1544,7 @@ int parse_arguments(int *argc_p, const c
 			snprintf(err_buf, sizeof err_buf,
 				 "--%s cannot be used with --%s\n",
 				 append_mode ? "append" : "inplace",
+				 detect_renamed ? "detect-renamed" :
 				 delay_updates ? "delay-updates" : "partial-dir");
 			return 0;
 		}
@@ -1885,6 +1889,8 @@ void server_options(char **args, int *ar
 			args[ac++] = "--super";
 		if (size_only)
 			args[ac++] = "--size-only";
+		if (detect_renamed)
+			args[ac++] = "--detect-renamed";
 	} else {
 		if (skip_compress) {
 			if (asprintf(&arg, "--skip-compress=%s", skip_compress) < 0)
--- old/rsync.yo
+++ new/rsync.yo
@@ -384,6 +384,7 @@ to the detailed description below for a 
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
  -y, --fuzzy                 find similar file for basis if no dest file
+     --detect-renamed        try to find renamed files to speed the xfer
      --compare-dest=DIR      also compare received files relative to DIR
      --copy-dest=DIR         ... and include copies of unchanged files
      --link-dest=DIR         hardlink to files in DIR when unchanged
@@ -1430,6 +1431,21 @@ Note that the use of the bf(--delete) op
 fuzzy-match files, so either use bf(--delete-after) or specify some
 filename exclusions if you need to prevent this.
 
+dit(bf(--detect-renamed)) With this option, for each new source file
+(call it em(src/S)), rsync looks for a file em(dest/D) anywhere in the
+destination that passes the quick check with em(src/S).  If such a em(dest/D)
+is found, rsync uses it as an alternate basis for transferring em(S).  The
+idea is that if em(src/S) was renamed from em(src/D) (as opposed to em(src/S)
+passing the quick check with em(dest/D) by coincidence), the delta-transfer
+algorithm will find that all the data matches between em(src/S) and em(dest/D),
+and the transfer will be really fast.
+
+By default, alternate-basis files are hard-linked into a directory named
+".~tmp~" in each file's destination directory, but if you've specified
+the bf(--partial-dir) option, that directory will be used instead.  These
+potential alternate-basis files will be removed as the transfer progresses.
+This option conflicts with bf(--inplace) and bf(--append).
+
 dit(bf(--compare-dest=DIR)) This option instructs rsync to use em(DIR) on
 the destination machine as an additional hierarchy to compare destination
 files against doing transfers (if the files are missing in the destination
--- old/util.c
+++ new/util.c
@@ -1030,6 +1030,32 @@ int handle_partial_dir(const char *fname
 	return 1;
 }
 
+/* We need to supply our own strcmp function for file list comparisons
+ * to ensure that signed/unsigned usage is consistent between machines. */
+int u_strcmp(const char *p1, const char *p2)
+{
+        for ( ; *p1; p1++, p2++) {
+		if (*p1 != *p2)
+			break;
+	}
+
+	return (int)*(uchar*)p1 - (int)*(uchar*)p2;
+}
+
+/* We need a memcmp function compares unsigned-byte values. */
+int u_memcmp(const void *p1, const void *p2, size_t len)
+{
+	const uchar *u1 = p1;
+	const uchar *u2 = p2;
+
+	while (len--) {
+		if (*u1 != *u2)
+			return (int)*u1 - (int)*u2;
+	}
+
+	return 0;
+}
+
 /**
  * Determine if a symlink points outside the current directory tree.
  * This is considered "unsafe" because e.g. when mirroring somebody
