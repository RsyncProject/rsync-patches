--- generator.c	18 May 2004 08:50:17 -0000	1.85
+++ generator.c	5 Jun 2004 15:56:04 -0000
@@ -26,6 +26,7 @@
 extern int verbose;
 extern int dry_run;
 extern int relative_paths;
+extern int keep_dirlinks;
 extern int preserve_links;
 extern int am_root;
 extern int preserve_devices;
@@ -302,6 +303,15 @@ void recv_generator(char *fname, struct 
 		return;
 	}
 
+#if SUPPORT_LINKS
+	if (statret == 0 && keep_dirlinks
+	    && S_ISLNK(st.st_mode) && S_ISDIR(file->mode)) {
+		STRUCT_STAT st2;
+		if (do_stat(fname, &st2) == 0 && S_ISDIR(st2.st_mode))
+		    st = st2;
+	}
+#endif
+
 	if (statret == 0 &&
 	    !preserve_perms &&
 	    (S_ISDIR(st.st_mode) == S_ISDIR(file->mode))) {
@@ -329,18 +339,23 @@ void recv_generator(char *fname, struct 
 			}
 			statret = -1;
 		}
-		if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
-			if (!(relative_paths && errno == ENOENT
-			    && create_directory_path(fname, orig_umask) == 0
-			    && do_mkdir(fname, file->mode) == 0)) {
-				rsyserr(FERROR, errno,
-					"recv_generator: mkdir %s failed",
-					full_fname(fname));
+		if (statret != 0) {
+			if (do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
+				if (!(relative_paths && errno == ENOENT
+				    && create_directory_path(fname, orig_umask) == 0
+				    && do_mkdir(fname, file->mode) == 0)) {
+					rsyserr(FERROR, errno,
+						"recv_generator: mkdir %s failed",
+						full_fname(fname));
+				}
 			}
+			statret = link_stat(fname, &st);
+			if (statret != 0)
+				return;
 		}
-		/* f_out is set to -1 when doing final directory
-		   permission and modification time repair */
-		if (set_perms(fname,file,NULL,0) && verbose && (f_out != -1))
+		/* f_out is set to -1 when doing final directory-permission
+		 * and modification-time repair. */
+		if (set_perms(fname, file, &st, 0) && verbose && (f_out != -1))
 			rprintf(FINFO,"%s/\n",fname);
 		return;
 	}
--- options.c	27 May 2004 21:51:53 -0000	1.153
+++ options.c	5 Jun 2004 15:56:04 -0000
@@ -38,6 +38,7 @@ int make_backups = 0;
 int whole_file = -1;
 
 int archive_mode = 0;
+int keep_dirlinks = 0;
 int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
@@ -232,6 +233,7 @@ void usage(enum logcode F)
   rprintf(F,"     --backup-dir            make backups into this directory\n");
   rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
+  rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            copy the referent of all symlinks\n");
   rprintf(F,"     --copy-unsafe-links     copy the referent of \"unsafe\" symlinks\n");
@@ -338,6 +340,7 @@ static struct poptOption long_options[] 
   {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
+  {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
   {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
   {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
@@ -818,6 +821,8 @@ void server_options(char **args,int *arg
 		argstr[x++] = 'l';
 	if (copy_links)
 		argstr[x++] = 'L';
+	if (keep_dirlinks && am_sender)
+		argstr[x++] = 'K';
 
 	if (whole_file > 0)
 		argstr[x++] = 'W';
--- rsync.yo	21 May 2004 09:44:32 -0000	1.170
+++ rsync.yo	5 Jun 2004 15:56:05 -0000
@@ -289,6 +289,7 @@ verb(
      --backup-dir            make backups into this directory
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don't overwrite newer files)
+ -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of all symlinks
      --copy-unsafe-links     copy the referent of "unsafe" symlinks
@@ -479,6 +480,10 @@ symlink where the destination has a file
 regardless of the timestamps.  This might change in the future (feel
 free to comment on this on the mailing list if you have an opinion).
 
+dit(bf(-K, --keep-dirlinks)) On the receiving side, if a symlink is
+pointing to a directory, it will be treated as matching a directory
+from the sender.
+
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
