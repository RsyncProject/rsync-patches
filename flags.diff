This patch provides --flags, which preserves the st_flags field.
Modified from a patch that was written by Rolf Grossmann.

To use this patch, run these commands for a successful build:

    patch -p1 <patches/flags.diff
    ./prepare-source
    ./configure
    make

TODO: fix --delete-delay to work with --flags option.

--- old/compat.c
+++ new/compat.c
@@ -50,6 +50,8 @@ void setup_protocol(int f_out,int f_in)
 		preserve_uid = ++file_extra_cnt;
 	if (preserve_gid)
 		preserve_gid = ++file_extra_cnt;
+	if (preserve_fileflags)
+		preserve_fileflags = ++file_extra_cnt;
 
 	if (remote_protocol == 0) {
 		if (!read_batch)
--- old/configure.in
+++ new/configure.in
@@ -554,7 +554,7 @@ AC_CHECK_FUNCS(waitpid wait4 getcwd strd
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
-    strerror putenv iconv_open locale_charset nl_langinfo \
+    chflags strerror putenv iconv_open locale_charset nl_langinfo \
     sigaction sigprocmask)
 
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
--- old/flist.c
+++ new/flist.c
@@ -45,6 +45,7 @@ extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_specials;
+extern int preserve_fileflags;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int relative_paths;
@@ -314,6 +315,9 @@ static void send_file_entry(struct file_
 {
 	static time_t modtime;
 	static mode_t mode;
+#ifdef SUPPORT_FLAGS
+	static uint32 fileflags;
+#endif
 	static int64 dev;
 	static dev_t rdev;
 	static uint32 rdev_major;
@@ -333,6 +337,12 @@ static void send_file_entry(struct file_
 		flags |= XMIT_SAME_MODE;
 	else
 		mode = file->mode;
+#ifdef SUPPORT_FLAGS
+ 	if (file->fileflags == fileflags)
+		flags |= XMIT_SAME_FLAGS;
+	else
+		fileflags = file->fileflags;
+#endif
 	if ((preserve_devices && IS_DEVICE(mode))
 	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
@@ -434,6 +444,10 @@ static void send_file_entry(struct file_
 		write_int(f, modtime);
 	if (!(flags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
+#ifdef SUPPORT_FLAGS
+ 	if (preserve_fileflags && !(flags & XMIT_SAME_FLAGS))
+		write_int(f, (int)fileflags);
+#endif
 	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
 		if (!numeric_ids)
 			add_uid(uid);
@@ -503,6 +517,9 @@ static struct file_struct *recv_file_ent
 {
 	static time_t modtime;
 	static mode_t mode;
+#ifdef SUPPORT_FLAGS
+ 	static uint32 fileflags;
+#endif
 	static int64 dev;
 	static dev_t rdev;
 	static uint32 rdev_major;
@@ -610,9 +627,12 @@ static struct file_struct *recv_file_ent
 		modtime = (time_t)read_int(f);
 	if (!(flags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
-
 	if (chmod_modes && !S_ISLNK(mode))
 		mode = tweak_mode(mode, chmod_modes);
+#ifdef SUPPORT_FLAGS
+ 	if (preserve_fileflags && !(flags & XMIT_SAME_FLAGS))
+		fileflags = (uint32)read_int(f);
+#endif
 
 	if (preserve_uid && !(flags & XMIT_SAME_UID))
 		uid = (uid_t)read_int(f);
@@ -696,6 +716,10 @@ static struct file_struct *recv_file_ent
 		OPT_EXTRA(file, 0)->unum = (uint32)(file_length >> 32);
 	}
 	file->mode = mode;
+#ifdef SUPPORT_FLAGS
+	if (preserve_fileflags)
+		F_FFLAGS(file) = fileflags;
+#endif
 	if (preserve_uid)
 		F_UID(file) = uid;
 	if (preserve_gid)
@@ -998,6 +1022,10 @@ struct file_struct *make_file(const char
 		OPT_EXTRA(file, 0)->unum = (uint32)(st.st_size >> 32);
 	}
 	file->mode = st.st_mode;
+#ifdef SUPPORT_FLAGS
+	if (preserve_fileflags)
+		F_FFLAGS(file) = st.st_flags;
+#endif
 	if (preserve_uid)
 		F_UID(file) = st.st_uid;
 	if (preserve_gid)
--- old/generator.c
+++ new/generator.c
@@ -103,6 +103,12 @@ static char *deldelay_buf = NULL;
 static int deldelay_fd = -1;
 static BOOL solo_file = 0;
 
+#ifdef SUPPORT_FLAGS
+#define FILEFLAGS(ff) ff
+#else
+#define FILEFLAGS(ff) 0
+#endif
+
 /* For calling delete_item() and delete_dir_contents(). */
 #define DEL_RECURSE		(1<<1) /* recurse */
 #define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
@@ -118,7 +124,6 @@ enum delret {
 /* Forward declaration for delete_item(). */
 static enum delret delete_dir_contents(char *fname, int flags);
 
-
 static int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
@@ -131,17 +136,20 @@ static int is_backup_file(char *fn)
  * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's
  * a directory! (The buffer is used for recursion, but returned unchanged.)
  */
-static enum delret delete_item(char *fbuf, int mode, char *replace, int flags)
+static enum delret delete_item(char *fbuf, int mode, uint32 fileflags, char *replace, int flags)
 {
 	enum delret ret;
 	char *what;
 	int ok;
 
 	if (verbose > 2) {
-		rprintf(FINFO, "delete_item(%s) mode=%o flags=%d\n",
-			fbuf, mode, flags);
+		rprintf(FINFO, "delete_item(%s) mode=%o fileflags=%o flags=%d\n",
+			fbuf, mode, fileflags, flags);
 	}
 
+#ifdef SUPPORT_FLAGS
+	make_mutable(fbuf, mode, fileflags);
+#endif
 	if (S_ISDIR(mode) && !(flags & DEL_DIR_IS_EMPTY)) {
 		ignore_perishable = 1;
 		/* If DEL_RECURSE is not set, this just reports emptiness. */
@@ -253,7 +261,7 @@ static enum delret delete_dir_contents(c
 		if (S_ISDIR(fp->mode)
 		 && delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
 			ret = DR_NOT_EMPTY;
-		if (delete_item(fname, fp->mode, NULL, flags) != DR_SUCCESS)
+		if (delete_item(fname, fp->mode, FILEFLAGS(fp->fileflags), NULL, flags) != DR_SUCCESS)
 			ret = DR_NOT_EMPTY;
 	}
 
@@ -309,8 +317,9 @@ static int remember_delete(struct file_s
 	
 	while (1) {
 		len = snprintf(deldelay_buf + deldelay_cnt,
-			       deldelay_size - deldelay_cnt,
-			       "%x %s%c", (int)file->mode, fname, '\0');
+			       deldelay_size - deldelay_cnt, "%x %x %s%c",
+			       (int)file->mode, (int)FILEFLAGS(file->fileflags),
+			       fname, '\0');
 		if ((deldelay_cnt += len) <= deldelay_size)
 			break;
 		if (deldelay_fd < 0 && !start_delete_delay_temp())
@@ -323,7 +332,7 @@ static int remember_delete(struct file_s
 	return 1;
 }
 
-static int read_delay_line(char *buf)
+static int read_delay_line(char *buf, int *fileflags_p)
 {
 	static int read_pos = 0;
 	int j, len, mode;
@@ -365,7 +374,7 @@ static int read_delay_line(char *buf)
 
 	bp = deldelay_buf + read_pos;
 
-	if (sscanf(bp, "%x ", &mode) != 1) {
+	if (sscanf(bp, "%x %x ", &mode, fileflags_p) != 2) {
 	  invalid_data:
 		rprintf(FERROR, "ERROR: invalid data in delete-delay file.\n");
 		return -1;
@@ -388,15 +397,15 @@ static int read_delay_line(char *buf)
 
 static void do_delayed_deletions(char *delbuf)
 {
-	int mode;
+	int mode, fileflags;
 
 	if (deldelay_fd >= 0) {
 		if (deldelay_cnt && !flush_delete_delay())
 			return;
 		lseek(deldelay_fd, 0, 0);
 	}
-	while ((mode = read_delay_line(delbuf)) >= 0)
-		delete_item(delbuf, mode, NULL, DEL_RECURSE);
+	while ((mode = read_delay_line(delbuf, &fileflags)) >= 0)
+		delete_item(delbuf, mode, fileflags, NULL, DEL_RECURSE);
 	if (deldelay_fd >= 0)
 		close(deldelay_fd);
 }
@@ -477,7 +486,7 @@ static void delete_in_dir(struct file_li
 				if (!remember_delete(fp, delbuf))
 					break;
 			} else
-				delete_item(delbuf, fp->mode, NULL, DEL_RECURSE);
+				delete_item(delbuf, fp->mode, FILEFLAGS(fp->fileflags), NULL, DEL_RECURSE);
 		}
 	}
 
@@ -1181,7 +1190,7 @@ static void recv_generator(char *fname, 
 		 * we need to delete it.  If it doesn't exist, then
 		 * (perhaps recursively) create it. */
 		if (statret == 0 && !S_ISDIR(st.st_mode)) {
-			if (delete_item(fname, st.st_mode, "directory", del_opts) != 0)
+			if (delete_item(fname, st.st_mode, FILEFLAGS(st.st_flags), "directory", del_opts) != 0)
 				return;
 			statret = -1;
 		}
@@ -1278,7 +1287,7 @@ static void recv_generator(char *fname, 
 			}
 			/* Not the right symlink (or not a symlink), so
 			 * delete it. */
-			if (delete_item(fname, st.st_mode, "symlink", del_opts) != 0)
+			if (delete_item(fname, st.st_mode, FILEFLAGS(st.st_flags), "symlink", del_opts) != 0)
 				return;
 		} else if (basis_dir[0] != NULL) {
 			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &st,
@@ -1355,7 +1364,7 @@ static void recv_generator(char *fname, 
 					goto return_with_success;
 				return;
 			}
-			if (delete_item(fname, st.st_mode, t, del_opts) != 0)
+			if (delete_item(fname, st.st_mode, FILEFLAGS(st.st_flags), t, del_opts) != 0)
 				return;
 		} else if (basis_dir[0] != NULL) {
 			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &st,
@@ -1444,7 +1453,7 @@ static void recv_generator(char *fname, 
 	fnamecmp_type = FNAMECMP_FNAME;
 
 	if (statret == 0 && !S_ISREG(st.st_mode)) {
-		if (delete_item(fname, st.st_mode, "regular file", del_opts) != 0)
+		if (delete_item(fname, st.st_mode, FILEFLAGS(st.st_flags), "regular file", del_opts) != 0)
 			return;
 		statret = -1;
 		stat_errno = ENOENT;
--- old/options.c
+++ new/options.c
@@ -48,6 +48,7 @@ int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_perms = 0;
+int preserve_fileflags = 0;
 int preserve_executability = 0;
 int preserve_devices = 0;
 int preserve_specials = 0;
@@ -200,6 +201,7 @@ static void print_rsync_version(enum log
 	char const *hardlinks = "no ";
 	char const *links = "no ";
 	char const *ipv6 = "no ";
+ 	char const *fileflags = "no ";
 	STRUCT_STAT *dumstat;
 
 #ifdef HAVE_SOCKETPAIR
@@ -222,6 +224,10 @@ static void print_rsync_version(enum log
 	ipv6 = "";
 #endif
 
+#ifdef SUPPORT_FLAGS
+	fileflags = "";
+#endif
+
 	rprintf(f, "%s  version %s  protocol version %d\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
 	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
@@ -232,8 +238,8 @@ static void print_rsync_version(enum log
 		(int)(sizeof (int64) * 8));
 	rprintf(f, "    %ssocketpairs, %shardlinks, %ssymlinks, %sIPv6, batchfiles, %sinplace,\n",
 		got_socketpair, hardlinks, links, ipv6, have_inplace);
-	rprintf(f, "    %sappend\n",
-		have_inplace);
+	rprintf(f, "    %sappend, %sfile-flags\n",
+		have_inplace, fileflags);
 
 #ifdef MAINTAINER_MODE
 	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
@@ -299,6 +305,7 @@ void usage(enum logcode F)
   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
+  rprintf(F,"     --fileflags             preserve file-flags\n");
   rprintf(F," -E, --executability         preserve the file's executability\n");
   rprintf(F,"     --chmod=CHMOD           affect file and/or directory permissions\n");
   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
@@ -420,6 +427,8 @@ static struct poptOption long_options[] 
   {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
   {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+  {"fileflags",        0,  POPT_ARG_VAL,    &preserve_fileflags, 1, 0, 0 },
+  {"no-fileflags",     0,  POPT_ARG_VAL,    &preserve_fileflags, 0, 0, 0 },
   {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
@@ -1125,6 +1134,15 @@ int parse_arguments(int *argc, const cha
 	}
 #endif
 
+#ifndef SUPPORT_FLAGS
+	if (preserve_fileflags) {
+		snprintf(err_buf, sizeof err_buf,
+			 "file flags are not supported on this %s\n",
+			 am_server ? "server" : "client");
+		return 0;
+	}
+#endif
+
 	if (write_batch && read_batch) {
 		snprintf(err_buf, sizeof err_buf,
 			"--write-batch and --read-batch can not be used together\n");
@@ -1579,6 +1597,9 @@ void server_options(char **args,int *arg
 	if (xfer_dirs && !recurse && delete_mode && am_sender)
 		args[ac++] = "--no-r";
 
+	if (preserve_fileflags)
+		args[ac++] = "--flags";
+
 	if (do_compression && def_compress_level != Z_DEFAULT_COMPRESSION) {
 		if (asprintf(&arg, "--compress-level=%d", def_compress_level) < 0)
 			goto oom;
--- old/rsync.c
+++ new/rsync.c
@@ -30,9 +30,12 @@
 #include <langinfo.h>
 #endif
 
+#define NOCHANGE_FLAGS (UF_IMMUTABLE|UF_APPEND|UF_NOUNLINK|SF_IMMUTABLE|SF_APPEND|SF_NOUNLINK)
+
 extern int verbose;
 extern int dry_run;
 extern int preserve_perms;
+extern int preserve_fileflags;
 extern int preserve_executability;
 extern int preserve_times;
 extern int omit_dir_times;
@@ -176,6 +179,41 @@ mode_t dest_mode(mode_t flist_mode, mode
 	return new_mode;
 }
 
+#ifdef SUPPORT_FLAGS
+/* Set a file's st_flags. */
+static int set_fileflags(const char *fname, uint32 fileflags)
+{
+	if (do_chflags(fname, fileflags) != 0) {
+		rsyserr(FERROR, errno,
+			"failed to set file flags on %s",
+			full_fname(fname));
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Remove immutable flags from an object, so it can be altered/removed. */
+void make_mutable(char *fname, mode_t mode, uint32 fileflags)
+{
+	if (!preserve_fileflags && S_ISLNK(mode))
+		return;
+
+	if (fileflags & NOCHANGE_FLAGS)
+		set_fileflags(fname, fileflags & ~NOCHANGE_FLAGS);
+}
+
+/* Undo a prior make_mutable() call. */
+void undo_make_mutable(char *fname, mode_t mode, uint32 fileflags)
+{
+	if (!preserve_fileflags && S_ISLNK(mode))
+		return;
+
+	if (fileflags & NOCHANGE_FLAGS)
+		set_fileflags(fname, fileflags);
+}
+#endif
+
 int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
 		   int flags)
 {
@@ -274,6 +312,15 @@ int set_file_attrs(char *fname, struct f
 	}
 #endif
 
+#ifdef SUPPORT_FLAGS
+	if (preserve_fileflags && !S_ISLNK(st->st_mode)
+	 && st->st_flags != file->fileflags) {
+		if (!set_fileflags(fname, file->fileflags))
+			return 0;
+		updated = 1;
+	}
+#endif
+
 	if (verbose > 1 && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
@@ -321,6 +368,9 @@ void finish_transfer(char *fname, char *
 	set_file_attrs(fnametmp, file, NULL,
 		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
 
+#ifdef SUPPORT_FLAGS
+	make_mutable(fnametmp, file->mode, file->fileflags);
+#endif
 	/* move tmp file over real file */
 	if (verbose > 2)
 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
@@ -335,6 +385,9 @@ void finish_transfer(char *fname, char *
 	}
 	if (ret == 0) {
 		/* The file was moved into place (not copied), so it's done. */
+#ifdef SUPPORT_FLAGS
+		undo_make_mutable(fname, file->mode, file->fileflags);
+#endif
 		return;
 	}
 	/* The file was copied, so tweak the perms of the copied file.  If it
--- old/rsync.h
+++ new/rsync.h
@@ -55,6 +55,7 @@
 #define XMIT_SAME_DEV_pre30 (1<<10)	/* protocols < 30 */
 #define XMIT_HLINK_FIRST (1<<10)	/* protocols >= 30 */
 #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
+#define XMIT_SAME_FLAGS (1<<12)
 
 /* These flags are used in the live flist data. */
 
@@ -374,6 +375,10 @@ enum msgcode {
 #endif
 #endif
 
+#ifdef HAVE_CHFLAGS
+#define SUPPORT_FLAGS 1
+#endif
+
 /* Find a variable that is either exactly 32-bits or longer.
  * If some code depends on 32-bit truncation, it will need to
  * take special action in a "#if SIZEOF_INT32 > 4" section. */
@@ -551,6 +556,7 @@ struct file_struct {
 extern int file_extra_cnt;
 extern int preserve_uid;
 extern int preserve_gid;
+extern int preserve_fileflags;
 
 #define FILE_STRUCT_LEN (offsetof(struct file_struct, basename))
 #define EXTRA_LEN (sizeof (union file_extras))
@@ -583,6 +589,7 @@ extern int preserve_gid;
 /* When the associated option is on, all entries will have these present: */
 #define F_UID(f) REQ_EXTRA(f, preserve_uid)->unum
 #define F_GID(f) REQ_EXTRA(f, preserve_gid)->unum
+#define F_FFLAGS(f) REQ_EXTRA(f, preserve_fileflags).num
 
 /* These items are per-entry optional and mutally exclusive: */
 #define F_HL_GNUM(f) OPT_EXTRA(f, LEN64_BUMP(f))->num
--- old/rsync.yo
+++ new/rsync.yo
@@ -321,6 +321,7 @@ to the detailed description below for a 
  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
+     --flags                 preserve file flags
  -E, --executability         preserve executability
      --chmod=CHMOD           affect file and/or directory permissions
  -o, --owner                 preserve owner (super-user only)
@@ -510,7 +511,9 @@ specified, in which case bf(-r) is not i
 
 Note that bf(-a) bf(does not preserve hardlinks), because
 finding multiply-linked files is expensive.  You must separately
-specify bf(-H).
+specify bf(-H).  Note also that for compatibility, bf(-a)
+currently bf(does not include --flags) (see there) to include preserving
+change file flags (if supported by the OS).
 
 dit(--no-OPTION) You may turn off one or more implied options by prefixing
 the option name with "no-".  Not all options may be prefixed with a "no-":
@@ -805,6 +808,13 @@ quote(itemization(
 
 If bf(--perms) is enabled, this option is ignored.
 
+dit(bf(--flags)) This option causes rsync to update the change file flags
+to be the same as the source file, if your OS supports the bf(chflags)(2)
+system call.  In any case, an attempt is made to remove flags that would
+prevent a file to be altered.  Some flags can only be altered by the
+super-user and can only be unset below a certain secure-level (usually
+single-user mode).
+
 dit(bf(--chmod)) This option tells rsync to apply one or more
 comma-separated "chmod" strings to the permission of the files in the
 transfer.  The resulting value is treated as though it was the permissions
--- old/syscall.c
+++ new/syscall.c
@@ -153,6 +153,15 @@ int do_chmod(const char *path, mode_t mo
 }
 #endif
 
+#ifdef SUPPORT_FLAGS
+int do_chflags(const char *path, u_long flags)
+{
+	if (dry_run) return 0;
+	RETURN_ERROR_IF_RO_OR_LO;
+	return chflags(path, flags);
+}
+#endif
+
 int do_rename(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
