This patch sends the new fnamecmp_type value from the generator to the
sender if --inplace was specified.  This allows the sender to know when
the transfer can fully utilize the basis file (i.e., when the basis file
is not the destination file).

--- orig/generator.c	2005-01-14 18:30:18
+++ generator.c	2004-11-03 20:37:57
@@ -593,6 +593,8 @@ prepare_to_open:
 
 notify_others:
 	write_int(f_out, i);
+	if (protocol_version >= 29 && inplace && !read_batch)
+		write_byte(f_out, fnamecmp_type);
 	if (f_out_name >= 0)
 		write_byte(f_out_name, fnamecmp_type);
 
--- orig/match.c	2005-01-01 21:11:00
+++ match.c	2004-11-12 05:48:57
@@ -23,8 +23,8 @@ extern int verbose;
 extern int am_server;
 extern int do_progress;
 extern int checksum_seed;
-extern int inplace;
-extern int make_backups;
+
+int updating_basis_file;
 
 typedef unsigned short tag;
 
@@ -206,9 +206,9 @@ static void hash_search(int f,struct sum
 			if (l != s->sums[i].len)
 				continue;
 
-			/* inplace: ensure chunk's offset is either >= our
+			/* in-place: ensure chunk's offset is either >= our
 			 * offset or that the data didn't move. */
-			if (inplace && !make_backups && s->sums[i].offset < offset
+			if (updating_basis_file && s->sums[i].offset < offset
 			    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET))
 				continue;
 
@@ -227,10 +227,10 @@ static void hash_search(int f,struct sum
 				continue;
 			}
 
-			/* If inplace is enabled, the best possible match is
+			/* When updating in-place, the best possible match is
 			 * one with an identical offset, so we prefer that over
 			 * the following want_i optimization. */
-			if (inplace && !make_backups) {
+			if (updating_basis_file) {
 				do {
 					size_t i2 = targets[j].i;
 					if (s->sums[i2].offset != offset)
@@ -253,7 +253,7 @@ static void hash_search(int f,struct sum
 			/* we've found a match, but now check to see
 			 * if want_i can hint at a better match. */
 			if (i != want_i && want_i < s->count
-			    && (!inplace || make_backups || s->sums[want_i].offset >= offset
+			    && (!updating_basis_file || s->sums[want_i].offset >= offset
 			     || s->sums[want_i].flags & SUMFLG_SAME_OFFSET)
 			    && sum == s->sums[want_i].sum1
 			    && memcmp(sum2, s->sums[want_i].sum2, s->s2length) == 0) {
--- orig/options.c	2005-01-15 20:26:21
+++ options.c	2005-01-15 20:26:06
@@ -952,12 +952,6 @@ int parse_arguments(int *argc, const cha
 			return 0;
 		}
 		keep_partial = 0;
-		if (dest_option) {
-			snprintf(err_buf, sizeof err_buf,
-				 "--inplace does not yet work with %s\n",
-				 dest_option);
-			return 0;
-		}
 #else
 		snprintf(err_buf, sizeof err_buf,
 			 "--inplace is not supported on this %s\n",
--- orig/rsync.h	2005-01-10 00:21:12
+++ rsync.h	2004-11-03 20:32:34
@@ -62,7 +62,7 @@
 #define FLAG_MOUNT_POINT (1<<2)	/* sender only */
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 28
+#define PROTOCOL_VERSION 29
 
 /* We refuse to interoperate with versions that are not in this range.
  * Note that we assume we'll work with later versions: the onus is on
--- orig/sender.c	2005-01-01 21:11:01
+++ sender.c	2004-11-12 05:51:25
@@ -27,7 +27,9 @@ extern int dry_run;
 extern int am_server;
 extern int am_daemon;
 extern int protocol_version;
+extern int updating_basis_file;
 extern int make_backups;
+extern int inplace;
 extern struct stats stats;
 
 
@@ -166,6 +168,11 @@ void send_files(struct file_list *flist,
 		} else
 			offset = 0;
 		fname2 = f_name_to(file, fname + offset);
+		if (inplace && protocol_version >= 29) {
+			uchar fnamecmp_type = read_byte(f_in);
+			updating_basis_file = fnamecmp_type == FNAMECMP_FNAME;
+		} else
+			updating_basis_file = inplace && !make_backups;
 
 		if (verbose > 2)
 			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
