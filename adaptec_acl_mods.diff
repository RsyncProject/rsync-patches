Depends-On-Patch: acls.diff

After applying the above patch and this one, run these commands for a
successful build:

    ./prepare-source
    ./configure --enable-acl-support
    make

Philip Lowman wrote:
> Attached is a small patch which is meant to be applied to a copy of
> rsync which has already been patched with acl support (the acls.diff
> file in the patches folder).  It allows the preservation of the delete,
> chmod, and chown bits which Adaptec has added to XFS on their SnapOS NAS
> units.  This is nice for backing up files between different NAS units
> and preserving all of the Samba ACLs.
> 
> I'm not sure how useful this patch will be because I'm not sure if any
> other NAS vendors have standardized on their extensions to POSIX ACLs to
> support Samba in the same manner that Adaptec has.  FWIW, though, this
> will allow you to preserve acls when copying between different Adaptec
> based NAS units running SnapOS.

I (Wayne) tweaked the patch for style and to avoid using SMB_* constants
with literal values were needed.

I've also updated it to apply to the updated version of the acls.diff,
though I don't know if there might be some bits lost in the current
algorithm when using the file's mode bits to reconstruct a stripped ACL
entry.

--- old/acls.c
+++ new/acls.c
@@ -84,10 +84,10 @@ static int calc_sacl_entries(const rsync
 
 static int rsync_acl_get_perms(const rsync_acl *racl)
 {
-	/* Note that (ACL_NO_ENTRY & 7) is 0. */
-	return ((racl->user_obj & 7) << 6)
-	     + (((racl->mask != ACL_NO_ENTRY ? racl->mask : racl->group_obj) & 7) << 3)
-	     + (racl->other & 7);
+	/* Note that (ACL_NO_ENTRY & 077) is 0. */
+	return ((racl->user_obj & 077) << 6)
+	     + (((racl->mask != ACL_NO_ENTRY ? racl->mask : racl->group_obj) & 077) << 3)
+	     + (racl->other & 077);
 }
 
 static void rsync_acl_strip_perms(rsync_acl *racl)
@@ -178,6 +178,9 @@ static BOOL unpack_smb_acl(rsync_acl *ra
 		}
 		access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
 		       | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_DELETE) ? 8 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_CHMOD) ? 16 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_CHOWN) ? 32 : 0)
 		       | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
 		/* continue == done with entry; break == store in given idal */
 		switch (tag_type) {
@@ -588,6 +591,12 @@ static int store_access_in_entry(uchar a
 
 	COE( sys_acl_get_permset,(entry, &permset) );
 	COE( sys_acl_clear_perms,(permset) );
+	if (access & 32)
+		COE( sys_acl_add_perm(permset, SMB_ACL_CHOWN) );
+	if (access & 16)
+		COE( sys_acl_add_perm(permset, SMB_ACL_CHMOD) );
+	if (access & 8)
+		COE( sys_acl_add_perm(permset, SMB_ACL_DELETE) );
 	if (access & 4)
 		COE( sys_acl_add_perm,(permset, SMB_ACL_READ) );
 	if (access & 2)
@@ -620,7 +629,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_USER_OBJ) );
-	COE2( store_access_in_entry,(racl->user_obj & 7, entry) );
+	COE2( store_access_in_entry,(racl->user_obj & 077, entry) );
 
 	for (ida = racl->users.idas, count = racl->users.count;
 	     count--; ida++) {
@@ -632,7 +641,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_GROUP_OBJ) );
-	COE2( store_access_in_entry,(racl->group_obj & 7, entry) );
+	COE2( store_access_in_entry,(racl->group_obj & 077, entry) );
 
 	for (ida = racl->groups.idas, count = racl->groups.count;
 	     count--; ida++) {
@@ -653,7 +662,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_OTHER) );
-	COE2( store_access_in_entry,(racl->other & 7, entry) );
+	COE2( store_access_in_entry,(racl->other & 077, entry) );
 
 #ifdef DEBUG
 	if (sys_acl_valid(*smb_acl) < 0)
@@ -762,7 +771,7 @@ static void receive_rsync_acl(rsync_acl 
 	while (count--) {
 		char tag = read_byte(f);
 		uchar access = read_byte(f);
-		if (access & ~ (4 | 2 | 1)) {
+		if (access & ~(32 | 16 | 8 | 4 | 2 | 1)) {
 			rprintf(FERROR, "receive_rsync_acl: bogus permset %o\n",
 				access);
 			exit_cleanup(RERR_STREAMIO);
@@ -835,7 +844,7 @@ static void receive_rsync_acl(rsync_acl 
 	} else
 #endif
 	if (racl->mask == ACL_NO_ENTRY) /* always made non-empty when needed */
-		racl->mask = computed_mask_bits | (racl->group_obj & 7);
+		racl->mask = computed_mask_bits | (racl->group_obj & 077);
 }
 
 /* receive and build the rsync_acl_lists */
--- old/smb_acls.h
+++ new/smb_acls.h
@@ -33,6 +33,11 @@
 #define SMB_ACL_READ		ACL_READ
 #define SMB_ACL_WRITE		ACL_WRITE
 #define SMB_ACL_EXECUTE		ACL_EXECUTE
+/* These are custom ACL bits used by Adaptec's modifications
+ * to XFS on their SnapOS units. */
+#define SMB_ACL_DELETE		0x08
+#define SMB_ACL_CHMOD		0x10
+#define SMB_ACL_CHOWN		0x20
 
 /* Types of ACLs. */
 #define SMB_ACL_USER		ACL_USER
