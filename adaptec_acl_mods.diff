To use this patch, run these commands for a successful build:

    patch -p1 <patches/acls.diff
    patch -p1 <patches/adaptec_acl_mods.diff
    ./prepare-source
    ./configure --enable-acl-support
    make

Philip Lowman wrote:
> Attached is a small patch which is meant to be applied to a copy of
> rsync which has already been patched with acl support (the acls.diff
> file in the patches folder).  It allows the preservation of the delete,
> chmod, and chown bits which Adaptec has added to XFS on their SnapOS NAS
> units.  This is nice for backing up files between different NAS units
> and preserving all of the Samba ACLs.
> 
> I'm not sure how useful this patch will be because I'm not sure if any
> other NAS vendors have standardized on their extensions to POSIX ACLs to
> support Samba in the same manner that Adaptec has.  FWIW, though, this
> will allow you to preserve acls when copying between different Adaptec
> based NAS units running SnapOS.

I (Wayne) tweaked the patch for style and to avoid using SMB_* constants
with literal values were needed.

I've also updated it to apply to the updated version of the acls.diff,
though I don't know if there might be some bits lost in the current
algorithm when using the file's mode bits to reconstruct a stripped ACL
entry.

--- old/acls.c
+++ new/acls.c
@@ -307,6 +307,9 @@ static BOOL unpack_smb_acl(SMB_ACL_T sac
 		}
 		access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
 		       | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_DELETE) ? 8 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_CHMOD) ? 16 : 0)
+		       | (sys_acl_get_perm(permset, SMB_ACL_CHOWN) ? 32 : 0)
 		       | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
 		/* continue == done with entry; break == store in temporary ida list */
 		switch (tag_type) {
@@ -401,6 +404,12 @@ static int store_access_in_entry(uchar a
 
 	COE( sys_acl_get_permset,(entry, &permset) );
 	COE( sys_acl_clear_perms,(permset) );
+	if (access & 32)
+		COE( sys_acl_add_perm(permset, SMB_ACL_CHOWN) );
+	if (access & 16)
+		COE( sys_acl_add_perm(permset, SMB_ACL_CHMOD) );
+	if (access & 8)
+		COE( sys_acl_add_perm(permset, SMB_ACL_DELETE) );
 	if (access & 4)
 		COE( sys_acl_add_perm,(permset, SMB_ACL_READ) );
 	if (access & 2)
@@ -434,7 +443,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_USER_OBJ) );
-	COE2( store_access_in_entry,(racl->user_obj & 7, entry) );
+	COE2( store_access_in_entry,(racl->user_obj & 077, entry) );
 
 	for (ida = racl->users.idas, count = racl->users.count; count--; ida++) {
 		COE( sys_acl_create_entry,(smb_acl, &entry) );
@@ -445,7 +454,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_GROUP_OBJ) );
-	COE2( store_access_in_entry,(racl->group_obj & 7, entry) );
+	COE2( store_access_in_entry,(racl->group_obj & 077, entry) );
 
 	for (ida = racl->groups.idas, count = racl->groups.count; count--; ida++) {
 		COE( sys_acl_create_entry,(smb_acl, &entry) );
@@ -455,7 +464,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 	}
 
 #ifdef ACLS_NEED_MASK
-	mask_bits = racl->mask_obj == NO_ENTRY ? racl->group_obj & 7 : racl->mask_obj;
+	mask_bits = racl->mask_obj == NO_ENTRY ? racl->group_obj & 077 : racl->mask_obj;
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_MASK) );
 	COE2( store_access_in_entry,(mask_bits, entry) );
@@ -469,7 +478,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
 
 	COE( sys_acl_create_entry,(smb_acl, &entry) );
 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_OTHER) );
-	COE2( store_access_in_entry,(racl->other_obj & 7, entry) );
+	COE2( store_access_in_entry,(racl->other_obj & 077, entry) );
 
 #ifdef DEBUG
 	if (sys_acl_valid(*smb_acl) < 0)
@@ -766,7 +775,7 @@ static void old_recv_rsync_acl(rsync_acl
 	while (count--) {
 		char tag = read_byte(f);
 		uchar access = read_byte(f);
-		if (access & ~ (4 | 2 | 1)) {
+		if (access & ~(32 | 16 | 8 | 4 | 2 | 1)) {
 			rprintf(FERROR, "old_recv_rsync_acl: bogus permset %o\n",
 				access);
 			exit_cleanup(RERR_STREAMIO);
@@ -832,7 +841,7 @@ static void old_recv_rsync_acl(rsync_acl
 			racl->mask_obj = NO_ENTRY;
 		}
 	} else if (racl->mask_obj == NO_ENTRY) /* Must be non-empty with lists. */
-		racl->mask_obj = computed_mask_bits | (racl->group_obj & 7);
+		racl->mask_obj = computed_mask_bits | (racl->group_obj & 077);
 }
 
 /* Receive the ACL info the sender has included for this file-list entry. */
@@ -904,7 +913,7 @@ static uchar recv_acl_access(uchar *name
 			*name_follows_val = 0;
 	}
 
-	if (access & ~(4 | 2 | 1)) {
+	if (access & ~(32 | 16 | 8 | 4 | 2 | 1)) {
 		rprintf(FERROR, "recv_acl_access: bogus permset %o\n", access);
 		exit_cleanup(RERR_STREAMIO);
 	}
--- old/smb_acls.h
+++ new/smb_acls.h
@@ -33,6 +33,11 @@
 #define SMB_ACL_READ		ACL_READ
 #define SMB_ACL_WRITE		ACL_WRITE
 #define SMB_ACL_EXECUTE		ACL_EXECUTE
+/* These are custom ACL bits used by Adaptec's modifications
+ * to XFS on their SnapOS units. */
+#define SMB_ACL_DELETE		0x08
+#define SMB_ACL_CHMOD		0x10
+#define SMB_ACL_CHOWN		0x20
 
 /* Types of ACLs. */
 #define SMB_ACL_USER		ACL_USER
