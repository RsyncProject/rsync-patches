--- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
+++ Makefile.in	10 Mar 2004 08:00:58 -0000
@@ -34,7 +34,7 @@ ZLIBOBJ=zlib/deflate.o zlib/infblock.o z
 OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 	main.o checksum.o match.o syscall.o log.o backup.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
-	fileio.o batch.o clientname.o
+	fileio.o batch.o clientname.o chmod.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
--- chmod.c	2004-02-13 17:08:33.000000000 -0800
+++ chmod.c	2004-03-09 23:59:27.000000000 -0800
@@ -0,0 +1,162 @@
+#include "rsync.h"
+
+struct chmod_mode_struct {
+	int ModeAND;
+	int ModeOR;
+	char Xkeep;
+	struct chmod_mode_struct *next;
+};
+
+#define CHMOD_ADD 1
+#define CHMOD_SUB 2
+#define CHMOD_EQ  3
+
+/* Parse a chmod-style argument, and break it down into one or more AND/OR
+ * pairs in a linked list.
+ * We use a state machine to walk through the options - states 1 and 3
+ * before/including the operation (+, - or =), state 2 after the operation and
+ * state 4 if we hit an error. */
+struct chmod_mode_struct *parse_chmod(char *modestr)
+{
+	int state = 1;
+	int where = 0, what = 0, op = 0, topbits = 0, topoct = 0, Xkeep = 0;
+	struct chmod_mode_struct *first_mode = NULL, *curr_mode = NULL,
+	    *prev_mode = NULL;
+
+	while (*modestr) {
+		if (state != 2) {
+			switch (*modestr) {
+			case 'u':
+				where |= 0100;
+				topbits |= 04000;
+				break;
+			case 'g':
+				where |= 0010;
+				topbits |= 02000;
+				break;
+			case 'o':
+				where |= 0001;
+				break;
+			case 'a':
+				where |= 0111;
+				break;
+			case '+':
+				op = CHMOD_ADD;
+				state = 2;
+				break;
+			case '-':
+				op = CHMOD_SUB;
+				state = 2;
+				break;
+			case '=':
+				op = CHMOD_EQ;
+				state = 2;
+				break;
+			case ',':
+				break;
+			default:
+				state = 4;	/* Invalid Mode! */
+				break;
+			}
+		} else {
+			switch (*modestr) {
+			case 'r':
+				what |= 4;
+				break;
+			case 'w':
+				what |= 2;
+				break;
+			case 'X':
+				Xkeep = 1;
+				/* FALL THROUGH */
+			case 'x':
+				what |= 1;
+				break;
+			case 's':
+				if (topbits)
+					topoct |= topbits;
+				else
+					topoct = 04000;
+				break;
+			case 't':
+				topoct |= 01000;
+				break;
+			default:
+				state = 4;	/* Invalid Mode! */
+				break;
+			}
+		}
+
+		if (state == 4)
+			break;
+
+		modestr++;
+		if (!*modestr || *modestr == ',') {
+			prev_mode = curr_mode;
+			curr_mode = new_array(struct chmod_mode_struct, 1);
+			if (prev_mode)
+				prev_mode->next = curr_mode;
+			else
+				first_mode = curr_mode;
+			curr_mode->next = NULL;
+
+			switch (op) {
+			case CHMOD_ADD:
+				curr_mode->ModeAND = 07777;
+				curr_mode->ModeOR  = (where * what) + topoct;
+				break;
+			case CHMOD_SUB:
+				curr_mode->ModeAND = 07777 - (where * what) - topoct;
+				curr_mode->ModeOR  = 0;
+				break;
+			case CHMOD_EQ:
+				curr_mode->ModeAND = 07777 - (where * 7);
+				curr_mode->ModeOR  = where * what - topoct;
+				break;
+			}
+
+			curr_mode->Xkeep = Xkeep;
+			state = 3;
+			where = what = topoct = topbits = Xkeep = 0;
+		}
+	}
+
+	if (state == 4) {
+		free_chmod_mode(first_mode);
+		first_mode = NULL;
+	}
+	return first_mode;
+}
+
+
+/* Takes an existing file permission and a list of AND/OR changes, and
+ * create a new permissions. */
+int tweak_mode(int oldmode, struct chmod_mode_struct *chmod_modes)
+{
+	int IsX = oldmode & 0111;
+	int NonPerm = oldmode - (oldmode & 07777);
+
+	while (chmod_modes) {
+		oldmode &= chmod_modes->ModeAND;
+		if (chmod_modes->Xkeep && !IsX)
+			oldmode |= chmod_modes->ModeOR & (07777 - 0111);
+		else
+			oldmode |= chmod_modes->ModeOR;
+		chmod_modes = chmod_modes->next;
+	}
+
+	return oldmode + NonPerm;
+}
+
+/* Free the linked list created by parse_chmod. */
+int free_chmod_mode(struct chmod_mode_struct *chmod_modes)
+{
+	struct chmod_mode_struct *next;
+
+	while (chmod_modes) {
+		next = chmod_modes->next;
+		free(chmod_modes);
+		chmod_modes = next;
+	}
+	return 0;
+}
--- flist.c	11 Feb 2004 02:48:58 -0000	1.205
+++ flist.c	10 Mar 2004 08:00:59 -0000
@@ -33,6 +33,7 @@ extern int verbose;
 extern int do_progress;
 extern int am_root;
 extern int am_server;
+extern int am_sender;
 extern int always_checksum;
 extern int module_id;
 extern int ignore_errors;
@@ -63,6 +64,8 @@ extern int sanitize_paths;
 extern int read_batch;
 extern int write_batch;
 
+extern struct chmod_mode_struct *chmod_modes;
+
 extern struct exclude_struct **exclude_list;
 extern struct exclude_struct **server_exclude_list;
 extern struct exclude_struct **local_exclude_list;
@@ -831,7 +834,10 @@ skip_excludes:
 	file->flags = flags;
 	file->modtime = st.st_mtime;
 	file->length = st.st_size;
-	file->mode = st.st_mode;
+	if (chmod_modes && am_sender && S_ISREG(st.st_mode))
+		file->mode = tweak_mode(st.st_mode, chmod_modes);
+	else
+		file->mode = st.st_mode;
 	file->uid = st.st_uid;
 	file->gid = st.st_gid;
 
--- options.c	22 Feb 2004 08:56:43 -0000	1.139
+++ options.c	10 Mar 2004 08:00:59 -0000
@@ -119,6 +119,7 @@ char *log_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
+char *chmod_mode = NULL;
 char backup_dir_buf[MAXPATHLEN];
 int rsync_port = RSYNC_PORT;
 int link_dest = 0;
@@ -132,6 +133,8 @@ int list_only = 0;
 #define MAX_BATCH_PREFIX_LEN 256	/* Must be less than MAXPATHLEN-13 */
 char *batch_prefix = NULL;
 
+struct chmod_mode_struct *chmod_modes = NULL;
+
 static int daemon_opt;   /* sets am_daemon after option error-reporting */
 static int modify_window_set;
 
@@ -239,6 +242,7 @@ void usage(enum logcode F)
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F," -D, --devices               preserve devices (root only)\n");
   rprintf(F," -t, --times                 preserve times\n");
+  rprintf(F,"     --chmod=CHMOD           change destination permissions\n");  
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
   rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
@@ -342,6 +346,7 @@ static struct poptOption long_options[] 
   {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
   {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
   {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
+  {"chmod",            0,  POPT_ARG_STRING, &chmod_mode, 0, 0, 0 },
   {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
   {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
   {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
@@ -687,6 +692,13 @@ int parse_arguments(int *argc, const cha
 		exit_cleanup(RERR_SYNTAX);
 	}
 
+	if (chmod_mode && !(chmod_modes = parse_chmod(chmod_mode))) {
+		snprintf(err_buf, sizeof err_buf,
+		    "Invalid argument passed to chmod\n");
+		rprintf(FERROR, "ERROR: %s", err_buf);
+		return 0;
+	}
+
 	if (do_progress && !verbose)
 		verbose = 1;
 
@@ -932,6 +944,11 @@ void server_options(char **args,int *arg
 		 */
 		args[ac++] = link_dest ? "--link-dest" : "--compare-dest";
 		args[ac++] = compare_dest;
+	}
+
+	if (chmod_mode && !am_sender) {
+		args[ac++] = "--chmod";
+		args[ac++] = chmod_mode;
 	}
 
 	if (files_from && (!am_sender || remote_filesfrom_file)) {
--- proto.h	17 Feb 2004 23:13:06 -0000	1.184
+++ proto.h	10 Mar 2004 08:00:59 -0000
@@ -25,6 +25,9 @@ void file_checksum(char *fname,char *sum
 void sum_init(void);
 void sum_update(char *p, int len);
 void sum_end(char *sum);
+struct chmod_mode_struct *parse_chmod(char *modestr);
+int tweak_mode(int oldmode, struct chmod_mode_struct *chmod_modes);
+int free_chmod_mode(struct chmod_mode_struct *chmod_modes);
 void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
--- rsync.1	2 Feb 2004 18:23:09 -0000	1.163
+++ rsync.1	10 Mar 2004 08:01:00 -0000
@@ -336,6 +336,7 @@ to the detailed description below for a 
  -g, --group                 preserve group
  -D, --devices               preserve devices (root only)
  -t, --times                 preserve times
+     --chmod=CHMOD           change destination permissions
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
@@ -614,6 +615,10 @@ modified cannot be effective; in other w
 cause the next transfer to behave as if it used -I, and all files will have
 their checksums compared and show up in log messages even if they haven\&'t
 changed\&.
+.IP 
+.IP "\fB--chmod\fP" 
+This options tells rsync to apply the listed "chmod" pattern
+to the permission of the files on the destination\&.
 .IP 
 .IP "\fB-n, --dry-run\fP" 
 This tells rsync to not do any file transfers,
--- rsync.yo	2 Feb 2004 18:23:09 -0000	1.147
+++ rsync.yo	10 Mar 2004 08:01:00 -0000
@@ -299,6 +299,7 @@ verb(
  -g, --group                 preserve group
  -D, --devices               preserve devices (root only)
  -t, --times                 preserve times
+     --chmod=CHMOD           change destination permissions
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
@@ -534,6 +535,9 @@ modified cannot be effective; in other w
 cause the next transfer to behave as if it used -I, and all files will have
 their checksums compared and show up in log messages even if they haven't
 changed.
+
+dit(bf(--chmod)) This options tells rsync to apply the listed "chmod" pattern
+to the permission of the files on the destination.
 
 dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken.
--- testsuite/chmod.test	2004-02-13 17:08:33.000000000 -0800
+++ testsuite/chmod.test	2004-03-10 00:05:23.000000000 -0800
@@ -0,0 +1,37 @@
+#! /bin/sh
+
+# Copyright (C) 2002 by Martin Pool <mbp@samba.org>
+
+# This program is distributable under the terms of the GNU GPL (see
+# COPYING).
+
+# Test that the --chmod option functions correctly.
+
+. $srcdir/testsuite/rsync.fns
+
+set -x
+
+# Build some files
+
+fromdir="$scratchdir/from"
+todir="$scratchdir/to"
+checkdir="$scratchdir/check"
+
+mkdir "$fromdir"
+name1="$fromdir/name1"
+name2="$fromdir/name2"
+echo "This is the file" > "$name1"
+echo "This is the other file" > "$name2"
+
+chmod 4700 "$name1" || test_skipped "Can't chown"
+
+# Copy the files we've created over to another directory
+checkit "$RSYNC -avv \"$fromdir/\" \"$checkdir/\"" "$fromdir" "$checkdir"
+
+# And then manually make the changes which should occur 
+chmod ug-s,a+rX $checkdir/*
+
+checkit "$RSYNC -avv --chmod ug-s,a+rX \"$fromdir/\" \"$todir/\"" "$checkdir" "$todir"
+
+# The script would have aborted on error, so getting here means we've won.
+exit 0
