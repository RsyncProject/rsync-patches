Added some DB-access routines to help rsync keep extra filesystem info
about the files it is dealing with.  This adds both the --db=CONFIG_FILE
option and the "db config" daemon parameter.

For the moment this only adds checksum caching when the --checksum option
is used.  Future improvements may include:

 - Updating of MD5 checksums when transferring any file, even w/o -c.
   We should be able to extend this to work for MD4 checksums too if we
   make the sender force checksum_seed to 0 when using a DB and having
   the receiving side check to see if it got a 0 checksum_seed.  (We
   probably don't want to compute 2 MD4 checksums for the case where
   the checksum_seed is non-zero.)

 - Caching of path info that allows for the finding of files to use for
   moving/linking/copying/alternate-basis-use.

 - Extend DB support beyond MySQL and SQLite (PostgreSQL?).

To use this patch, run these commands for a successful build:

    patch -p1 <patches/db.diff
    ./configure                               (optional if already run)
    make

based-on: 0488a14b9930bf91719ac0f1d1c0c8770ca10646
diff --git a/.gitignore b/.gitignore
--- a/.gitignore
+++ b/.gitignore
@@ -23,6 +23,7 @@ config.status
 /getgroups
 /gmon.out
 /rsync
+/rsyncdb
 /shconfig
 /testdir
 /tests-dont-exist
diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -36,7 +36,7 @@ zlib_OBJS=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
 OBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \
 	util.o util2.o main.o checksum.o match.o syscall.o log.o backup.o delete.o
 OBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \
-	fileio.o batch.o clientname.o chmod.o acls.o xattrs.o
+	fileio.o batch.o clientname.o chmod.o db.o acls.o xattrs.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
@@ -60,11 +60,12 @@ CHECK_OBJS=tls.o testrun.o getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.
 	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
 
-all: Makefile rsync$(EXEEXT) @MAKE_MAN@
+all: Makefile rsync$(EXEEXT) rsyncdb @MAKE_MAN@
 
 install: all
 	-mkdir -p ${DESTDIR}${bindir}
 	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
+	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsyncdb$(EXEEXT) ${DESTDIR}${bindir}
 	-mkdir -p ${DESTDIR}${mandir}/man1
 	-mkdir -p ${DESTDIR}${mandir}/man5
 	if test -f rsync.1; then ${INSTALLMAN} -m 644 rsync.1 ${DESTDIR}${mandir}/man1; fi
@@ -76,6 +77,10 @@ install-strip:
 rsync$(EXEEXT): $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
+RSYNCDB_OBJS = rsyncdb.o db.o hashtable.o fileio.o syscall.o util2.o lib/compat.o lib/mdfour.o lib/md5.o @BUILD_POPT@
+rsyncdb$(EXEEXT): $(RSYNCDB_OBJS) rsync.h
+	$(CC) -o rsyncdb $(RSYNCDB_OBJS) $(LIBS)
+
 $(OBJS): $(HEADERS)
 $(CHECK_OBJS): $(HEADERS)
 
@@ -196,7 +201,7 @@ rsyncd.conf.5: rsyncd.conf.yo
 	-$(srcdir)/tweak_manpage rsyncd.conf.5
 
 clean: cleantests
-	rm -f *~ $(OBJS) $(CHECK_PROGS) $(CHECK_OBJS) $(CHECK_SYMLINKS) \
+	rm -f *~ $(OBJS) $(CHECK_PROGS) $(CHECK_OBJS) $(CHECK_SYMLINKS) rsyncdb rsyncdb.o \
 		rounding rounding.h *.old
 
 cleantests:
diff --git a/checksum.c b/checksum.c
--- a/checksum.c
+++ b/checksum.c
@@ -23,6 +23,7 @@
 
 extern int checksum_seed;
 extern int protocol_version;
+extern int use_db;
 
 /*
   a simple 32 bit checksum that can be upadted from either end
@@ -98,10 +99,10 @@ void get_checksum2(char *buf, int32 len, char *sum)
 	}
 }
 
-void file_checksum(char *fname, char *sum, OFF_T size)
+void file_checksum(const char *fname, STRUCT_STAT *st_p, char *sum)
 {
 	struct map_struct *buf;
-	OFF_T i, len = size;
+	OFF_T i, len = st_p->st_size;
 	md_context m;
 	int32 remainder;
 	int fd;
@@ -112,7 +113,7 @@ void file_checksum(char *fname, char *sum, OFF_T size)
 	if (fd == -1)
 		return;
 
-	buf = map_file(fd, size, MAX_MAP_SIZE, CSUM_CHUNK);
+	buf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);
 
 	if (protocol_version >= 30) {
 		md5_begin(&m);
@@ -127,6 +128,9 @@ void file_checksum(char *fname, char *sum, OFF_T size)
 			md5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
 		md5_result(&m, (uchar *)sum);
+
+		if (use_db)
+			db_set_checksum(5, st_p, sum);
 	} else {
 		mdfour_begin(&m);
 
@@ -144,6 +148,9 @@ void file_checksum(char *fname, char *sum, OFF_T size)
 			mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
 		mdfour_result(&m, (uchar *)sum);
+
+		if (use_db)
+			db_set_checksum(4, st_p, sum);
 	}
 
 	close(fd);
diff --git a/cleanup.c b/cleanup.c
--- a/cleanup.c
+++ b/cleanup.c
@@ -26,6 +26,7 @@ extern int am_server;
 extern int am_daemon;
 extern int am_receiver;
 extern int io_error;
+extern int use_db;
 extern int keep_partial;
 extern int got_xfer_error;
 extern int protocol_version;
@@ -141,6 +142,12 @@ NORETURN void _exit_cleanup(int code, const char *file, int line)
 #include "case_N.h"
 		switch_step++;
 
+		if (use_db)
+			db_disconnect();
+
+		/* FALLTHROUGH */
+#include "case_N.h"
+
 		if (cleanup_child_pid != -1) {
 			int status;
 			int pid = wait_process(cleanup_child_pid, &status, WNOHANG);
diff --git a/clientserver.c b/clientserver.c
--- a/clientserver.c
+++ b/clientserver.c
@@ -42,12 +42,15 @@ extern int numeric_ids;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
+extern int always_checksum;
 extern int io_timeout;
 extern int no_detach;
+extern int use_db;
 extern int write_batch;
 extern int default_af_hint;
 extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
+extern char *db_config;
 extern char *bind_address;
 extern char *config_file;
 extern char *logfile_format;
@@ -692,6 +695,9 @@ static int rsync_module(int f_in, int f_out, int i, const char *addr, const char
 
 	log_init(1);
 
+	if (*lp_db_config(i))
+		db_read_config(FLOG, lp_db_config(i));
+
 #ifdef HAVE_PUTENV
 	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
 		int status;
@@ -896,6 +902,10 @@ static int rsync_module(int f_in, int f_out, int i, const char *addr, const char
 
 	am_server = 1; /* Don't let someone try to be tricky. */
 	quiet = 0;
+	db_config = NULL;
+	if (!always_checksum)
+		use_db = 0;
+
 	if (lp_ignore_errors(module_id))
 		ignore_errors = 1;
 	if (write_batch < 0)
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -344,6 +344,7 @@ AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
     sys/un.h sys/attr.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
+    mysql/mysql.h sqlite3.h \
     netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
     sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
     popt.h popt/popt.h linux/falloc.h netinet/in_systm.h netinet/ip.h \
@@ -1096,6 +1097,48 @@ if test x"$enable_acl_support" = x"no" -o x"$enable_xattr_support" = x"no" -o x"
     fi
 fi
 
+AC_MSG_CHECKING([whether to include mysql DB support])
+AC_ARG_ENABLE(mysql,
+	AC_HELP_STRING([--disable-mysql],
+		[disable mysql DB support]))
+
+if test x"$enable_mysql" = x"no"; then
+    AC_MSG_RESULT(no)
+else
+    AC_MSG_RESULT([yes])
+    AC_CHECK_PROG(MYSQL_CONFIG, mysql_config, 1, 0)
+    if test x$MYSQL_CONFIG = x1; then
+	AC_MSG_CHECKING(for mysql version >= 4)
+	mysql_version=`mysql_config --version`
+	mysql_major_version=`echo $mysql_version | sed 's/\..*//'`
+	if test $mysql_major_version -lt 4; then
+	    AC_MSG_RESULT(no.. skipping MySQL)
+	else
+	    AC_MSG_RESULT(yes)
+
+	    MYSQL_CFLAGS=`mysql_config --cflags`
+	    MYSQL_LIBS=`mysql_config --libs`
+
+	    CPPFLAGS="$CPPFLAGS $MYSQL_CFLAGS"
+	    LIBS="$MYSQL_LIBS $LIBS"
+
+	    AC_CHECK_LIB(mysqlclient, mysql_init)
+	fi
+    fi
+fi
+
+AC_MSG_CHECKING([whether to include sqlite DB support])
+AC_ARG_ENABLE(sqlite,
+	AC_HELP_STRING([--disable-sqlite],
+		[disable sqlite DB support]))
+
+if test x"$enable_sqlite" = x"no"; then
+    AC_MSG_RESULT(no)
+else
+    AC_CHECK_LIB(sqlite3, sqlite3_open)
+    AC_CHECK_FUNCS(sqlite3_open_v2 sqlite3_prepare_v2)
+fi
+
 case "$CC" in
 ' checker'*|checker*)
     AC_DEFINE(FORCE_FD_ZERO_MEMSET, 1, [Used to make "checker" understand that FD_ZERO() clears memory.])
diff --git a/db.c b/db.c
new file mode 100644
--- /dev/null
+++ b/db.c
@@ -0,0 +1,877 @@
+/*
+ * Routines to access extended file info via DB.
+ *
+ * Copyright (C) 2008-2013 Wayne Davison
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, visit the http://fsf.org website.
+ */
+
+#include "rsync.h"
+#include "ifuncs.h"
+#include "itypes.h"
+
+#if defined HAVE_MYSQL_MYSQL_H && defined HAVE_LIBMYSQLCLIENT
+#define USE_MYSQL
+#include <mysql/mysql.h>
+#include <mysql/errmsg.h>
+#endif
+
+#if defined HAVE_SQLITE3_H && defined HAVE_LIBSQLITE3
+#define USE_SQLITE
+#include <sqlite3.h>
+#ifndef HAVE_SQLITE3_OPEN_V2
+#define sqlite3_open_v2(dbname, dbhptr, flags, vfs) \
+	sqlite3_open(dbname, dbhptr)
+#endif
+#ifndef HAVE_SQLITE3_PREPARE_V2
+#define sqlite3_prepare_v2 sqlite3_prepare
+#endif
+#define MAX_OPEN_FAILURES 10
+#define OPEN_FAIL_MSLEEP 100
+#endif
+
+extern int protocol_version;
+extern int checksum_len;
+
+#define DB_TYPE_NONE 0
+#define DB_TYPE_MYSQL 1
+#define DB_TYPE_SQLITE 2
+
+int use_db = DB_TYPE_NONE;
+int select_many_sums = 0;
+
+static const char *dbhost = NULL, *dbuser = NULL, *dbpass = NULL, *dbname = NULL;
+static unsigned int dbport = 0;
+
+static union {
+#ifdef USE_MYSQL
+    MYSQL *mysql;
+#endif
+#ifdef USE_SQLITE
+    sqlite3 *sqlite;
+#endif
+    void *all;
+} dbh;
+
+#define SEL_DEV 0
+#define SEL_SUM 1
+#define REP_SUM 2
+#define DEL_SUMS 3
+#define INS_PRESENT 4
+#define MAX_PREP_CNT 5
+
+#define MAX_BIND_CNT 7
+#define MAX_RESULT_BINDS 32
+
+static union {
+#ifdef USE_MYSQL
+    MYSQL_STMT *mysql;
+#endif
+#ifdef USE_SQLITE
+    sqlite3_stmt *sqlite;
+#endif
+    void *all;
+} statements[MAX_PREP_CNT];
+
+static int md_num;
+static int check_ctime = 1;
+static enum logcode log_code;
+
+#ifdef USE_MYSQL
+static unsigned int bind_disk_id, bind_mdnum;
+static unsigned long long bind_devno, bind_ino, bind_size, bind_mtime, bind_ctime;
+static char bind_sum[MAX_DIGEST_LEN];
+#endif
+static char bind_thishost[256];
+static int bind_thishost_len;
+
+static char *error_log;
+#if defined USE_SQLITE && defined SQLITE_CONFIG_LOG
+static FILE *error_log_fp;
+#endif
+
+int db_read_config(enum logcode code, const char *config_file)
+{
+	char buf[2048], *cp;
+	FILE *fp;
+	int lineno = 0;
+
+	log_code = code;
+
+	bind_thishost_len = strlcpy(bind_thishost, "localhost", sizeof bind_thishost);
+
+	if (!(fp = fopen(config_file, "r"))) {
+		rsyserr(log_code, errno, "unable to open %s", config_file);
+		return 0;
+	}
+	while (fgets(buf, sizeof buf, fp)) {
+		lineno++;
+		if ((cp = strchr(buf, '#')) == NULL
+		 && (cp = strchr(buf, '\r')) == NULL
+		 && (cp = strchr(buf, '\n')) == NULL)
+			cp = buf + strlen(buf);
+		while (cp != buf && isSpace(cp-1)) cp--;
+		*cp = '\0';
+
+		if (!*buf)
+			continue;
+
+		if (!(cp = strchr(buf, ':')))
+			goto invalid_line;
+		*cp++ = '\0';
+
+		while (isSpace(cp)) cp++;
+		if (strcasecmp(buf, "dbhost") == 0)
+			dbhost = strdup(cp);
+		else if (strcasecmp(buf, "dbuser") == 0)
+			dbuser = strdup(cp);
+		else if (strcasecmp(buf, "dbpass") == 0)
+			dbpass = strdup(cp);
+		else if (strcasecmp(buf, "dbname") == 0)
+			dbname = strdup(cp);
+		else if (strcasecmp(buf, "dbport") == 0)
+			dbport = atoi(cp);
+		else if (strcasecmp(buf, "no_ctime") == 0)
+			check_ctime = atoi(cp) ? 0 : 1;
+		else if (strcasecmp(buf, "errlog") == 0)
+			error_log = strdup(cp);
+		else if (strcasecmp(buf, "thishost") == 0)
+			bind_thishost_len = strlcpy(bind_thishost, cp, sizeof bind_thishost);
+		else if (strcasecmp(buf, "dbtype") == 0) {
+#ifdef USE_MYSQL
+			if (strcasecmp(cp, "mysql") == 0) {
+				use_db = DB_TYPE_MYSQL;
+				continue;
+			}
+#endif
+#ifdef USE_SQLITE
+			if (strcasecmp(cp, "sqlite") == 0) {
+				use_db = DB_TYPE_SQLITE;
+				continue;
+			}
+#endif
+			rprintf(log_code,
+			    "Unsupported dbtype on line #%d in %s.\n",
+			    lineno, config_file);
+			use_db = DB_TYPE_NONE;
+			return 0;
+		} else {
+		  invalid_line:
+			rprintf(log_code, "Invalid line #%d in %s\n",
+				lineno, config_file);
+			use_db = DB_TYPE_NONE;
+			return 0;
+		}
+	}
+	fclose(fp);
+
+	if (bind_thishost_len >= (int)sizeof bind_thishost)
+		bind_thishost_len = sizeof bind_thishost - 1;
+
+	if (!use_db || !dbname) {
+		rprintf(log_code, "Please specify at least dbtype and dbname in %s.\n", config_file);
+		use_db = DB_TYPE_NONE;
+		return 0;
+	}
+
+	md_num = protocol_version >= 30 ? 5 : 4;
+
+	if (error_log) {
+		if (use_db != DB_TYPE_SQLITE)
+			rprintf(log_code, "Ignoring errlog setting for non-SQLite DB.\n");
+#ifndef SQLITE_CONFIG_LOG
+		else
+			rprintf(log_code, "Your sqlite doesn't support SQLITE_CONFIG_LOG.\n");
+#endif
+	}
+
+	return 1;
+}
+
+#if defined USE_SQLITE && defined SQLITE_CONFIG_LOG
+static void errorLogCallback(UNUSED(void *pArg), int iErrCode, const char *zMsg)
+{
+	fprintf(error_log_fp, "[%d] %s (%d)\n", (int)getpid(), zMsg, iErrCode);
+}
+#endif
+
+#ifdef USE_MYSQL
+static MYSQL_STMT *prepare_mysql(MYSQL_BIND *binds, int bind_cnt, const char *fmt, ...)
+{
+	va_list ap;
+	char *query;
+	int qlen, param_cnt;
+	MYSQL_STMT *stmt = mysql_stmt_init(dbh.mysql);
+
+	if (stmt == NULL)
+		out_of_memory("prepare_mysql");
+
+	va_start(ap, fmt);
+	qlen = vasprintf(&query, fmt, ap);
+	va_end(ap);
+	if (qlen < 0)
+		out_of_memory("prepare_mysql");
+
+	if (mysql_stmt_prepare(stmt, query, qlen) != 0) {
+		rprintf(log_code, "Prepare failed: %s\n", mysql_stmt_error(stmt));
+		return NULL;
+	}
+	free(query);
+
+	if ((param_cnt = mysql_stmt_param_count(stmt)) != bind_cnt) {
+		rprintf(log_code, "Parameters in statement = %d, bind vars = %d\n",
+			param_cnt, bind_cnt);
+		return NULL;
+	}
+	if (bind_cnt)
+		mysql_stmt_bind_param(stmt, binds);
+
+	return stmt;
+}
+#endif
+
+#ifdef USE_MYSQL
+static int db_connect_mysql(void)
+{
+	MYSQL_BIND binds[MAX_BIND_CNT];
+
+	if (!(dbh.mysql = mysql_init(NULL)))
+		out_of_memory("db_read_config");
+
+	if (!mysql_real_connect(dbh.mysql, dbhost, dbuser, dbpass, dbname, dbport, NULL, 0))
+		return 0;
+
+	memset(binds, 0, sizeof binds);
+	binds[0].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[0].buffer = &bind_devno;
+	binds[1].buffer_type = MYSQL_TYPE_STRING;
+	binds[1].buffer = &bind_thishost;
+	binds[1].buffer_length = bind_thishost_len;
+	statements[SEL_DEV].mysql = prepare_mysql(binds, 2,
+		"SELECT disk_id"
+		" FROM disk"
+		" WHERE devno = ? AND host = ? AND mounted = 1"
+		);
+	if (!statements[SEL_DEV].mysql)
+		return 0;
+
+	memset(binds, 0, sizeof binds);
+	binds[0].buffer_type = MYSQL_TYPE_LONG;
+	binds[0].buffer = &bind_disk_id;
+	binds[1].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[1].buffer = &bind_ino;
+	if (select_many_sums) {
+		statements[SEL_SUM].mysql = prepare_mysql(binds, 2,
+			"SELECT checksum, sum_type, size, mtime, ctime"
+			" FROM inode_map"
+			" WHERE disk_id = ? AND ino = ?"
+			);
+	} else {
+		binds[2].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[2].buffer = &bind_size;
+		binds[3].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[3].buffer = &bind_mtime;
+		if (check_ctime) {
+			binds[4].buffer_type = MYSQL_TYPE_LONGLONG;
+			binds[4].buffer = &bind_ctime;
+		}
+		statements[SEL_SUM].mysql = prepare_mysql(binds, 4 + check_ctime,
+			"SELECT checksum"
+			" FROM inode_map"
+			" WHERE disk_id = ? AND ino = ? AND sum_type = %d"
+			"   AND size = ? AND mtime = ? %s",
+			md_num, check_ctime ? "AND ctime = ?" : "");
+	}
+	if (!statements[SEL_SUM].mysql)
+		return 0;
+
+	memset(binds, 0, sizeof binds);
+	binds[0].buffer_type = MYSQL_TYPE_LONG;
+	binds[0].buffer = &bind_disk_id;
+	binds[1].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[1].buffer = &bind_ino;
+	binds[2].buffer_type = MYSQL_TYPE_LONG;
+	binds[2].buffer = &bind_mdnum;
+	binds[3].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[3].buffer = &bind_size;
+	binds[4].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[4].buffer = &bind_mtime;
+	binds[5].buffer_type = MYSQL_TYPE_LONGLONG;
+	binds[5].buffer = &bind_ctime;
+	binds[6].buffer_type = MYSQL_TYPE_BLOB;
+	binds[6].buffer = &bind_sum;
+	binds[6].buffer_length = checksum_len;
+	statements[REP_SUM].mysql = prepare_mysql(binds, 7,
+		"INSERT INTO inode_map"
+		" SET disk_id = ?, ino = ?, sum_type = ?,"
+		"     size = ?, mtime = ?, ctime = ?, checksum = ?"
+		" ON DUPLICATE KEY"
+		" UPDATE size = VALUES(size), mtime = VALUES(mtime),"
+		"        ctime = VALUES(ctime), checksum = VALUES(checksum)"
+		);
+	if (!statements[REP_SUM].mysql)
+		return 0;
+
+	return 1;
+}
+#endif
+
+#ifdef USE_SQLITE
+static int db_connect_sqlite(void)
+{
+	int open_failures = 0;
+	char *sql;
+
+#ifdef SQLITE_CONFIG_LOG
+	if (error_log) {
+		if (!(error_log_fp = fopen(error_log, "a"))) {
+			rsyserr(log_code, errno, "unable to append to logfile %s", error_log);
+			error_log = NULL;
+		} else if (sqlite3_config(SQLITE_CONFIG_LOG, errorLogCallback, NULL) != 0)
+			rprintf(log_code, "Failed to set errorLogCallback: %s\n", sqlite3_errmsg(dbh.sqlite));
+	}
+#endif
+
+	while (1) {
+		int ret = sqlite3_open_v2(dbname, &dbh.sqlite, SQLITE_OPEN_READWRITE, NULL);
+		if (ret == 0)
+			break;
+		if (ret != SQLITE_BUSY && ret != SQLITE_LOCKED)
+			return 0;
+		if (++open_failures > MAX_OPEN_FAILURES)
+			return 0;
+		msleep(OPEN_FAIL_MSLEEP);
+	}
+
+	sql="SELECT disk_id"
+	    " FROM disk"
+	    " WHERE devno = ? AND host = ? AND mounted = 1";
+	if (sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[SEL_DEV].sqlite, NULL) != 0)
+		return 0;
+
+	if (select_many_sums) {
+		sql="SELECT checksum, sum_type, size, mtime, ctime"
+		    " FROM inode_map"
+		    " WHERE disk_id = ? AND ino = ?";
+		if (sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[SEL_SUM].sqlite, NULL) != 0)
+			return 0;
+	} else {
+		if (asprintf(&sql,
+		    "SELECT checksum"
+		    " FROM inode_map"
+		    " WHERE disk_id = ? AND ino = ? AND sum_type = %d"
+		    "   AND size = ? AND mtime = ? %s",
+		    md_num, check_ctime ? "AND ctime = ?" : "") < 0
+		 || sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[SEL_SUM].sqlite, NULL) != 0)
+			return 0;
+		free(sql);
+	}
+
+	sql="INSERT OR REPLACE INTO inode_map"
+	    " (disk_id, ino, sum_type, size, mtime, ctime, checksum)"
+	    " VALUES (?, ?, ?, ?, ?, ?, ?)";
+	if (sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[REP_SUM].sqlite, NULL) != 0)
+		return 0;
+
+	return 1;
+}
+#endif
+
+int db_connect(int select_many)
+{
+	select_many_sums = select_many;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL:
+		if (db_connect_mysql())
+			return 1;
+		break;
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE:
+		if (db_connect_sqlite())
+			return 1;
+		break;
+#endif
+	}
+
+	rprintf(log_code, "Unable to connect to DB: %s\n", sqlite3_errmsg(dbh.sqlite));
+	db_disconnect();
+	use_db = DB_TYPE_NONE;
+
+	return 0;
+}
+
+void db_disconnect(void)
+{
+	int ndx;
+
+	if (!dbh.all)
+		return;
+
+	for (ndx = 0; ndx < MAX_PREP_CNT; ndx++) {
+		if (statements[ndx].all) {
+			switch (use_db) {
+#ifdef USE_MYSQL
+			case DB_TYPE_MYSQL:
+				mysql_stmt_close(statements[ndx].mysql);
+				break;
+#endif
+#ifdef USE_SQLITE
+			case DB_TYPE_SQLITE:
+				sqlite3_finalize(statements[ndx].sqlite);
+				break;
+#endif
+			}
+			statements[ndx].all = NULL;
+		}
+	}
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL:
+		mysql_close(dbh.mysql);
+		break;
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE:
+		sqlite3_close(dbh.sqlite);
+		break;
+#endif
+	}
+
+	dbh.all = NULL;
+}
+
+#ifdef USE_MYSQL
+static MYSQL_STMT *exec_mysql(int ndx)
+{
+	MYSQL_STMT *stmt = statements[ndx].mysql;
+	int rc;
+
+	if ((rc = mysql_stmt_execute(stmt)) == CR_SERVER_LOST) {
+		db_disconnect();
+		if (db_connect(select_many_sums)) {
+			stmt = statements[ndx].mysql;
+			rc = mysql_stmt_execute(stmt);
+		}
+	}
+	if (rc != 0) {
+		rprintf(log_code, "SQL execute failed: %s\n", mysql_stmt_error(stmt));
+		return NULL;
+	}
+
+	return stmt;
+}
+#endif
+
+#ifdef USE_MYSQL
+static int fetch_mysql(MYSQL_BIND *binds, int bind_cnt, int ndx, int max_rows)
+{
+	unsigned long length[MAX_RESULT_BINDS];
+	my_bool is_null[MAX_RESULT_BINDS], error[MAX_RESULT_BINDS];
+	MYSQL_STMT *stmt;
+	int i, rc, rows = 0;
+
+	if (bind_cnt > MAX_RESULT_BINDS)
+		exit_cleanup(RERR_UNSUPPORTED);
+
+	if ((stmt = exec_mysql(ndx)) == NULL)
+		return 0;
+
+	for (i = 0; i < bind_cnt; i++) {
+		binds[i].is_null = &is_null[i];
+		binds[i].length = &length[i];
+		binds[i].error = &error[i];
+	}
+	mysql_stmt_bind_result(stmt, binds);
+
+	while (rows < max_rows) {
+		if ((rc = mysql_stmt_fetch(stmt)) != 0) {
+			if (rc != MYSQL_NO_DATA) {
+				rprintf(log_code, "SELECT fetch failed: %s\n",
+					mysql_stmt_error(stmt));
+			}
+			break;
+		}
+		for (i = 0; i < bind_cnt; i++)
+			binds[i].buffer += binds[i].buffer_length;
+	}
+
+	mysql_stmt_free_result(stmt);
+
+	return rows;
+}
+#endif
+
+unsigned int get_disk_id(unsigned long long devno)
+{
+	static unsigned int prior_disk_id = 0;
+	static unsigned long long prior_devno = 0;
+
+	if (prior_devno == devno && prior_disk_id)
+		return prior_disk_id;
+	prior_devno = devno;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL: {
+		MYSQL_BIND binds[1];
+
+		bind_devno = devno; /* The one variable SEL_DEV input value. */
+
+		/* Bind where to put the output. */
+		binds[0].buffer_type = MYSQL_TYPE_LONG;
+		binds[0].buffer = &prior_disk_id;
+		if (!fetch_mysql(binds, 1, SEL_DEV, 1))
+			prior_disk_id = 0;
+		break;
+	    }
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		sqlite3_stmt *stmt = statements[SEL_DEV].sqlite;
+		sqlite3_bind_int64(stmt, 1, devno);
+		sqlite3_bind_text(stmt, 2, bind_thishost, bind_thishost_len, SQLITE_STATIC);
+		if (sqlite3_step(stmt) == SQLITE_ROW)
+			prior_disk_id = sqlite3_column_int(stmt, 0);
+		else
+			prior_disk_id = 0;
+		sqlite3_reset(stmt);
+		break;
+	    }
+#endif
+	}
+
+	return prior_disk_id;
+}
+
+int db_get_checksum(const STRUCT_STAT *st_p, char *sum)
+{
+	unsigned int disk_id = get_disk_id(st_p->st_dev);
+
+	if (disk_id == 0)
+		return 0;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL: {
+		MYSQL_BIND binds[1];
+
+		bind_disk_id = disk_id;
+		bind_ino = st_p->st_ino;
+		bind_size = st_p->st_size;
+		bind_mtime = st_p->st_mtime;
+		if (check_ctime)
+			bind_ctime = st_p->st_ctime;
+
+		binds[0].buffer_type = MYSQL_TYPE_BLOB;
+		binds[0].buffer = sum;
+		binds[0].buffer_length = checksum_len;
+		return fetch_mysql(binds, 1, SEL_SUM, 1);
+	    }
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		sqlite3_stmt *stmt = statements[SEL_SUM].sqlite;
+		sqlite3_bind_int(stmt, 1, disk_id);
+		sqlite3_bind_int64(stmt, 2, st_p->st_ino);
+		sqlite3_bind_int64(stmt, 3, st_p->st_size);
+		sqlite3_bind_int64(stmt, 4, st_p->st_mtime);
+		if (check_ctime)
+			sqlite3_bind_int64(stmt, 5, st_p->st_ctime);
+		if (sqlite3_step(stmt) == SQLITE_ROW) {
+			int len = sqlite3_column_bytes(stmt, 0);
+			if (len > MAX_DIGEST_LEN)
+				len = MAX_DIGEST_LEN;
+			memcpy(sum, sqlite3_column_blob(stmt, 0), len);
+			sqlite3_reset(stmt);
+			return 1;
+		}
+		sqlite3_reset(stmt);
+		return 0;
+	    }
+#endif
+	}
+
+	return 0;
+}
+
+int db_get_both_checksums(const STRUCT_STAT *st_p, int *right_sum_cnt, int *wrong_sum_cnt, char **sum4, char **sum5)
+{
+	int rows, j, sum_type[2];
+	static char dbsum[MD5_DIGEST_LEN*2];
+	long long dbsize[2], dbmtime[2], dbctime[2];
+	unsigned int disk_id = get_disk_id(st_p->st_dev);
+
+	if (disk_id == 0)
+		return 0;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL: {
+		MYSQL_BIND binds[5];
+
+		bind_disk_id = disk_id;
+		bind_ino = st_p->st_ino;
+
+		/* We set the superfluous lengths for incrementing to extra rows. */
+		binds[0].buffer_type = MYSQL_TYPE_BLOB;
+		binds[0].buffer = dbsum;
+		binds[0].buffer_length = checksum_len;
+		binds[1].buffer_type = MYSQL_TYPE_LONG;
+		binds[1].buffer = (char*)sum_type;
+		binds[1].buffer_length = sizeof (*sum_type);
+		binds[2].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[2].buffer = (char*)dbsize;
+		binds[2].buffer_length = sizeof (*dbsize);
+		binds[3].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[3].buffer = (char*)dbmtime;
+		binds[3].buffer_length = sizeof (*dbmtime);
+		binds[4].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[4].buffer = (char*)dbctime;
+		binds[4].buffer_length = sizeof (*dbctime);
+		rows = fetch_mysql(binds, 5, SEL_SUM, 2);
+		break;
+	    }
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		sqlite3_stmt *stmt = statements[SEL_SUM].sqlite;
+		sqlite3_bind_int(stmt, 1, disk_id);
+		sqlite3_bind_int64(stmt, 2, st_p->st_ino);
+		for (j = 0; j < 2; j++) {
+			if (sqlite3_step(stmt) != SQLITE_ROW)
+				break;
+			int len = sqlite3_column_bytes(stmt, 0);
+			if (len > checksum_len)
+				len = checksum_len;
+			memcpy(dbsum + checksum_len*j, sqlite3_column_blob(stmt, 0), len);
+			sum_type[j] = sqlite3_column_int(stmt, 1);
+			dbsize[j] = sqlite3_column_int(stmt, 2);
+			dbmtime[j] = sqlite3_column_int64(stmt, 3);
+			dbctime[j] = sqlite3_column_int64(stmt, 4);
+		}
+		sqlite3_reset(stmt);
+		rows = j;
+		break;
+	    }
+#endif
+	default:
+		return 0;
+	}
+
+	if (sum4)
+		*sum4 = NULL;
+	if (sum5)
+		*sum5 = NULL;
+	*right_sum_cnt = *wrong_sum_cnt = 0;
+	for (j = 0; j < rows; j++) {
+		if (sum_type[j] == 4) {
+			if (!sum4)
+				continue;
+			*sum4 = dbsum + checksum_len*j;
+		} else {
+			if (!sum5)
+				continue;
+			*sum5 = dbsum + checksum_len*j;
+		}
+		if (st_p->st_size == dbsize[j] && st_p->st_mtime == dbmtime[j] && (!check_ctime || st_p->st_ctime == dbctime[j]))
+			++*right_sum_cnt;
+		else
+			++*wrong_sum_cnt;
+	}
+
+	return rows;
+}
+
+int db_set_checksum(int mdnum, const STRUCT_STAT *st_p, const char *sum)
+{
+	unsigned int disk_id = get_disk_id(st_p->st_dev);
+
+	if (disk_id == 0)
+		return 0;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL:
+		bind_disk_id = disk_id;
+		bind_ino = st_p->st_ino;
+		bind_mdnum = mdnum;
+		bind_size = st_p->st_size;
+		bind_mtime = st_p->st_mtime;
+		bind_ctime = st_p->st_ctime;
+		memcpy(bind_sum, sum, checksum_len);
+
+		return exec_mysql(REP_SUM) != NULL;
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		int rc;
+		sqlite3_stmt *stmt = statements[REP_SUM].sqlite;
+		sqlite3_bind_int(stmt, 1, disk_id);
+		sqlite3_bind_int64(stmt, 2, st_p->st_ino);
+		sqlite3_bind_int(stmt, 3, mdnum);
+		sqlite3_bind_int64(stmt, 4, st_p->st_size);
+		sqlite3_bind_int64(stmt, 5, st_p->st_mtime);
+		sqlite3_bind_int64(stmt, 6, st_p->st_ctime);
+		sqlite3_bind_blob(stmt, 7, sum, checksum_len, SQLITE_TRANSIENT);
+		rc = sqlite3_step(stmt);
+		sqlite3_reset(stmt);
+		return rc == SQLITE_DONE;
+	    }
+#endif
+	}
+
+	return 0;
+}
+
+int db_clean_init(void)
+{
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL: {
+		MYSQL_BIND binds[MAX_BIND_CNT];
+
+		mysql_query(dbh.mysql,
+			"CREATE TEMPORARY TABLE inode_present ("
+			" disk_id integer unsigned NOT NULL,"
+			" ino bigint unsigned NOT NULL,"
+			" present tinyint NOT NULL default '1',"
+			" PRIMARY KEY (disk_id,ino)"
+			") ENGINE=MEMORY"
+			);
+
+		memset(binds, 0, sizeof binds);
+		binds[0].buffer_type = MYSQL_TYPE_LONG;
+		binds[0].buffer = &bind_disk_id;
+		binds[1].buffer_type = MYSQL_TYPE_LONGLONG;
+		binds[1].buffer = &bind_ino;
+		statements[INS_PRESENT].mysql = prepare_mysql(binds, 2,
+			"INSERT IGNORE INTO inode_present"
+			" SET disk_id = ?, ino = ?, present = 1"
+			);
+		if (!statements[INS_PRESENT].mysql)
+			return 0;
+
+		statements[DEL_SUMS].mysql = prepare_mysql(binds, 0,
+			"DELETE m.*"
+			" FROM inode_map AS m"
+			" LEFT JOIN inode_present USING(disk_id, ino)"
+			" JOIN disk AS d ON(m.disk_id = d.disk_id)"
+			" WHERE mounted = 1 AND present IS NULL"
+			);
+		if (!statements[DEL_SUMS].mysql)
+			return 0;
+
+		return 1;
+	    }
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		char *sql;
+		sql="ATTACH DATABASE '' AS aux1;"; /* Private temp DB, probably in-memory */
+		if (sqlite3_exec(dbh.sqlite, sql, NULL, NULL, NULL) != 0)
+			return 0;
+
+		sql="CREATE TABLE aux1.inode_present ("
+		    " disk_id integer NOT NULL,"
+		    " ino bigint NOT NULL,"
+		    " present tinyint NOT NULL default '1',"
+		    " PRIMARY KEY (disk_id,ino)"
+		    ")";
+		if (sqlite3_exec(dbh.sqlite, sql, NULL, NULL, NULL) != 0)
+			return 0;
+
+		sql="INSERT OR IGNORE INTO aux1.inode_present"
+		    " (disk_id, ino, present)"
+		    " VALUES (?, ?, 1)";
+		if (sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[INS_PRESENT].sqlite, NULL) != 0)
+			return 0;
+
+		sql="DELETE FROM inode_map"
+		    " WHERE ROWID IN ("
+		    "  SELECT m.ROWID"
+		    "  FROM inode_map AS m"
+		    "  LEFT JOIN aux1.inode_present USING(disk_id, ino)"
+		    "  JOIN disk AS d ON(m.disk_id = d.disk_id)"
+		    "  WHERE MOUNTED = 1 AND present IS NULL"
+		    " )";
+		if (sqlite3_prepare_v2(dbh.sqlite, sql, -1, &statements[DEL_SUMS].sqlite, NULL) != 0)
+			return 0;
+
+		return 1;
+	    }
+#endif
+	}
+
+	return 0;
+}
+
+int db_note_present(int disk_id, long long ino)
+{
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL:
+		bind_disk_id = disk_id;
+		bind_ino = ino;
+		return exec_mysql(INS_PRESENT) != NULL;
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		int rc;
+		sqlite3_stmt *stmt = statements[INS_PRESENT].sqlite;
+		sqlite3_bind_int(stmt, 1, disk_id);
+		sqlite3_bind_int64(stmt, 2, ino);
+		rc = sqlite3_step(stmt);
+		sqlite3_reset(stmt);
+		return rc == SQLITE_DONE;
+	    }
+#endif
+	}
+
+	return 0;
+}
+
+/* This function requires the user to have populated all disk_id+inode pairs
+ * into the inode_present table. */
+int db_clean_inodes(void)
+{
+	int del_cnt = 0;
+
+	switch (use_db) {
+#ifdef USE_MYSQL
+	case DB_TYPE_MYSQL: {
+		MYSQL_STMT *stmt = exec_mysql(DEL_SUMS);
+		if (stmt != NULL)
+			del_cnt = mysql_affected_rows(dbh.mysql);
+	    }
+#endif
+#ifdef USE_SQLITE
+	case DB_TYPE_SQLITE: {
+		int rc;
+		sqlite3_stmt *stmt = statements[DEL_SUMS].sqlite;
+		rc = sqlite3_step(stmt);
+		if (rc == SQLITE_DONE)
+			del_cnt = sqlite3_changes(dbh.sqlite);
+		sqlite3_reset(stmt);
+	    }
+#endif
+	}
+
+	db_clean_init();
+
+	return del_cnt;
+}
diff --git a/flist.c b/flist.c
--- a/flist.c
+++ b/flist.c
@@ -52,6 +52,7 @@ extern int preserve_devices;
 extern int preserve_specials;
 extern int delete_during;
 extern int missing_args;
+extern int use_db;
 extern int eol_nulls;
 extern int relative_paths;
 extern int implied_dirs;
@@ -1302,11 +1303,8 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 		extra_len += EXTRA_LEN;
 #endif
 
-	if (always_checksum && am_sender && S_ISREG(st.st_mode)) {
-		file_checksum(thisname, tmp_sum, st.st_size);
-		if (sender_keeps_checksum)
-			extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
-	}
+	if (sender_keeps_checksum && S_ISREG(st.st_mode))
+		extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
 
 #if EXTRA_ROUNDING > 0
 	if (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))
@@ -1391,8 +1389,12 @@ struct file_struct *make_file(const char *fname, struct file_list *flist,
 		return NULL;
 	}
 
-	if (sender_keeps_checksum && S_ISREG(st.st_mode))
-		memcpy(F_SUM(file), tmp_sum, checksum_len);
+	if (always_checksum && am_sender && S_ISREG(st.st_mode)) {
+		if (!use_db || !db_get_checksum(&st, tmp_sum))
+			file_checksum(thisname, &st, tmp_sum);
+		if (sender_keeps_checksum)
+			memcpy(F_SUM(file), tmp_sum, checksum_len);
+	}
 
 	if (unsort_ndx)
 		F_NDX(file) = stats.num_dirs;
@@ -2075,6 +2077,9 @@ struct file_list *send_file_list(int f, int argc, char *argv[])
 		     | (eol_nulls || reading_remotely ? RL_EOL_NULLS : 0);
 	int implied_dot_dir = 0;
 
+	if (use_db)
+		db_connect(0);
+
 	rprintf(FLOG, "building file list\n");
 	if (show_filelist_p())
 		start_filelist_progress("building file list");
diff --git a/generator.c b/generator.c
--- a/generator.c
+++ b/generator.c
@@ -58,6 +58,7 @@ extern int human_readable;
 extern int ignore_existing;
 extern int ignore_non_existing;
 extern int inplace;
+extern int use_db;
 extern int append_mode;
 extern int make_backups;
 extern int csum_length;
@@ -574,7 +575,8 @@ int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
 	   of the file time to determine whether to sync */
 	if (always_checksum > 0 && S_ISREG(st->st_mode)) {
 		char sum[MAX_DIGEST_LEN];
-		file_checksum(fn, sum, st->st_size);
+		if (!use_db || !db_get_checksum(st, sum))
+			file_checksum(fn, st, sum);
 		return memcmp(sum, F_SUM(file), checksum_len) == 0;
 	}
 
@@ -2193,6 +2195,9 @@ void generate_files(int f_out, const char *local_name)
 			: "enabled");
 	}
 
+	if (use_db && always_checksum)
+		db_connect(0);
+
 	dflt_perms = (ACCESSPERMS & ~orig_umask);
 
 	do {
diff --git a/loadparm.c b/loadparm.c
--- a/loadparm.c
+++ b/loadparm.c
@@ -109,6 +109,7 @@ typedef struct {
 	char *auth_users;
 	char *charset;
 	char *comment;
+	char *db_config;
 	char *dont_compress;
 	char *exclude;
 	char *exclude_from;
@@ -185,6 +186,7 @@ static const all_vars Defaults = {
  /* auth_users; */		NULL,
  /* charset; */ 		NULL,
  /* comment; */ 		NULL,
+ /* db_config; */		NULL,
  /* dont_compress; */		DEFAULT_DONT_COMPRESS,
  /* exclude; */			NULL,
  /* exclude_from; */		NULL,
@@ -322,6 +324,7 @@ static struct parm_struct parm_table[] =
  {"auth users",        P_STRING, P_LOCAL, &Vars.l.auth_users,          NULL,0},
  {"charset",           P_STRING, P_LOCAL, &Vars.l.charset,             NULL,0},
  {"comment",           P_STRING, P_LOCAL, &Vars.l.comment,             NULL,0},
+ {"db config",         P_STRING, P_LOCAL, &Vars.l.db_config,           NULL,0},
  {"dont compress",     P_STRING, P_LOCAL, &Vars.l.dont_compress,       NULL,0},
  {"exclude from",      P_STRING, P_LOCAL, &Vars.l.exclude_from,        NULL,0},
  {"exclude",           P_STRING, P_LOCAL, &Vars.l.exclude,             NULL,0},
@@ -454,6 +457,7 @@ FN_GLOBAL_INTEGER(lp_rsync_port, &Vars.g.rsync_port)
 FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_charset, charset)
 FN_LOCAL_STRING(lp_comment, comment)
+FN_LOCAL_STRING(lp_db_config, db_config)
 FN_LOCAL_STRING(lp_dont_compress, dont_compress)
 FN_LOCAL_STRING(lp_exclude, exclude)
 FN_LOCAL_STRING(lp_exclude_from, exclude_from)
diff --git a/main.c b/main.c
--- a/main.c
+++ b/main.c
@@ -51,6 +51,7 @@ extern int copy_unsafe_links;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
+extern int always_checksum;
 extern int file_total;
 extern int recurse;
 extern int xfer_dirs;
@@ -84,6 +85,7 @@ extern char *filesfrom_host;
 extern char *partial_dir;
 extern char *dest_option;
 extern char *rsync_path;
+extern char *db_config;
 extern char *shell_cmd;
 extern char *batch_name;
 extern char *password_file;
@@ -1622,6 +1624,9 @@ int main(int argc,char *argv[])
 		exit_cleanup(RERR_SYNTAX);
 	}
 
+	if (db_config && always_checksum)
+		db_read_config(FERROR, db_config);
+
 	if (am_server) {
 		set_nonblocking(STDIN_FILENO);
 		set_nonblocking(STDOUT_FILENO);
diff --git a/mkproto.pl b/mkproto.pl
--- a/mkproto.pl
+++ b/mkproto.pl
@@ -13,6 +13,8 @@ if (open(IN, 'proto.h')) {
     STRING => 'char *',
 );
 
+@ARGV = grep !m{/rsyncdb\.c$}, @ARGV;
+
 $inheader = 0;
 $protos = qq|/* This file is automatically generated with "make proto". DO NOT EDIT */\n\n|;
 
diff --git a/options.c b/options.c
--- a/options.c
+++ b/options.c
@@ -93,6 +93,7 @@ int use_qsort = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *filesfrom_host = NULL;
+char *db_config = NULL;
 int eol_nulls = 0;
 int protect_args = -1;
 int human_readable = 1;
@@ -572,6 +573,7 @@ static void print_rsync_version(enum logcode f)
 	char const *links = "no ";
 	char const *iconv = "no ";
 	char const *ipv6 = "no ";
+	char const *db = "no ";
 	STRUCT_STAT *dumstat;
 
 #if SUBPROTOCOL_VERSION != 0
@@ -608,6 +610,11 @@ static void print_rsync_version(enum logcode f)
 #ifdef CAN_SET_SYMLINK_TIMES
 	symtimes = "";
 #endif
+#if defined HAVE_MYSQL_MYSQL_H && defined HAVE_LIBMYSQLCLIENT
+	db = "";
+#elif defined HAVE_SQLITE3_H && defined HAVE_LIBSQLITE3
+	db = "";
+#endif
 
 	rprintf(f, "%s  version %s  protocol version %d%s\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION, subprotocol);
@@ -621,8 +628,8 @@ static void print_rsync_version(enum logcode f)
 		(int)(sizeof (int64) * 8));
 	rprintf(f, "    %ssocketpairs, %shardlinks, %ssymlinks, %sIPv6, batchfiles, %sinplace,\n",
 		got_socketpair, hardlinks, links, ipv6, have_inplace);
-	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes, %sprealloc\n",
-		have_inplace, acls, xattrs, iconv, symtimes, prealloc);
+	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes, %sprealloc, %sdb\n",
+		have_inplace, acls, xattrs, iconv, symtimes, prealloc, db);
 
 #ifdef MAINTAINER_MODE
 	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
@@ -671,6 +678,7 @@ void usage(enum logcode F)
   rprintf(F," -q, --quiet                 suppress non-error messages\n");
   rprintf(F,"     --no-motd               suppress daemon-mode MOTD (see manpage caveat)\n");
   rprintf(F," -c, --checksum              skip based on checksum, not mod-time & size\n");
+  rprintf(F,"     --db=CONFIG_FILE        specify a CONFIG_FILE for DB checksums\n");
   rprintf(F," -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)\n");
   rprintf(F,"     --no-OPTION             turn off an implied OPTION (e.g. --no-D)\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
@@ -957,6 +965,7 @@ static struct poptOption long_options[] = {
   {"checksum",        'c', POPT_ARG_VAL,    &always_checksum, 1, 0, 0 },
   {"no-checksum",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"no-c",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
+  {"db",               0,  POPT_ARG_STRING, &db_config, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
diff --git a/pipe.c b/pipe.c
--- a/pipe.c
+++ b/pipe.c
@@ -27,6 +27,9 @@ extern int am_server;
 extern int blocking_io;
 extern int filesfrom_fd;
 extern int munge_symlinks;
+extern int always_checksum;
+extern int use_db;
+extern char *db_config;
 extern char *logfile_name;
 extern int remote_option_cnt;
 extern const char **remote_options;
@@ -141,6 +144,9 @@ pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 			logfile_close();
 		}
 
+		use_db = 0;
+		db_config = NULL;
+
 		if (remote_option_cnt) {
 			int rc = remote_option_cnt + 1;
 			const char **rv = remote_options;
@@ -148,6 +154,8 @@ pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 				option_error();
 				exit_cleanup(RERR_SYNTAX);
 			}
+			if (db_config && always_checksum)
+				db_read_config(FERROR, db_config);
 		}
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
diff --git a/rsync.yo b/rsync.yo
--- a/rsync.yo
+++ b/rsync.yo
@@ -337,6 +337,7 @@ to the detailed description below for a complete description.  verb(
  -q, --quiet                 suppress non-error messages
      --no-motd               suppress daemon-mode MOTD (see caveat)
  -c, --checksum              skip based on checksum, not mod-time & size
+     --db=CONFIG_FILE        specify a CONFIG_FILE for DB checksums
  -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
      --no-OPTION             turn off an implied OPTION (e.g. --no-D)
  -r, --recursive             recurse into directories
@@ -625,6 +626,47 @@ option's before-the-transfer "Does this file need to be updated?" check.
 For protocol 30 and beyond (first supported in 3.0.0), the checksum used is
 MD5.  For older protocols, the checksum used is MD4.
 
+dit(bf(--db=CONFIG_FILE))  This option specifies a CONFIG_FILE to read
+that holds connection details for a database of checksum information.
+When combined with the bf(--checksum) (bf(-c)) option, rsync will try to
+use cached checksum information from the DB, and will update it if it is
+missing.
+
+The currently supported DB choices are MySQL and SQLite.  For example, a
+MySQL configuration might look like this:
+
+verb(    dbtype: mysql
+    dbhost: 127.0.0.1
+    dbname: rsyncdb
+    dbuser: rsyncuser
+    dbpass: somepass
+    port: 3306
+    thishost: hostname )
+
+And a SQLite configuration might look like this:
+
+verb(    dbtype: SQLite
+    dbname: /var/cache/rsync/sum.db )
+
+This option only affects one side of a transfer.  See the
+bf(--remote-option) option for a way to specify the option for both
+sides of the transfer (with each side reading the config file from
+their local filesystem).  For example:
+
+verb(    rsync -avc {-M,}--db=/etc/rsyncdb.conf src/ host:dest/ )
+
+See the perl script "rsyncdb" in the support directory of the source code
+(which may also be installed in /usr/bin) for a way to create the tables,
+populate the mounted-disk information, check files against their checksums,
+and update both the MD4 and MD5 checksums for files at the same time (since
+an rsync copy will only update one or the other).
+
+You can use a single MySQL DB for all your hosts if you give each one
+their own "thishost" name and setup their device-mapping data.  Or feel
+free to use separate databases, separate servers, etc.  See the rsync
+daemon's "db config" parameter for how to configure a daemon to use a DB
+(since a client cannot control this parameter on a daemon).
+
 dit(bf(-a, --archive)) This is equivalent to bf(-rlptgoD). It is a quick
 way of saying you want recursion and want to preserve almost
 everything (with -H being a notable omission).
diff --git a/rsyncd.conf.yo b/rsyncd.conf.yo
--- a/rsyncd.conf.yo
+++ b/rsyncd.conf.yo
@@ -312,6 +312,18 @@ is daemon.  This setting has no effect if the "log file" setting is a
 non-empty string (either set in the per-modules settings, or inherited
 from the global settings).
 
+dit(bf(db config)) This parameter specifies a config file to read that
+holds connection details for a database of checksum information.
+
+The config file will be read-in prior to any chroot restrictions, but
+the connection occurs from inside the chroot.  This means that you
+should use a socket connection (e.g. 127.0.0.1 rather than localhost)
+for a MySQL config from inside a chroot.  For SQLite, the DB file must
+be placed inside the chroot (though it can be placed outside the
+transfer dir if you configured an inside-chroot path).
+
+See the bf(--db=CONFIG_FILE) option for full details.
+
 dit(bf(max verbosity)) This parameter allows you to control
 the maximum amount of verbose information that you'll allow the daemon to
 generate (since the information goes into the log file). The default is 1,
diff --git a/rsyncdb.c b/rsyncdb.c
new file mode 100644
--- /dev/null
+++ b/rsyncdb.c
@@ -0,0 +1,620 @@
+/*
+ * This helper program maintains an dev+inode DB.
+ *
+ * Copyright (C) 2013 Wayne Davison
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, visit the http://fsf.org website.
+ */
+
+#include "rsync.h"
+#include "itypes.h"
+#include "ifuncs.h"
+#include <popt.h>
+
+#define MYNAME "rsync-db"
+
+#define PTR_SIZE (sizeof (struct file_struct *))
+
+#define MALLOC_MAX 0x40000000
+
+struct name_list {
+	struct name_list *next;
+	char name[1];
+} *dirs_list;
+
+int check_opt;
+int clean_opt;
+int dry_run;
+int recurse_opt;
+int verbosity = 0;
+char *db_config = NULL;
+
+int am_root, am_sender, list_only, read_only;
+int preserve_executability, preserve_perms, sparse_files;
+
+int saw_output_opt, saw_sum_opt;
+int output_dirs, output_name, output_sum, output_info, output_unchanged;
+int do_md4, do_md5;
+
+int checksum_len = MD5_DIGEST_LEN;
+int protocol_version = 31;
+short debug_levels[COUNT_DEBUG];
+
+static struct poptOption long_options[] = {
+  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
+  {"check",           'c', POPT_ARG_VAL,    &check_opt, 1, 0, 0},
+  {"only-check",       0,  POPT_ARG_VAL,    &check_opt, 2, 0, 0},
+  {"clean",            0,  POPT_ARG_VAL,    &clean_opt, 1, 0, 0},
+  {"only-clean",       0,  POPT_ARG_VAL,    &clean_opt, 2, 0, 0},
+  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
+  {"db",               0,  POPT_ARG_STRING, &db_config, 0, 0, 0 },
+  {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
+  {"output",          'o', POPT_ARG_STRING, 0, 'o', 0, 0 },
+  {"recurse",         'r', POPT_ARG_NONE,   &recurse_opt, 0, 0, 0 },
+  {"recursive",        0,  POPT_ARG_NONE,   &recurse_opt, 0, 0, 0 },
+  {"sums",            's', POPT_ARG_STRING, 0, 's', 0, 0 },
+  {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
+  {0,0,0,0, 0, 0, 0}
+};
+
+static void show_usage(int code);
+static const char *abs_path(const char *curdir, const char *dir);
+static struct name_list *new_name(const char *basename, const char *filename);
+static struct name_list *get_sorted_names(const char *dir);
+static int mention_file(const char *dir, const char *name, int right_cnt, int wrong_cnt,
+			const char *dbsum4, const char *dbsum5, const char *sum4, const char *sum5);
+
+int main(int argc, char *argv[])
+{
+	poptContext pc = poptGetContext(MYNAME, argc, (const char**)argv, long_options, 0);
+	int opt, need_sum_cnt, start_dir_len;
+	struct name_list *prior_dir;
+	struct name_list *names;
+	char *cp, start_dir[MAXPATHLEN];
+	const char **args;
+	int exit_code = 0;
+
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		switch (opt) {
+		  case 'h':
+		    show_usage(0);
+		    break;
+		  case 'o':
+		    for (cp = poptGetOptArg(pc); *cp; cp++) {
+			    switch (toLower(cp)) {
+			      case 'n':
+				output_name = 1;
+				break;
+			      case 's':
+			      case 'c':
+				output_sum = output_name = 1;
+				break;
+			      case 'i':
+				output_info = output_name = 1;
+				break;
+			      case 'u':
+				output_unchanged = output_name = 1;
+				break;
+			      case 'd':
+				output_dirs = 1;
+				break;
+			    }
+		    }
+		    saw_output_opt = 1;
+		    break;
+		  case 's':
+		    for (cp = poptGetOptArg(pc); *cp; cp++) {
+			    switch (*cp) {
+			      case '4':
+				do_md4 = 1;
+				break;
+			      case '5':
+				do_md5 = 1;
+				break;
+			    }
+		    }
+		    saw_sum_opt = 1;
+		    break;
+		  case 'v':
+		    verbosity++;
+		    break;
+		  default:
+		    show_usage(1);
+		    break;
+		}
+	}
+
+	if (!db_config) {
+		fprintf(stderr, "You must specify the --db=FILE option.\n");
+		show_usage(1);
+	}
+
+	if (check_opt) {
+		if (!verbosity)
+			verbosity = 1;
+		output_info = 1;
+	}
+	if (!saw_output_opt && verbosity)
+		output_dirs = output_name = 1;
+	if (!saw_sum_opt)
+		do_md4 = do_md5 = 1;
+
+	need_sum_cnt = do_md4 + do_md5;
+
+	if (!db_read_config(FERROR, db_config) || !db_connect(1))
+		exit(1);
+
+        if (clean_opt)
+		db_clean_init();
+
+	if (getcwd(start_dir, sizeof start_dir - 1) == NULL) {
+		rsyserr(FERROR, errno, "getcwd()");
+		exit_cleanup(RERR_FILESELECT);
+	}
+	start_dir_len = strlen(start_dir);
+
+	args = poptGetArgs(pc);
+	if (args) {
+		prior_dir = NULL;
+		while (*args) {
+			struct name_list *add = new_name(abs_path(start_dir, *args++), NULL);
+			if (!add)
+				continue;
+			if (prior_dir)
+				prior_dir->next = add;
+			else
+				dirs_list = add;
+			prior_dir = add;
+		}
+	} else
+		dirs_list = new_name(abs_path(start_dir, "."), NULL);
+
+	prior_dir = NULL;
+	while (dirs_list) {
+		struct name_list *subdirs, *prior_subdir, *prior_name;
+		const char *dir = dirs_list->name;
+		const char *reldir = dir;
+
+		if (prior_dir)
+			free((void*)prior_dir);
+		prior_dir = dirs_list;
+		dirs_list = dirs_list->next;
+
+		if (strncmp(reldir, start_dir, start_dir_len) == 0) {
+			if (reldir[start_dir_len] == '\0')
+				reldir = ".";
+			else if (reldir[start_dir_len] == '/')
+				reldir += start_dir_len + 1;
+		}
+		if (output_dirs)
+			printf("... %s/ ...\n", reldir);
+
+		if (chdir(dir) < 0) {
+			fprintf(stderr, "Unable to chdir to %s: %s\n", dir, strerror(errno));
+			continue;
+		}
+		if (!(names = get_sorted_names(dir)))
+			continue;
+
+		subdirs = prior_subdir = prior_name = NULL;
+		while (names) {
+			STRUCT_STAT st;
+			char *dbsum4, sum4[MD5_DIGEST_LEN];
+			char *dbsum5, sum5[MD5_DIGEST_LEN];
+			int right_sum_cnt, wrong_sum_cnt;
+			const char *name = names->name;
+			unsigned int disk_id;
+
+			if (prior_name)
+				free((void*)prior_name);
+			prior_name = names;
+			names = names->next;
+
+			if (lstat(name, &st) < 0) {
+				fprintf(stderr, "Failed to lstat(%s): %s\n", name, strerror(errno));
+				continue;
+			}
+			if (S_ISLNK(st.st_mode))
+				continue;
+			if (S_ISDIR(st.st_mode)) {
+				// add optional excluding of things like /^(CVS|\.svn|\.git|\.bzr)$/;
+				if (recurse_opt) {
+					struct name_list *add = new_name(dir, name);
+					if (add) {
+						if (prior_subdir)
+							prior_subdir->next = add;
+						else
+							subdirs = add;
+						prior_subdir = add;
+					}
+				}
+				continue;
+			}
+			if (!S_ISREG(st.st_mode))
+				continue;
+
+			if (!(disk_id = get_disk_id(st.st_dev)))
+				continue;
+			if (clean_opt) {
+				db_note_present(disk_id, st.st_ino);
+				if (clean_opt > 1)
+					continue;
+			}
+			db_get_both_checksums(&st, &right_sum_cnt, &wrong_sum_cnt,
+					      do_md4 ? &dbsum4 : NULL, do_md5 ? &dbsum5 : NULL);
+
+			if (!check_opt && right_sum_cnt == need_sum_cnt) {
+				mention_file(reldir, name, right_sum_cnt, wrong_sum_cnt, dbsum4, dbsum5, dbsum4, dbsum5);
+				continue;
+			}
+
+			if (!check_opt || right_sum_cnt || output_sum) {
+				uchar *data;
+				int32 remainder;
+				md_context m4, m5;
+				struct map_struct *buf;
+				OFF_T off, len = st.st_size;
+				int fd = do_open(name, O_RDONLY, 0);
+
+				if (fd < 0) {
+					fprintf(stderr, "ERROR: unable to read %s: %s\n", name, strerror(errno));
+					continue;
+				}
+
+				if (do_md4)
+					mdfour_begin(&m4);
+				if (do_md5)
+					md5_begin(&m5);
+
+				buf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);
+
+				for (off = 0; off + CSUM_CHUNK <= len; off += CSUM_CHUNK) {
+					data = (uchar*)map_ptr(buf, off, CSUM_CHUNK);
+					if (do_md4)
+						mdfour_update(&m4, data, CSUM_CHUNK);
+					if (do_md5)
+						md5_update(&m5, data, CSUM_CHUNK);
+				}
+
+				remainder = (int32)(len - off);
+				data = (uchar*)map_ptr(buf, off, remainder);
+				if (do_md4) {
+					mdfour_update(&m4, data, remainder);
+					mdfour_result(&m4, (uchar*)sum4);
+				}
+				if (do_md5) {
+					md5_update(&m5, data, remainder);
+					md5_result(&m5, (uchar*)sum5);
+				}
+
+				close(fd);
+				unmap_file(buf);
+			}
+
+			int chg = mention_file(reldir, name, right_sum_cnt, wrong_sum_cnt, dbsum4, dbsum5, sum4, sum5);
+			if (!chg) {
+				// Only check_opt should get here...
+			} else if (check_opt == 2) {
+				exit_code = 1;
+			} else {
+				if (do_md4)
+					db_set_checksum(4, &st, sum4);
+				if (do_md5)
+					db_set_checksum(5, &st, sum5);
+			}
+		}
+		if (prior_name)
+			free((void*)prior_name);
+
+		if (recurse_opt && subdirs) {
+			prior_subdir->next = dirs_list;
+			dirs_list = subdirs;
+		}
+	}
+	if (prior_dir)
+		free((void*)prior_dir);
+
+	if (clean_opt) {
+		int rows = db_clean_inodes();
+		if (verbosity)
+			printf("Cleaned out %d old inode%s.\n", rows, rows == 1 ? "" : "s");
+	}
+
+	return exit_code;
+}
+
+static const char *abs_path(const char *curdir, const char *dir)
+{
+	static char buf[MAXPATHLEN];
+	char *t = buf, *limit = buf - 1;
+	const char *f;
+
+	if (*dir == '/') {
+		curdir = NULL;
+		f = dir;
+	} else {
+		if (*curdir != '/') {
+			fprintf(stderr, "Malformed 'curdir' value passed to abs_path(): %s.\n", curdir);
+			return NULL;
+		}
+		f =  curdir;
+	}
+
+	*t++ = *f++;
+	if (!*f && curdir) {
+		f = dir;
+		curdir = NULL;
+	}
+	while (*f) {
+		/* Discard extra slashes */
+		if (*f == '/') {
+			f++;
+			continue;
+		}
+		if (*f == '.') {
+			/* Discard interior and trailing "." dirs */
+			if (f[1] == '/') {
+				f += 2;
+				continue;
+			}
+			if (f[1] == '\0') {
+				if (curdir) {
+					f = dir;
+					curdir = NULL;
+					continue;
+				}
+				break;
+			}
+			/* collapse ".." dirs */
+			if (f[1] == '.' && (f[2] == '/' || !f[2])) {
+				char *s = t - 1;
+				if (s == buf) {
+					f += 2;
+					continue;
+				}
+				while (s > limit && *--s != '/') {}
+				if (s != t - 1 && (s < buf || *s == '/')) {
+					t = s + 1;
+					f += 2;
+					continue;
+				}
+				limit = t + 2;
+			}
+		}
+		while (1) {
+			if (!*f) {
+				if (curdir) {
+					*t++ = '/';
+					f = dir;
+					curdir = NULL;
+				}
+				break;
+			}
+			if (t - buf >= (int)sizeof buf - 2) {
+				fprintf(stderr, "Directory too long: %s\n", dir);
+				return NULL;
+			}
+
+			if ((*t++ = *f++) == '/')
+				break;
+		}
+	}
+
+	if (t > buf+1 && t[-1] == '/')
+		t--;
+	*t = '\0';
+
+	return buf;
+}
+
+static struct name_list *new_name(const char *basename, const char *filename)
+{
+	struct name_list *n;
+	int blen = strlen(basename);
+	int slen = filename ? (int)strlen(filename) : -1;
+	int len = blen + 1 + slen;
+
+	if (len >= MAXPATHLEN) {
+		if (filename)
+			fprintf(stderr, "Filename too long: %s/%s\n", basename, filename);
+		else
+			fprintf(stderr, "Filename too long: %s\n", basename);
+		return NULL;
+	}
+
+	if (!(n = (struct name_list *)malloc(sizeof (struct name_list) + len)))
+		out_of_memory("new_name");
+
+	memcpy(n->name, basename, blen);
+	if (filename) {
+		n->name[blen] = '/';
+		memcpy(n->name + 1 + blen, filename, slen);
+	}
+	n->name[len] = '\0';
+	n->next = NULL;
+
+	return n;
+}
+
+static int name_compare(const void *n1, const void *n2)
+{
+	struct name_list *p1 = *(struct name_list **)n1;
+	struct name_list *p2 = *(struct name_list **)n2;
+	return strcmp(p1->name, p2->name);
+}
+
+static struct name_list *get_sorted_names(const char *dir)
+{
+	struct name_list *add, **sortbuf, *names = NULL, *prior_name = NULL;
+	struct dirent *di;
+	int cnt = 0;
+	DIR *d;
+
+	if (!(d = opendir("."))) {
+		fprintf(stderr, "Unable to opendir %s: %s\n", dir, strerror(errno));
+		return NULL;
+	}
+	while ((di = readdir(d)) != NULL) {
+		char *dname = d_name(di);
+		if (dname[0] == '.' && (dname[1] == '\0' || (dname[1] == '.' && dname[2] == '\0')))
+			continue;
+		if (!(add = new_name(dname, NULL)))
+			continue;
+		if (prior_name)
+			prior_name->next = add;
+		else
+			names = add;
+		prior_name = add;
+		cnt++;
+	}
+	closedir(d);
+
+	if (cnt) {
+		int j;
+
+		if (!(sortbuf = new_array(struct name_list *, cnt)))
+			out_of_memory("get_sorted_names");
+		for (j = 0; j < cnt; j++) {
+			sortbuf[j] = names;
+			names = names->next;
+		}
+
+		qsort(sortbuf, cnt, PTR_SIZE, name_compare);
+
+		names = prior_name = NULL;
+		for (j = 0; j < cnt; j++) {
+			add = sortbuf[j];
+			if (prior_name)
+				prior_name->next = add;
+			else
+				names = add;
+			prior_name = add;
+		}
+
+		if (prior_name)
+			prior_name->next = NULL;
+		free(sortbuf);
+	}
+
+	return names;
+}
+
+const char *who_am_i(void)
+{
+	return MYNAME;
+}
+
+void rprintf(enum logcode code, const char *format, ...)
+{
+	va_list ap;
+	va_start(ap, format);
+	vfprintf(code == FINFO ? stdout : stderr, format, ap);
+	va_end(ap);
+}
+
+ void rsyserr(UNUSED(enum logcode code), int errcode, const char *format, ...)
+{
+	va_list ap;
+	fputs(MYNAME ": ", stderr);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fprintf(stderr, ": %s (%d)\n", strerror(errcode), errcode);
+}
+
+NORETURN void _exit_cleanup(int code, UNUSED(const char *file), UNUSED(int line))
+{
+	db_disconnect();
+	exit(code);
+}
+
+static inline int sums_ne(const char *sum1, const char *sum2)
+{
+	return memcmp(sum1, sum2, checksum_len) != 0;
+}
+
+// Returns 1 if there is a checksum change, else undef.
+static int mention_file(const char *dir, const char *name, int right_cnt, int wrong_cnt,
+			const char *dbsum4, const char *dbsum5, const char *sum4, const char *sum5)
+{
+	char *info_str = wrong_cnt && !right_cnt ? "!i " : "   ";
+	char *md4_str = !do_md4 ? NULL : !dbsum4 ? "+4 " : !sum4 ? "?4 " : sums_ne(sum4, dbsum4) ? "!4 " : "   ";
+	char *md5_str = !do_md5 ? NULL : !dbsum5 ? "+5 " : !sum5 ? "?5 " : sums_ne(sum5, dbsum5) ? "!5 " : "   ";
+	int chg = *info_str != ' ' || (md4_str && *md4_str != ' ') || (md5_str && *md5_str != ' ');
+	if (chg || output_unchanged) {
+		if (output_info) {
+			fputs(info_str, stdout);
+			if (md4_str)
+				fputs(md4_str, stdout);
+			if (md5_str)
+				fputs(md5_str, stdout);
+		}
+		if (output_sum) {
+			if (do_md4)
+				printf("%s ", sum_as_hex(sum4));
+			if (do_md5)
+				printf("%s ", sum_as_hex(sum5));
+		}
+		if (output_name) {
+			if (output_sum)
+				putchar(' '); /* We want 2 spaces, like md5sum. */
+			if (*dir != '.' || dir[1]) {
+				fputs(dir, stdout);
+				putchar('/');
+			}
+			puts(name);
+		}
+	}
+
+	return chg;
+}
+
+static void show_usage(int code)
+{
+	fprintf(code ? stderr : stdout, "\n\
+Usage: rsyncdb --db=CONFIG_FILE [OPTIONS] [DIRS]\n\
+\n\
+Options:\n\
+--db=FILE          Specify the config FILE to read for the DB info.\n\
+--recurse (-r)     Scan files in subdirectories too.\n\
+--sums=SUMS (-s)   List which checksums to update (default: 4,5).  Note that\n\
+                   this doesn't affect the order of sum output via \"-o s\".\n\
+--verbosity (-v)   Output change info for --init, --mounts, and --*clean.\n\
+                   Also makes checksumming output default be \"-o dn\".\n\
+--output=STR (-o)  One or more letters of what to output (default is nothing).\n\
+                   d = output \"... dir_name ...\" lines from our scan.\n\
+                   n = output names of items with changes.\n\
+                   s = output checksum info for changes (implies n).\n\
+                   u = output even unchanged items (implies n).\n\
+                   i = output prefixed change info: !i if time and/or size is\n\
+                       wrong, +4/+5 if the MD4/5 sum is missing, !4/!5 if sum\n\
+                       is wrong, ?4/?5 if we didn't need to read the file (i.e.\n\
+                       if time/size is wrong and no sum output was requested).\n\
+--check (-c)       Check the checksums (by reading the files) and fix any\n\
+                   issues.  Implies --verbose and enables output of \"i\".\n\
+--only-check       Like --check, but doesn't fix anything.\n\
+--clean            Read all inodes from the DB and remove the ones that aren't\n\
+                   found in the DIR(s) while also updating the DB's info.  You\n\
+                   need to specify all mounted DIRs in the DB & also --recurse.\n\
+--only-clean       Like --clean, but avoids adding missing info.\n\
+--help (-h)        Display this help message.\n\
+\n\
+Examples:\n\
+\n\
+rsyncdb --db=/etc/db.conf -r -o n /src\n\
+rsyncdb --db=/etc/db.conf -r --check /src\n\
+rsyncdb --db=/etc/db.conf -s5 -rous /src >/tmp/really-fast-md5sum.txt\n\
+");
+        exit(code);
+}
diff --git a/support/rsyncdb b/support/rsyncdb
new file mode 100755
--- /dev/null
+++ b/support/rsyncdb
@@ -0,0 +1,417 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use DBI;
+use Getopt::Long;
+use Cwd qw(abs_path cwd);
+use Digest::MD4;
+use Digest::MD5;
+
+my $MOUNT_FILE = '/etc/mtab';
+
+&Getopt::Long::Configure('bundling');
+&usage if !&GetOptions(
+    'db=s' => \( my $db_config ),
+    'init' => \( my $init_db ),
+    'mounts|m' => \( my $update_mounts ),
+    'recurse|r' => \( my $recurse_opt ),
+    'sums|s=s' => \( my $sums = '4,5' ),
+    'verbose|v+' => \( my $verbosity = 0 ),
+    'output|o=s' => \( my $output ),
+    'check|c' => \( my $check_opt ),
+    'clean' => \( my $clean_opt ),
+    'only-clean' => \( my $only_clean_opt ),
+    'help|h' => \( my $help_opt ),
+);
+&usage if $help_opt || !defined $db_config;
+
+$verbosity ||= 1 if $check_opt;
+$clean_opt = 1 if $only_clean_opt;
+$output ||= $verbosity ? 'dn' : '';
+$output .= 's' if $output =~ /c/; # Be nice if they specify c instead of s.
+$output .= 'n' if $output =~ /[isu]/;
+$output .= 'i' if $check_opt;
+$output = lc($output);
+
+my $do_md4 = $sums =~ /\b(md)?4\b/i ? 1 : 0;
+my $do_md5 = $sums =~ /\b(md)?5\b/i ? 1 : 0;
+my $need_sum_cnt = $do_md4 + $do_md5;
+
+my %config;
+open IN, '<', $db_config or die "Unable to open $db_config: $!\n";
+while (<IN>) {
+    s/[#\r\n].*//s;
+    next if /^$/;
+    my($key, $val) = /^(\S+):\s*(.*)/ or die "Unable to parse line $. of $db_config\n";
+    $config{$key} = $val;
+}
+close IN;
+
+die "You must define at least dbtype and dbname in $db_config\n"
+    unless defined $config{'dbtype'} && defined $config{'dbname'};
+
+my $sqlite = $config{'dbtype'} =~ /^sqlite$/i;
+
+my $thishost = $config{'thishost'} || 'localhost';
+
+my $connect = 'DBI:' . $config{'dbtype'} . ':';
+$connect .= 'dbname=' . $config{'dbname'} if $sqlite;
+$connect .= 'database=' . $config{'dbname'} if !$sqlite && !$init_db;
+$connect .= ';host=' . $config{'dbhost'} if defined $config{'dbhost'};
+$connect .= ';port=' . $config{'dbport'} if defined $config{'dbport'};
+
+my $dbh = DBI->connect($connect, $config{'dbuser'}, $config{'dbpass'})
+    or die "DB connection failed\n";
+
+END {
+    $dbh->disconnect if defined $dbh;
+}
+
+if ($init_db) {
+    my $unsigned = $sqlite ? '' : 'unsigned';
+    my $auto_increment = $sqlite ? 'AUTOINCREMENT' : 'AUTO_INCREMENT';
+    my $dbname = $config{'dbname'};
+
+    if (!$sqlite) {
+	$dbh->do("CREATE DATABASE IF NOT EXISTS `$dbname`");
+	$dbh->do("USE `$dbname`");
+    }
+
+    print "Dropping old tables (if they exist) ...\n" if $verbosity;
+    $dbh->do("DROP TABLE IF EXISTS disk") or die $dbh->errstr;
+    $dbh->do("DROP TABLE IF EXISTS inode_map") or die $dbh->errstr;
+
+    print "Creating empty tables ...\n" if $verbosity;
+    $dbh->do("
+	CREATE TABLE disk (
+	  disk_id integer $unsigned NOT NULL PRIMARY KEY $auto_increment,
+	  devno bigint $unsigned NOT NULL,
+	  host varchar(256) NOT NULL default 'localhost',
+	  mounted tinyint NOT NULL default '1',
+	  comment varchar(256) default NULL
+	)") or die $dbh->errstr;
+
+    $dbh->do("
+	CREATE TABLE inode_map (
+	  disk_id integer $unsigned NOT NULL,
+	  ino bigint $unsigned NOT NULL,
+	  size bigint $unsigned NOT NULL,
+	  mtime bigint NOT NULL,
+	  ctime bigint NOT NULL,
+	  sum_type tinyint NOT NULL default '0',
+	  checksum binary(16) NOT NULL,
+	  PRIMARY KEY (disk_id,ino,sum_type)
+	)") or die $dbh->errstr;
+
+    exit unless $update_mounts;
+}
+
+my $sel_disk_H = $dbh->prepare("
+    SELECT disk_id, devno, mounted, comment
+    FROM disk
+    WHERE host = ?
+    ") or die $dbh->errstr;
+
+my $ins_disk_H = $dbh->prepare("
+    INSERT INTO disk
+    (devno, host, mounted, comment)
+    VALUES (?, ?, ?, ?)
+    ") or die $dbh->errstr;
+
+my $up_disk_H = $dbh->prepare("
+    UPDATE disk
+    SET mounted = ?
+    WHERE disk_id = ?
+    ") or die $dbh->errstr;
+
+my $sel_sum_H = $dbh->prepare("
+    SELECT sum_type, checksum, size, mtime, ctime
+    FROM inode_map
+    WHERE disk_id = ? AND ino = ?
+    ") or die $dbh->errstr;
+
+my $rep_sum_H = $dbh->prepare("
+    REPLACE INTO inode_map
+    (disk_id, ino, size, mtime, ctime, sum_type, checksum)
+    VALUES (?, ?, ?, ?, ?, ?, ?)
+    ") or die $dbh->errstr;
+
+my $del_sum_H = $dbh->prepare("
+    DELETE FROM inode_map
+    WHERE disk_id = ? AND ino = ? AND sum_type = ?
+    ") or die $dbh->errstr;
+
+my %mounts;
+if ($update_mounts) {
+    open IN, $MOUNT_FILE or die "Unable to open $MOUNT_FILE: $!\n";
+    while (<IN>) {
+	my($devname, $mnt) = (split)[0,1];
+	next unless $devname =~ m#^/dev#;
+	my($devno) = (stat($mnt))[0];
+	if (!defined $devno) {
+	    warn "Unable to stat $mnt: $!\n";
+	    next;
+	}
+	$mounts{$devno} = "$devname on $mnt";
+    }
+    close IN;
+}
+
+my %disk_id;
+$sel_disk_H->execute($thishost);
+while (my($disk_id, $devno, $mounted, $comment) = $sel_disk_H->fetchrow_array) {
+    if ($update_mounts) {
+	my $changed;
+	if (defined $mounts{$devno} && $comment eq $mounts{$devno}) {
+	    if (!$mounted) {
+		print "Noting mounted state for $comment ($thishost:$devno)\n" if $verbosity;
+		$up_disk_H->execute(1, $disk_id);
+		$mounted = 1;
+		$changed = 1;
+	    }
+	} else {
+	    if ($mounted) {
+		print "Noting UNmounted state for $comment ($thishost:$devno)\n" if $verbosity;
+		$up_disk_H->execute(0, $disk_id);
+	    }
+	    # This avoids "No change" notice for an unmounted disk.
+	    next;
+	}
+	print "No change for $comment ($thishost:$devno)\n" if $verbosity && !$changed;
+    }
+    $disk_id{$devno} = $disk_id if $mounted;
+}
+$sel_disk_H->finish;
+
+if ($update_mounts) {
+    while (my($devno, $comment) = each %mounts) {
+	next if $disk_id{$devno};
+	print "Adding $comment ($thishost:$devno)\n" if $verbosity;
+	$ins_disk_H->execute($devno, $thishost, 1, $comment);
+	$disk_id{$devno} = $dbh->last_insert_id(undef, undef, 'disk', 'disk_id');
+    }
+    exit;
+}
+
+my %all_inodes;
+if ($clean_opt) {
+    my $on_list = join ',', map { $disk_id{$_} } keys %disk_id;
+    if ($on_list ne '') {
+	my $sel_inodes_H = $dbh->prepare("
+	    SELECT disk_id, ino, sum_type
+	    FROM inode_map
+	    WHERE disk_id IN ($on_list)
+	    ") or die $dbh->errstr;
+	$sel_inodes_H->execute();
+	while (my($id, $ino, $type) = $sel_inodes_H->fetchrow_array) {
+	    $all_inodes{"$id,$ino,$type"} = 1;
+	}
+    }
+}
+
+my $start_dir = cwd();
+
+my @dirs = @ARGV;
+@dirs = '.' unless @dirs;
+foreach (@dirs) {
+    $_ = abs_path($_);
+}
+
+$| = 1;
+
+my $exit_code = 0;
+
+my $md4 = Digest::MD4->new;
+my $md5 = Digest::MD5->new;
+
+while (@dirs) {
+    my $dir = shift @dirs;
+
+    if (!chdir($dir)) {
+	warn "Unable to chdir to $dir: $!\n";
+	next;
+    }
+    if (!opendir(DP, '.')) {
+	warn "Unable to opendir $dir: $!\n";
+	next;
+    }
+
+    my $reldir = $dir;
+    $reldir =~ s#^$start_dir(/|$)# $1 ? '' : '.' #eo;
+    print "... $reldir/ ...\n" if $output =~ /d/;
+
+    my @subdirs;
+    my @files = sort grep !/^\.\.?$/, readdir DP;
+    closedir DP;
+    foreach my $fn (@files) {
+	next if -l $fn;
+	if (-d _) {
+	    push @subdirs, "$dir/$fn" unless $fn =~ /^(CVS|\.svn|\.git|\.bzr)$/;
+	    next;
+	}
+	next unless -f _;
+
+	my($dev,$ino,$size,$mtime,$ctime) = (stat(_))[0,1,7,9,10];
+	my $disk_id = $disk_id{$dev} or next;
+	if ($clean_opt) {
+	    delete $all_inodes{"$disk_id,$ino,4"};
+	    delete $all_inodes{"$disk_id,$ino,5"};
+	    next if $only_clean_opt;
+	}
+	$sel_sum_H->execute($disk_id,$ino) or die $!;
+	my($sum4, $dbsum4, $sum5, $dbsum5);
+	my $right_sum_cnt = 0;
+	my $wrong_sum_cnt = 0;
+	while (my($sum_type,$sum,$dbsize,$dbmtime,$dbctime) = $sel_sum_H->fetchrow_array) {
+	    if ($sum_type == 4) {
+		$dbsum4 = $sum;
+		next unless $do_md4;
+	    } elsif ($sum_type == 5) {
+		$dbsum5 = $sum;
+		next unless $do_md5;
+	    }
+	    if ($size == $dbsize && $mtime == $dbmtime && ($config{no_ctime} || $ctime == $dbctime)) {
+		$right_sum_cnt++;
+	    } else {
+		$wrong_sum_cnt++;
+	    }
+	}
+	$sel_sum_H->finish;
+
+	if (!$check_opt && $right_sum_cnt == $need_sum_cnt) {
+	    mention_file($reldir, $fn, $right_sum_cnt, $wrong_sum_cnt, $dbsum4, $dbsum5, $dbsum4, $dbsum5);
+	    next;
+	}
+
+	if (!$check_opt || $right_sum_cnt || $output =~ /s/) {
+	    if (!open IN, $fn) {
+		print STDERR "ERROR: unable to read $fn: $!\n";
+		next;
+	    }
+
+	    while (1) {
+		while (sysread(IN, $_, 64*1024)) {
+		    $md4->add($_) if $do_md4;
+		    $md5->add($_) if $do_md5;
+		}
+		$sum4 = $md4->digest if $do_md4;
+		$sum5 = $md5->digest if $do_md5;
+		my($ino2,$size2,$mtime2,$ctime2) = (stat(IN))[1,7,9,10];
+		last if $ino == $ino2 && $size == $size2 && $mtime == $mtime2 && ($config{no_ctime} || $ctime == $ctime2);
+		$ino = $ino2;
+		$size = $size2;
+		$mtime = $mtime2;
+		$ctime = $ctime2;
+		sysseek(IN, 0, 0);
+	    }
+
+	    close IN;
+	}
+
+	my $chg = mention_file($reldir, $fn, $right_sum_cnt, $wrong_sum_cnt, $dbsum4, $dbsum5, $sum4, $sum5);
+	if (!$chg) {
+	    # Only $check_opt should get here...
+	} elsif ($check_opt) {
+	    $exit_code = 1;
+	} else {
+	    if ($do_md4) {
+		$rep_sum_H->execute($disk_id, $ino, $size, $mtime, $ctime, 4, $sum4);
+	    }
+	    if ($do_md5) {
+		$rep_sum_H->execute($disk_id, $ino, $size, $mtime, $ctime, 5, $sum5);
+	    }
+	}
+    }
+
+    unshift @dirs, sort @subdirs if $recurse_opt;
+}
+
+if ($clean_opt) {
+    my $cnt = 0;
+    $dbh->begin_work;
+    while (my ($info, $val) = each %all_inodes) {
+	my ($id, $ino, $type) = split /,/, $info;
+	print "Deleting $info\n" if $verbosity >= 2;
+	$del_sum_H->execute($id, $ino, $type);
+	$cnt++;
+    }
+    $dbh->commit;
+    my $s = $cnt == 1 ? '' : 's';
+    print "Cleaned out $cnt old inode$s.\n" if $verbosity;
+}
+
+exit $exit_code;
+
+# Returns 1 if there is a checksum change, else undef.
+sub mention_file
+{
+    my ($dir, $name, $right_cnt, $wrong_cnt, $dbsum4, $dbsum5, $sum4, $sum5) = @_;
+
+    my @diffs = $wrong_cnt && !$right_cnt ? '!i' : '  ';
+    if ($do_md4) {
+	push @diffs, !defined $dbsum4 ? '+4' : !defined $sum4 ? '?4' : $sum4 ne $dbsum4 ? '!4' : '  ';
+    }
+    if ($do_md5) {
+	push @diffs, !defined $dbsum5 ? '+5' : !defined $sum5 ? '?5' : $sum5 ne $dbsum5 ? '!5' : '  ';
+    }
+
+    my $chg = grep /\S/, @diffs;
+    if ($chg || $output =~ /u/) {
+	my $line = '';
+	if ($output =~ /i/) {
+	    $line .= "@diffs ";
+	}
+	if ($output =~ /s/) {
+	    $line .= unpack('H*', $sum4) . ' ' if $do_md4;
+	    $line .= unpack('H*', $sum5) . ' ' if $do_md5;
+	}
+	if ($output =~ /n/) {
+	    $line .= ' ' if $line ne ''; # We want 2 spaces, like md5sum.
+	    $line .= $dir . '/' unless $dir eq '.';
+	    print $line, $name, "\n";
+	}
+    }
+
+    return $chg;
+}
+
+sub usage
+{
+    die <<EOT;
+Usage: rsyncdb --db=CONFIG_FILE [OPTIONS] [DIRS]
+
+Options:
+--db=FILE          Specify the config FILE to read for the DB info.
+--init             Create (recreate) needed tables (making them empty).
+                   No DIR scanning, but can be combined with --mounts.
+--mounts (-m)      Update mount info.  Does no DIR scanning.
+--recurse (-r)     Scan files in subdirectories too.
+--sums=SUMS (-s)   List which checksums to update (default: 4,5).  Note that
+                   this doesn't affect the order of sum output via "-o s".
+--verbosity (-v)   Output change info for --init, --mounts, and --*clean.
+                   Also makes checksumming output default be "-o dn".
+--output=STR (-o)  One or more letters of what to output (default is nothing).
+                   d = output "... dir_name ..." lines from our scan.
+                   n = output names of items with changes.
+                   s = output checksum info for changes (implies n).
+                   u = output even unchanged items (implies n).
+                   i = output prefixed change info: !i if time and/or size is
+                       wrong, +4/+5 if the MD4/5 sum is missing, !4/!5 if sum
+                       is wrong, ?4/?5 if we didn't need to read the file (i.e.
+                       if time/size is wrong and no sum output was requested).
+--check (-c)       Check if the checksums are right (doesn't update).
+                   Implies --verbose and enables output of "i".
+--clean            Read all inodes from the DB and remove the ones that aren't
+                   found in the DIR(s) while also updating the DB's info.  You
+                   need to specify all mounted DIRs in the DB & also --recurse.
+--only-clean       Like --clean, but avoids adding missing info.
+--help (-h)        Display this help message.
+
+Examples:
+
+rsyncdb --db=/etc/db.conf -r -o n /src
+rsyncdb --db=/etc/db.conf -r --check /src
+rsyncdb --db=/etc/db.conf -s5 -rous /src >/tmp/really-fast-md5sum.txt
+EOT
+}
