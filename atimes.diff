To use this patch, run these commands for a successful build:

    patch -p1 <patches/atimes.diff
    ./prepare-source
    ./configure                      (optional if already run)
    make


--- old/compat.c
+++ new/compat.c
@@ -64,6 +64,8 @@ void setup_protocol(int f_out,int f_in)
 		preserve_uid = ++file_extra_cnt;
 	if (preserve_gid)
 		preserve_gid = ++file_extra_cnt;
+	if (preserve_atimes)
+		preserve_atimes = ++file_extra_cnt;
 	if (preserve_acls && !am_sender)
 		preserve_acls = ++file_extra_cnt;
 	if (preserve_xattrs)
--- old/flist.c
+++ new/flist.c
@@ -50,6 +50,7 @@ extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_uid;
 extern int preserve_gid;
+extern int preserve_atimes;
 extern int relative_paths;
 extern int implied_dirs;
 extern int file_extra_cnt;
@@ -147,6 +148,7 @@ void show_flist_stats(void)
 static void list_file_entry(struct file_struct *f)
 {
 	char permbuf[PERMSTRING_SIZE];
+	time_t atime = preserve_atimes ? F_ATIME(f) : 0;
 	double len;
 
 	if (!F_IS_ACTIVE(f)) {
@@ -161,14 +163,16 @@ static void list_file_entry(struct file_
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
-		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
+		rprintf(FINFO, "%s %11.0f %s %s %s -> %s\n",
 			permbuf, len, timestring(f->modtime),
+			preserve_atimes ? timestring(atime) : "",
 			f_name(f, NULL), F_SYMLINK(f));
 	} else
 #endif
 	{
-		rprintf(FINFO, "%s %11.0f %s %s\n",
+		rprintf(FINFO, "%s %11.0f %s %s %s\n",
 			permbuf, len, timestring(f->modtime),
+			preserve_atimes ? timestring(atime) : "",
 			f_name(f, NULL));
 	}
 }
@@ -352,6 +356,7 @@ int push_flist_dir(const char *dir, int 
 static void send_file_entry(int f, struct file_struct *file, int ndx)
 {
 	static time_t modtime;
+	static time_t atime;
 	static mode_t mode;
 	static int64 dev;
 	static dev_t rdev;
@@ -419,6 +424,13 @@ static void send_file_entry(int f, struc
 		flags |= XMIT_SAME_TIME;
 	else
 		modtime = file->modtime;
+	if (preserve_atimes && !S_ISDIR(mode)) {
+		time_t file_atime = F_ATIME(file);
+		if (file_atime == atime)
+			flags |= XMIT_SAME_ATIME;
+		else
+			atime = file_atime;
+	}
 
 #ifdef SUPPORT_HARD_LINKS
 	if (tmp_dev != 0) {
@@ -486,6 +498,8 @@ static void send_file_entry(int f, struc
 		write_int(f, modtime);
 	if (!(flags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
+	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
+		write_int(f, atime);
 	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
 		if (protocol_version < 30)
 			write_int(f, uid);
@@ -572,7 +586,7 @@ static void send_file_entry(int f, struc
 static struct file_struct *recv_file_entry(struct file_list *flist,
 					   int flags, int f)
 {
-	static time_t modtime;
+	static time_t modtime, atime;
 	static mode_t mode;
 	static int64 dev;
 	static dev_t rdev;
@@ -670,6 +684,8 @@ static struct file_struct *recv_file_ent
 		modtime = (time_t)read_int(f);
 	if (!(flags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
+	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
+		atime = (time_t)read_int(f);
 
 	if (chmod_modes && !S_ISLNK(mode))
 		mode = tweak_mode(mode, chmod_modes);
@@ -794,6 +810,8 @@ static struct file_struct *recv_file_ent
 		F_OWNER(file) = uid;
 	if (preserve_gid)
 		F_GROUP(file) = gid;
+	if (preserve_atimes)
+		F_ATIME(file) = atime;
 
 	if (basename != thisname) {
 		file->dirname = lastdir;
@@ -1103,6 +1121,8 @@ struct file_struct *make_file(const char
 		F_OWNER(file) = st.st_uid;
 	if (preserve_gid)
 		F_GROUP(file) = st.st_gid;
+	if (preserve_atimes)
+		F_ATIME(file) = st.st_atime;
 
 	if (basename != thisname)
 		file->dirname = lastdir;
--- old/generator.c
+++ new/generator.c
@@ -45,6 +45,7 @@ extern int preserve_perms;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
+extern int preserve_atimes;
 extern int omit_dir_times;
 extern int delete_mode;
 extern int delete_before;
@@ -561,6 +562,9 @@ void itemize(const char *fnamecmp, struc
 		  && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
 		 || (keep_time && cmp_time(file->modtime, sxp->st.st_mtime) != 0))
 			iflags |= ITEM_REPORT_TIME;
+		if (preserve_atimes && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)
+		 && cmp_time(F_ATIME(file), sxp->st.st_atime) != 0)
+			iflags |= ITEM_REPORT_ATIME;
 		if (!BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
 			iflags |= ITEM_REPORT_PERMS;
 		if (preserve_uid && am_root && F_UID(file) != sxp->st.st_uid)
@@ -878,6 +882,8 @@ static int try_dests_reg(struct file_str
 		if (link_dest) {
 			if (!hard_link_one(file, fname, cmpbuf, 1))
 				goto try_a_copy;
+			if (preserve_atimes)
+				set_file_attrs(fname, file, sxp, 0);
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, &sxp->st, itemizing, code, j);
 			if (itemizing && (verbose > 1 || stdout_format_has_i > 1)) {
@@ -1741,7 +1747,7 @@ static void touch_up_dirs(struct file_li
 		if (!(file->mode & S_IWUSR))
 			do_chmod(fname, file->mode);
 		if (need_retouch_dir_times)
-			set_modtime(fname, file->modtime, file->mode);
+			set_times(fname, file->modtime, file->modtime, file->mode);
 		if (allowed_lull && !(++j % lull_mod))
 			maybe_send_keepalive();
 		else if (!(j % 200))
--- old/log.c
+++ new/log.c
@@ -36,6 +36,7 @@ extern int msg_fd_out;
 extern int allow_8bit_chars;
 extern int protocol_version;
 extern int preserve_times;
+extern int preserve_atimes;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int stdout_format_has_i;
@@ -624,7 +625,8 @@ static void log_formatted(enum logcode c
 			c[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
 			c[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
 			c[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
-			c[8] = !(iflags & ITEM_REPORT_ATIME) ? '.' : 'u';
+			c[8] = !(iflags & ITEM_REPORT_ATIME) ? '.'
+			     : S_ISLNK(file->mode) ? 'U' : 'u';
 			c[9] = !(iflags & ITEM_REPORT_ACL) ? '.' : 'a';
 			c[10] = !(iflags & ITEM_REPORT_XATTR) ? '.' : 'x';
 			c[11] = '\0';
--- old/options.c
+++ new/options.c
@@ -56,6 +56,7 @@ int preserve_uid = 0;
 int preserve_gid = 0;
 int preserve_times = 0;
 int omit_dir_times = 0;
+int preserve_atimes = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
@@ -323,8 +324,9 @@ void usage(enum logcode F)
   rprintf(F,"     --devices               preserve device files (super-user only)\n");
   rprintf(F,"     --specials              preserve special files\n");
   rprintf(F," -D                          same as --devices --specials\n");
-  rprintf(F," -t, --times                 preserve times\n");
-  rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
+  rprintf(F," -t, --times                 preserve modify times\n");
+  rprintf(F," -O, --omit-dir-times        omit directories when preserving modify times\n");
+  rprintf(F," -U, --atimes                preserve access (use) times\n");
   rprintf(F,"     --super                 receiver attempts super-user activities\n");
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
@@ -451,6 +453,9 @@ static struct poptOption long_options[] 
   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+  {"atimes",          'U', POPT_ARG_VAL,    &preserve_atimes, 1, 0, 0 },
+  {"no-atimes",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
+  {"no-U",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
   {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
@@ -1603,6 +1608,8 @@ void server_options(char **args,int *arg
 		argstr[x++] = 'D';
 	if (preserve_times)
 		argstr[x++] = 't';
+	if (preserve_atimes)
+		argstr[x++] = 'U';
 	if (preserve_perms)
 		argstr[x++] = 'p';
 	else if (preserve_executability && am_sender)
--- old/rsync.c
+++ new/rsync.c
@@ -35,6 +35,7 @@ extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_perms;
 extern int preserve_executability;
+extern int preserve_atimes;
 extern int preserve_times;
 extern int omit_dir_times;
 extern int am_root;
@@ -228,6 +229,7 @@ int set_file_attrs(const char *fname, st
 	int updated = 0;
 	statx sx2;
 	int change_uid, change_gid;
+	time_t atime, mtime;
 	mode_t new_mode = file->mode;
 
 	if (!sxp) {
@@ -263,18 +265,36 @@ int set_file_attrs(const char *fname, st
 		set_xattr(fname, file, fnamecmp, sxp);
 #endif
 
+	/* This code must be the first update in the function due to
+	 * how it uses the "updated" variable. */
 	if (!preserve_times || (S_ISDIR(sxp->st.st_mode) && omit_dir_times))
 		flags |= ATTRS_SKIP_MTIME;
+	if (!preserve_atimes || S_ISDIR(sxp->st.st_mode))
+		flags |= ATTRS_SKIP_ATIME;
 	if (!(flags & ATTRS_SKIP_MTIME)
 	    && cmp_time(sxp->st.st_mtime, file->modtime) != 0) {
-		int ret = set_modtime(fname, file->modtime, sxp->st.st_mode);
+		mtime = file->modtime;
+		updated = 1;
+	} else
+		mtime = sxp->st.st_mtime;
+	if (!(flags & ATTRS_SKIP_ATIME)) {
+		time_t file_atime = F_ATIME(file);
+		if (cmp_time(sxp->st.st_atime, file_atime) != 0) {
+			atime = file_atime;
+			updated = 1;
+		} else
+			atime = sxp->st.st_atime;
+	} else
+		atime = sxp->st.st_atime;
+	if (updated) {
+		int ret = set_times(fname, mtime, atime, sxp->st.st_mode);
 		if (ret < 0) {
 			rsyserr(FERROR, errno, "failed to set times on %s",
 				full_fname(fname));
 			goto cleanup;
 		}
-		if (ret == 0) /* ret == 1 if symlink could not be set */
-			updated = 1;
+		if (ret > 0) /* ret == 1 if symlink could not be set */
+			updated = 0;
 	}
 
 	change_uid = am_root && preserve_uid && sxp->st.st_uid != F_UID(file);
--- old/rsync.h
+++ new/rsync.h
@@ -56,6 +56,7 @@
 #define XMIT_RDEV_MINOR_8_pre30 (1<<11)	/* protocols 28 - 29  */
 #define XMIT_GROUP_NAME_FOLLOWS (1<<11) /* protocols 30 - NOW */
 #define XMIT_HLINK_FIRST (1<<12)	/* protocols 30 - NOW */
+#define XMIT_SAME_ATIME (1<<13)		/* protocols ?? - NOW */
 
 /* These flags are used in the live flist data. */
 
@@ -136,6 +137,7 @@
 
 #define ATTRS_REPORT		(1<<0)
 #define ATTRS_SKIP_MTIME	(1<<1)
+#define ATTRS_SKIP_ATIME	(1<<2)
 
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
@@ -568,6 +570,7 @@ struct file_struct {
 extern int file_extra_cnt;
 extern int preserve_uid;
 extern int preserve_gid;
+extern int preserve_atimes;
 extern int preserve_acls;
 extern int preserve_xattrs;
 
@@ -602,6 +605,7 @@ extern int preserve_xattrs;
 /* When the associated option is on, all entries will have these present: */
 #define F_OWNER(f) REQ_EXTRA(f, preserve_uid)->unum
 #define F_GROUP(f) REQ_EXTRA(f, preserve_gid)->unum
+#define F_ATIME(f) REQ_EXTRA(f, preserve_atimes)->unum
 #define F_ACL(f) REQ_EXTRA(f, preserve_acls)->num
 #define F_XATTR(f) REQ_EXTRA(f, preserve_xattrs)->num
 
--- old/rsync.yo
+++ new/rsync.yo
@@ -330,8 +330,9 @@ to the detailed description below for a 
      --devices               preserve device files (super-user only)
      --specials              preserve special files
  -D                          same as --devices --specials
- -t, --times                 preserve times
- -O, --omit-dir-times        omit directories when preserving times
+ -t, --times                 preserve modify times
+ -O, --omit-dir-times        omit directories when preserving mod-times
+ -U, --atimes                preserve access (use) times
      --super                 receiver attempts super-user activities
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
@@ -902,6 +903,12 @@ it is preserving modification times (see
 the directories on the receiving side, it is a good idea to use bf(-O).
 This option is inferred if you use bf(--backup) without bf(--backup-dir).
 
+dit(bf(-U, --atimes)) This tells rsync to set the access (use) times of the
+destination files to the same value as the source files.  Note that the
+reading of the source file may update the atime of the source files, so
+repeated rsync runs with --atimes may be needed if you want to force the
+access-time values to be 100% identical on the two systems.
+
 dit(bf(--super)) This tells the receiving side to attempt super-user
 activities even if the receiving rsync wasn't run by the super-user.  These
 activities include: preserving users via the bf(--owner) option, preserving
@@ -1488,7 +1495,7 @@ quote(itemization(
   by the file transfer.
   it() A bf(t) means the modification time is different and is being updated
   to the sender's value (requires bf(--times)).  An alternate value of bf(T)
-  means that the time will be set to the transfer time, which happens
+  means that the modify time will be set to the transfer time, which happens
   anytime a symlink is transferred, or when a file or device is transferred
   without bf(--times).
   it() A bf(p) means the permissions are different and are being updated to
@@ -1497,8 +1504,10 @@ quote(itemization(
   sender's value (requires bf(--owner) and super-user privileges).
   it() A bf(g) means the group is different and is being updated to the
   sender's value (requires bf(--group) and the authority to set the group).
-  it() The bf(u) slot is reserved for reporting update (access) time changes
-  (a feature that is not yet released).
+  it() A bf(u) means the access (use) time is different and is being updated to
+  the sender's value (requires bf(--atimes)).  An alternate value of bf(U)
+  means that the access time will be set to the transfer time, which happens
+  when a symlink or directory is updated.
   it() The bf(a) means that the ACL information changed.
   it() The bf(x) slot is reserved for reporting extended attribute changes
   (a feature that is not yet released).
--- old/sender.c
+++ new/sender.c
@@ -43,6 +43,7 @@ extern int do_progress;
 extern int inplace;
 extern int batch_fd;
 extern int write_batch;
+extern unsigned int file_struct_len;
 extern struct stats stats;
 extern struct file_list *cur_flist, *first_flist;
 
--- old/testsuite/atimes.test
+++ new/testsuite/atimes.test
@@ -0,0 +1,19 @@
+#! /bin/sh
+
+# Test rsync copying atimes
+
+. "$suitedir/rsync.fns"
+
+set -x
+
+mkdir "$fromdir"
+
+touch "$fromdir/foo"
+touch -a -t 200102031717.42 "$fromdir/foo"
+
+TLS_ARGS=--atime
+
+checkit "$RSYNC -rtUgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+
+# The script would have aborted on error, so getting here means we've won.
+exit 0
--- old/testsuite/rsync.fns
+++ new/testsuite/rsync.fns
@@ -66,7 +66,7 @@ printmsg() {
 }
 
 rsync_ls_lR() {
-    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls"
+    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls" $TLS_ARGS
 }
 
 check_perms() {
@@ -184,6 +184,10 @@ checkit() {
     # We can just write everything to stdout/stderr, because the
     # wrapper hides it unless there is a problem.
 
+    if test x$TLS_ARGS = x--atime; then
+	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+    fi
+
     echo "Running: \"$1\""  
     eval "$1" 
     status=$?
@@ -191,10 +195,13 @@ checkit() {
 	failed="YES";
     fi
 
+    if test x$TLS_ARGS != x--atime; then
+	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+    fi
+
     echo "-------------"
     echo "check how the directory listings compare with diff:"
     echo ""
-    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
     ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
     diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
 
--- old/tls.c
+++ new/tls.c
@@ -34,6 +34,7 @@
  * change. */
 
 #include "rsync.h"
+#include "popt.h"
 
 #define PROGRAM "tls"
 
@@ -43,6 +44,8 @@ int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
 
+static int display_atime = 0;
+ 
 static void failed(char const *what, char const *where)
 {
 	fprintf(stderr, PROGRAM ": %s %s: %s\n",
@@ -50,12 +53,29 @@ static void failed(char const *what, cha
 	exit(1);
 }
 
+static void storetime(char *dest, time_t t, size_t destsize)
+{
+	if (t) {
+		struct tm *mt = gmtime(&t);
+
+		snprintf(dest, destsize,
+			"%04d-%02d-%02d %02d:%02d:%02d ",
+			(int)mt->tm_year + 1900,
+			(int)mt->tm_mon + 1,
+			(int)mt->tm_mday,
+			(int)mt->tm_hour,
+			(int)mt->tm_min,
+			(int)mt->tm_sec);
+	} else
+		strlcpy(dest, "                    ", destsize);
+}
+
 static void list_file(const char *fname)
 {
 	STRUCT_STAT buf;
 	char permbuf[PERMSTRING_SIZE];
-	struct tm *mt;
-	char datebuf[50];
+	char mtimebuf[50];
+	char atimebuf[50];
 	char linkbuf[4096];
 
 	if (do_lstat(fname, &buf) < 0)
@@ -88,19 +108,8 @@ static void list_file(const char *fname)
 
 	permstring(permbuf, buf.st_mode);
 
-	if (buf.st_mtime) {
-		mt = gmtime(&buf.st_mtime);
-
-		snprintf(datebuf, sizeof datebuf,
-			"%04d-%02d-%02d %02d:%02d:%02d",
-			(int)mt->tm_year + 1900,
-			(int)mt->tm_mon + 1,
-			(int)mt->tm_mday,
-			(int)mt->tm_hour,
-			(int)mt->tm_min,
-			(int)mt->tm_sec);
-	} else
-		strlcpy(datebuf, "                   ", sizeof datebuf);
+	storetime(mtimebuf, buf.st_mtime, sizeof mtimebuf);
+	storetime(atimebuf, buf.st_atime, sizeof atimebuf);
 
 	/* TODO: Perhaps escape special characters in fname? */
 
@@ -111,23 +120,55 @@ static void list_file(const char *fname)
 		    (long)minor(buf.st_rdev));
 	} else /* NB: use double for size since it might not fit in a long. */
 		printf("%12.0f", (double)buf.st_size);
-	printf(" %6ld.%-6ld %6ld %s %s%s\n",
+	printf(" %6ld.%-6ld %6ld %s%s%s%s\n",
 	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
-	       datebuf, fname, linkbuf);
+ 	       mtimebuf, display_atime && !S_ISDIR(buf.st_mode) ? atimebuf : "",
+	       fname, linkbuf);
+}
+
+static struct poptOption long_options[] = {
+  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
+  {"atime",           'u', POPT_ARG_NONE,   &display_atime, 0,   0, 0},
+  {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0},
+  {0,0,0,0,0,0,0}
+};
+
+static void tls_usage(int ret)
+{
+	fprintf(stderr, "usage: " PROGRAM " [--atime | -u] FILE ...\n"
+	    "Trivial file listing program for portably checking rsync\n");
+	exit(ret);
 }
 
 int
 main(int argc, char *argv[])
 {
-	if (argc < 2) {
-		fprintf(stderr, "usage: " PROGRAM " FILE ...\n"
-			"Trivial file listing program for portably checking rsync\n");
-		return 1;
-	}
+	poptContext pc;
+	const char **extra_args;
+	int opt;
 
-	for (argv++; *argv; argv++) {
-		list_file(*argv);
+	pc = poptGetContext(PROGRAM, argc, (const char **)argv,
+			    long_options, 0);
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		switch (opt) {
+		case 'h':
+			tls_usage(0);
+		default:
+			fprintf(stderr,
+			        "%s: %s\n",
+				poptBadOption(pc, POPT_BADOPTION_NOALIAS),
+				poptStrerror(opt));
+			tls_usage(1);
+		}
 	}
 
+	extra_args = poptGetArgs(pc);
+	if (*extra_args == NULL)
+		tls_usage(1);
+
+	for (; *extra_args; extra_args++)
+		list_file(*extra_args);
+	poptFreeContext(pc);
+
 	return 0;
 }
--- old/util.c
+++ new/util.c
@@ -120,7 +120,7 @@ NORETURN void overflow_exit(const char *
 	exit_cleanup(RERR_MALLOC);
 }
 
-int set_modtime(const char *fname, time_t modtime, mode_t mode)
+int set_times(const char *fname, time_t modtime, time_t atime, mode_t mode)
 {
 #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
 	if (S_ISLNK(mode))
@@ -128,9 +128,13 @@ int set_modtime(const char *fname, time_
 #endif
 
 	if (verbose > 2) {
-		rprintf(FINFO, "set modtime of %s to (%ld) %s",
+		char mtimebuf[200];
+
+		strlcpy(mtimebuf, timestring(modtime), sizeof mtimebuf);
+		rprintf(FINFO,
+			"set modtime, atime of %s to (%ld) %s, (%ld) %s\n",
 			fname, (long)modtime,
-			asctime(localtime(&modtime)));
+			mtimebuf, (long)atime, timestring(atime));
 	}
 
 	if (dry_run)
@@ -139,7 +143,7 @@ int set_modtime(const char *fname, time_
 	{
 #ifdef HAVE_UTIMES
 		struct timeval t[2];
-		t[0].tv_sec = time(NULL);
+		t[0].tv_sec = atime;
 		t[0].tv_usec = 0;
 		t[1].tv_sec = modtime;
 		t[1].tv_usec = 0;
@@ -152,12 +156,12 @@ int set_modtime(const char *fname, time_
 		return utimes(fname, t);
 #elif defined HAVE_UTIMBUF
 		struct utimbuf tbuf;
-		tbuf.actime = time(NULL);
+		tbuf.actime = atime;
 		tbuf.modtime = modtime;
 		return utime(fname,&tbuf);
 #elif defined HAVE_UTIME
 		time_t t[2];
-		t[0] = time(NULL);
+		t[0] = atime;
 		t[1] = modtime;
 		return utime(fname,t);
 #else
