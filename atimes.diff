After applying this patch, run these commands for a successful build:

    ./prepare-source
    ./configure                      (optional if already run)
    make


--- orig/flist.c	2006-01-31 02:30:18
+++ flist.c	2006-01-27 00:33:39
@@ -51,6 +51,7 @@ extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_uid;
 extern int preserve_gid;
+extern int preserve_atimes;
 extern int relative_paths;
 extern int implied_dirs;
 extern int prune_empty_dirs;
@@ -85,7 +86,13 @@ void init_flist(void)
 	struct file_struct f;
 
 	/* Figure out how big the file_struct is without trailing padding */
-	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
+	if (preserve_atimes)
+		file_struct_len = offsetof(struct file_struct, fl4g5);
+	else
+		file_struct_len = offsetof(struct file_struct, atime);
+	/* The "flags" uchar is no longer accessed directly, so I
+	 * mangled the name to fl4g5 as a reminder. */
+	file_struct_len += sizeof f.fl4g5;
 	checksum_len = protocol_version < 21 ? 2 : MD4_SUM_LENGTH;
 }
 
@@ -141,16 +148,18 @@ static void list_file_entry(struct file_
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
-		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
+		rprintf(FINFO, "%s %11.0f %s %s %s -> %s\n",
 			permbuf,
 			(double)f->length, timestring(f->modtime),
+			preserve_atimes ? timestring(f->atime) : "",
 			f_name(f, NULL), f->u.link);
 	} else
 #endif
 	{
-		rprintf(FINFO, "%s %11.0f %s %s\n",
+		rprintf(FINFO, "%s %11.0f %s %s %s\n",
 			permbuf,
 			(double)f->length, timestring(f->modtime),
+			preserve_atimes ? timestring(f->atime) : "",
 			f_name(f, NULL));
 	}
 }
@@ -312,6 +321,7 @@ static void send_file_entry(struct file_
 {
 	unsigned short flags;
 	static time_t modtime;
+	static time_t atime;
 	static mode_t mode;
 	static int64 dev;
 	static dev_t rdev;
@@ -327,7 +337,7 @@ static void send_file_entry(struct file_
 
 	if (!file) {
 		write_byte(f, 0);
-		modtime = 0, mode = 0;
+		modtime = 0, atime = 0, mode = 0;
 		dev = 0, rdev = makedev(0, 0);
 		rdev_major = 0;
 		uid = 0, gid = 0;
@@ -339,7 +349,7 @@ static void send_file_entry(struct file_
 
 	f_name(file, fname);
 
-	flags = file->flags & XMIT_TOP_DIR;
+	flags = FFLAGS(file) & XMIT_TOP_DIR;
 
 	if (file->mode == mode)
 		flags |= XMIT_SAME_MODE;
@@ -375,6 +385,12 @@ static void send_file_entry(struct file_
 		flags |= XMIT_SAME_TIME;
 	else
 		modtime = file->modtime;
+	if (preserve_atimes && !S_ISDIR(mode)) {
+		if (file->atime == atime)
+			flags |= XMIT_SAME_ATIME;
+		else
+			atime = file->atime;
+	}
 
 #ifdef SUPPORT_HARD_LINKS
 	if (file->link_u.idev) {
@@ -428,6 +444,8 @@ static void send_file_entry(struct file_
 		write_int(f, modtime);
 	if (!(flags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
+	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
+		write_int(f, atime);
 	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
 		if (!numeric_ids)
 			add_uid(uid);
@@ -496,6 +514,7 @@ static struct file_struct *receive_file_
 					      unsigned short flags, int f)
 {
 	static time_t modtime;
+	static time_t atime;
 	static mode_t mode;
 	static int64 dev;
 	static dev_t rdev;
@@ -514,7 +533,7 @@ static struct file_struct *receive_file_
 	struct file_struct *file;
 
 	if (!flist) {
-		modtime = 0, mode = 0;
+		modtime = 0, atime = 0, mode = 0;
 		dev = 0, rdev = makedev(0, 0);
 		rdev_major = 0;
 		uid = 0, gid = 0;
@@ -570,6 +589,8 @@ static struct file_struct *receive_file_
 		modtime = (time_t)read_int(f);
 	if (!(flags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
+	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
+		atime = (time_t)read_int(f);
 
 	if (chmod_modes && !S_ISLNK(mode))
 		mode = tweak_mode(mode, chmod_modes);
@@ -625,6 +646,8 @@ static struct file_struct *receive_file_
 	file->mode = mode;
 	file->uid = uid;
 	file->gid = gid;
+	if (preserve_atimes)
+		file->atime = atime;
 
 	if (dirname_len) {
 		file->dirname = lastdir = bp;
@@ -650,12 +673,12 @@ static struct file_struct *receive_file_
 			    && lastname[del_hier_name_len-1] == '.'
 			    && lastname[del_hier_name_len-2] == '/')
 				del_hier_name_len -= 2;
-			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
+			FFLAGS(file) |= FLAG_TOP_DIR | FLAG_DEL_HERE;
 		} else if (in_del_hier) {
 			if (!relative_paths || !del_hier_name_len
 			 || (l1 >= del_hier_name_len
 			  && lastname[del_hier_name_len] == '/'))
-				file->flags |= FLAG_DEL_HERE;
+				FFLAGS(file) |= FLAG_DEL_HERE;
 			else
 				in_del_hier = 0;
 		}
@@ -871,12 +894,14 @@ struct file_struct *make_file(char *fnam
 	memset(bp, 0, file_struct_len);
 	bp += file_struct_len;
 
-	file->flags = flags;
+	FFLAGS(file) = flags;
 	file->modtime = st.st_mtime;
 	file->length = st.st_size;
 	file->mode = st.st_mode;
 	file->uid = st.st_uid;
 	file->gid = st.st_gid;
+	if (preserve_atimes)
+		file->atime = st.st_atime;
 
 #ifdef SUPPORT_HARD_LINKS
 	if (flist && flist->hlink_pool) {
@@ -989,7 +1014,7 @@ static void send_if_directory(int f, str
 	char is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');
 
 	if (S_ISDIR(file->mode)
-	    && !(file->flags & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
+	    && !(FFLAGS(file) & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
 		void *save_filters;
 		unsigned int len = strlen(fbuf);
 		if (len > 1 && fbuf[len-1] == '/')
@@ -1595,8 +1620,9 @@ static void clean_flist(struct file_list
 			}
 			/* Make sure we don't lose track of a user-specified
 			 * top directory. */
-			flist->files[keep]->flags |= flist->files[drop]->flags
-						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
+			FFLAGS(flist->files[keep])
+			    |= FFLAGS(flist->files[drop])
+			     & (FLAG_TOP_DIR|FLAG_DEL_HERE);
 
 			clear_file(flist->files[drop], flist);
 
@@ -1720,7 +1746,7 @@ static void output_flist(struct file_lis
 			file->dirname ? file->dirname : "",
 			file->dirname ? "/" : "", NS(file->basename),
 			S_ISDIR(file->mode) ? "/" : "", (int)file->mode,
-			(double)file->length, uidbuf, gidbuf, file->flags);
+			(double)file->length, uidbuf, gidbuf, FFLAGS(file));
 	}
 }
 
--- orig/generator.c	2006-02-05 06:40:40
+++ generator.c	2006-02-01 19:37:52
@@ -44,6 +44,7 @@ extern int preserve_perms;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
+extern int preserve_atimes;
 extern int omit_dir_times;
 extern int delete_mode;
 extern int delete_before;
@@ -91,6 +92,7 @@ extern dev_t filesystem_dev;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
+extern unsigned int file_struct_len;
 extern struct file_list *the_file_list;
 extern struct filter_list_struct server_filter_list;
 
@@ -185,7 +187,7 @@ static int delete_item(char *fname, int 
 	for (j = dirlist->count; j--; ) {
 		struct file_struct *fp = dirlist->files[j];
 
-		if (fp->flags & FLAG_MOUNT_POINT)
+		if (FFLAGS(fp) & FLAG_MOUNT_POINT)
 			continue;
 
 		strlcpy(p, fp->basename, remainder);
@@ -263,7 +265,7 @@ static void delete_in_dir(struct file_li
 	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
 
 	if (one_file_system) {
-		if (file->flags & FLAG_TOP_DIR)
+		if (FFLAGS(file) & FLAG_TOP_DIR)
 			filesystem_dev = stp->st_dev;
 		else if (filesystem_dev != stp->st_dev)
 			return;
@@ -275,7 +277,7 @@ static void delete_in_dir(struct file_li
 	 * from the filesystem. */
 	for (i = dirlist->count; i--; ) {
 		struct file_struct *fp = dirlist->files[i];
-		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
+		if (!fp->basename || FFLAGS(fp) & FLAG_MOUNT_POINT)
 			continue;
 		if (flist_find(flist, fp) < 0) {
 			f_name(fp, delbuf);
@@ -301,11 +303,11 @@ static void do_delete_pass(struct file_l
 	for (j = 0; j < flist->count; j++) {
 		struct file_struct *file = flist->files[j];
 
-		if (!(file->flags & FLAG_DEL_HERE))
+		if (!(FFLAGS(file) & FLAG_DEL_HERE))
 			continue;
 
 		f_name(file, fbuf);
-		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
+		if (verbose > 1 && FFLAGS(file) & FLAG_TOP_DIR)
 			rprintf(FINFO, "deleting in %s\n", fbuf);
 
 		if (link_stat(fbuf, &st, keep_dirlinks) < 0
@@ -347,8 +349,11 @@ void itemize(struct file_struct *file, i
 			iflags |= ITEM_REPORT_SIZE;
 		if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
 		     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
-		    || (keep_time && cmp_modtime(file->modtime, st->st_mtime) != 0))
+		    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
 			iflags |= ITEM_REPORT_TIME;
+		if (preserve_atimes && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)
+		 && cmp_time(file->atime, st->st_atime) != 0)
+			iflags |= ITEM_REPORT_ATIME;
 		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
 			iflags |= ITEM_REPORT_PERMS;
 		if (preserve_uid && am_root && file->uid != st->st_uid)
@@ -396,7 +401,7 @@ int unchanged_file(char *fn, struct file
 	if (ignore_times)
 		return 0;
 
-	return cmp_modtime(st->st_mtime, file->modtime) == 0;
+	return cmp_time(st->st_mtime, file->modtime) == 0;
 }
 
 
@@ -550,13 +555,13 @@ static int find_fuzzy(struct file_struct
 		uint32 dist;
 
 		if (!S_ISREG(fp->mode) || !fp->length
-		    || fp->flags & FLAG_NO_FUZZY)
+		    || FFLAGS(fp) & FLAG_NO_FUZZY)
 			continue;
 
 		name = fp->basename;
 
 		if (fp->length == file->length
-		    && cmp_modtime(fp->modtime, file->modtime) == 0) {
+		    && cmp_time(fp->modtime, file->modtime) == 0) {
 			if (verbose > 4) {
 				rprintf(FINFO,
 					"fuzzy size/modtime match for %s\n",
@@ -632,7 +637,7 @@ static int try_dests_reg(struct file_str
 			if (!unchanged_attrs(file, stp))
 				continue;
 			if ((always_checksum || ignore_times)
-			 && cmp_modtime(stp->st_mtime, file->modtime))
+			 && cmp_time(stp->st_mtime, file->modtime))
 				continue;
 			best_match = j;
 			match_level = 3;
@@ -659,6 +664,8 @@ static int try_dests_reg(struct file_str
 					  itemizing && verbose > 1,
 					  code) < 0)
 				goto try_a_copy;
+			if (preserve_atimes)
+				set_file_attrs(fname, file, stp, 0);
 			if (preserve_hard_links && file->link_u.links)
 				hard_link_cluster(file, ndx, itemizing, code);
 		} else if (itemizing)
@@ -894,7 +901,7 @@ static void recv_generator(char *fname, 
 		    && verbose && code && f_out != -1)
 			rprintf(code, "%s/\n", fname);
 		if (delete_during && f_out != -1 && !phase && dry_run < 2
-		    && (file->flags & FLAG_DEL_HERE))
+		    && (FFLAGS(file) & FLAG_DEL_HERE))
 			delete_in_dir(the_file_list, fname, file, &st);
 		return;
 	}
@@ -1073,7 +1080,7 @@ static void recv_generator(char *fname, 
 	}
 
 	if (update_only && statret == 0
-	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
+	    && cmp_time(st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s is newer\n", fname);
 		return;
@@ -1176,7 +1183,7 @@ static void recv_generator(char *fname, 
 	if (fuzzy_basis) {
 		int j = flist_find(fuzzy_dirlist, file);
 		if (j >= 0) /* don't use changing file as future fuzzy basis */
-			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
+			FFLAGS(fuzzy_dirlist->files[j]) |= FLAG_NO_FUZZY;
 	}
 
 	/* open the file */
--- orig/hlink.c	2006-01-14 20:27:09
+++ hlink.c	2006-01-24 19:17:58
@@ -26,6 +26,7 @@ extern int link_dest;
 extern int make_backups;
 extern int log_format_has_i;
 extern char *basis_dir[];
+extern unsigned int file_struct_len;
 extern struct file_list *the_file_list;
 
 #ifdef SUPPORT_HARD_LINKS
@@ -86,10 +87,10 @@ static void link_idev_data(void)
 			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
 			    struct hlink, 1, "hlink_list");
 
-			FPTR(head)->flags |= FLAG_HLINK_TOL;
+			FFLAGS(FPTR(head)) |= FLAG_HLINK_TOL;
 			FPTR(cur)->F_HLINDEX = to;
 			FPTR(cur)->F_NEXT = head;
-			FPTR(cur)->flags |= FLAG_HLINK_EOL;
+			FFLAGS(FPTR(cur)) |= FLAG_HLINK_EOL;
 			hlink_list[to++] = head;
 		} else
 			FPTR(cur)->link_u.links = NULL;
@@ -175,7 +176,7 @@ int hard_link_check(struct file_struct *
 {
 #ifdef SUPPORT_HARD_LINKS
 	int head;
-	if (skip && !(file->flags & FLAG_HLINK_EOL))
+	if (skip && !(FFLAGS(file) & FLAG_HLINK_EOL))
 		head = hlink_list[file->F_HLINDEX] = file->F_NEXT;
 	else
 		head = hlink_list[file->F_HLINDEX];
@@ -270,8 +271,8 @@ void hard_link_cluster(struct file_struc
 	file->F_HLINDEX = FINISHED_LINK;
 	if (link_stat(f_name(file, hlink1), &st1, 0) < 0)
 		return;
-	if (!(file->flags & FLAG_HLINK_TOL)) {
-		while (!(file->flags & FLAG_HLINK_EOL)) {
+	if (!(FFLAGS(file) & FLAG_HLINK_TOL)) {
+		while (!(FFLAGS(file) & FLAG_HLINK_EOL)) {
 			ndx = file->F_NEXT;
 			file = FPTR(ndx);
 		}
@@ -286,6 +287,6 @@ void hard_link_cluster(struct file_struc
 		maybe_hard_link(file, ndx, hlink2, statret, &st2,
 				hlink1, &st1, itemizing, code);
 		file->F_HLINDEX = FINISHED_LINK;
-	} while (!(file->flags & FLAG_HLINK_EOL));
+	} while (!(FFLAGS(file) & FLAG_HLINK_EOL));
 #endif
 }
--- orig/log.c	2006-02-05 04:53:34
+++ log.c	2006-01-24 22:50:01
@@ -41,6 +41,7 @@ extern int module_id;
 extern int msg_fd_out;
 extern int protocol_version;
 extern int preserve_times;
+extern int preserve_atimes;
 extern int log_format_has_i;
 extern int log_format_has_o_or_i;
 extern int daemon_log_format_has_o_or_i;
@@ -607,10 +608,12 @@ static void log_formatted(enum logcode c
 			n[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
 			n[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
 			     : !preserve_times || S_ISLNK(file->mode) ? 'T' : 't';
-			n[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
-			n[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
-			n[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
-			n[8] = '\0';
+			n[5] = !(iflags & ITEM_REPORT_ATIME) ? '.'
+			     : S_ISLNK(file->mode) ? 'U' : 'u';
+			n[6] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
+			n[7] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
+			n[8] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
+			n[9] = '\0';
 
 			if (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {
 				char ch = iflags & ITEM_IS_NEW ? '+' : '?';
--- orig/options.c	2006-02-03 23:51:57
+++ options.c	2006-01-31 03:08:39
@@ -52,6 +52,7 @@ int preserve_uid = 0;
 int preserve_gid = 0;
 int preserve_times = 0;
 int omit_dir_times = 0;
+int preserve_atimes = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
@@ -299,8 +300,9 @@ void usage(enum logcode F)
   rprintf(F,"     --devices               preserve device files (super-user only)\n");
   rprintf(F,"     --specials              preserve special files\n");
   rprintf(F," -D                          same as --devices --specials\n");
-  rprintf(F," -t, --times                 preserve times\n");
-  rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
+  rprintf(F," -t, --times                 preserve modify times\n");
+  rprintf(F," -O, --omit-dir-times        omit directories when preserving modify times\n");
+  rprintf(F," -U, --atimes                preserve access (use) times\n");
   rprintf(F,"     --super                 receiver attempts super-user activities\n");
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
@@ -412,6 +414,9 @@ static struct poptOption long_options[] 
   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+  {"atimes",          'U', POPT_ARG_VAL,    &preserve_atimes, 1, 0, 0 },
+  {"no-atimes",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
+  {"no-k",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
   {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
@@ -1505,6 +1510,8 @@ void server_options(char **args,int *arg
 		argstr[x++] = 'D';
 	if (preserve_times)
 		argstr[x++] = 't';
+	if (preserve_atimes)
+		argstr[x++] = 'U';
 	if (preserve_perms)
 		argstr[x++] = 'p';
 	else if (preserve_executability && am_sender)
--- orig/rsync.c	2006-02-05 15:31:49
+++ rsync.c	2006-01-31 03:00:22
@@ -37,6 +37,7 @@ extern int preserve_perms;
 extern int preserve_executability;
 extern int preserve_times;
 extern int omit_dir_times;
+extern int preserve_atimes;
 extern int orig_umask;
 extern int am_root;
 extern int am_server;
@@ -116,6 +117,7 @@ int set_file_attrs(char *fname, struct f
 	int updated = 0;
 	STRUCT_STAT st2;
 	int change_uid, change_gid;
+	time_t atime, mtime;
 
 	if (!st) {
 		if (dry_run)
@@ -134,18 +136,33 @@ int set_file_attrs(char *fname, struct f
 		}
 	}
 
+	/* This code must be the first update in the function due to
+	 * how it uses the "updated" variable. */
 	if (!preserve_times || (S_ISDIR(st->st_mode) && omit_dir_times))
 		flags |= ATTRS_SKIP_MTIME;
+	if (!preserve_atimes || S_ISDIR(st->st_mode))
+		flags |= ATTRS_SKIP_ATIME;
 	if (!(flags & ATTRS_SKIP_MTIME)
-	    && cmp_modtime(st->st_mtime, file->modtime) != 0) {
-		int ret = set_modtime(fname, file->modtime, st->st_mode);
+	    && cmp_time(st->st_mtime, file->modtime) != 0) {
+		mtime = file->modtime;
+		updated = 1;
+	} else
+		mtime = st->st_mtime;
+	if (!(flags & ATTRS_SKIP_ATIME)
+	    && cmp_time(st->st_atime, file->atime) != 0) {
+		atime = file->atime;
+		updated = 1;
+	} else
+		atime = st->st_atime;
+	if (updated) {
+		int ret = set_times(fname, mtime, atime, st->st_mode);
 		if (ret < 0) {
 			rsyserr(FERROR, errno, "failed to set times on %s",
 				full_fname(fname));
 			return 0;
 		}
-		if (ret == 0) /* ret == 1 if symlink could not be set */
-			updated = 1;
+		if (ret > 0) /* ret == 1 if symlink could not be set */
+			updated = 0;
 	}
 
 	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
--- orig/rsync.h	2006-02-03 20:00:36
+++ rsync.h	2006-01-24 22:38:08
@@ -54,6 +54,7 @@
 #define XMIT_HAS_IDEV_DATA (1<<9)
 #define XMIT_SAME_DEV (1<<10)
 #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
+#define XMIT_SAME_ATIME (1<<12)
 
 /* These flags are used in the live flist data. */
 
@@ -119,6 +120,7 @@
 
 #define ATTRS_REPORT		(1<<0)
 #define ATTRS_SKIP_MTIME	(1<<1)
+#define ATTRS_SKIP_ATIME	(1<<2)
 
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
@@ -135,6 +137,7 @@
 #define FNAMECMP_FUZZY		0x83
 
 /* For use by the itemize_changes code */
+#define ITEM_REPORT_ATIME (1<<0)
 #define ITEM_REPORT_CHECKSUM (1<<1)
 #define ITEM_REPORT_SIZE (1<<2)
 #define ITEM_REPORT_TIME (1<<3)
@@ -520,9 +523,12 @@ struct file_struct {
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
-	uchar flags;	/* this item MUST remain last */
+	time_t atime;   /* this MUST be second to last */
+	uchar fl4g5;	/* this item MUST remain last */
 };
 
+#define FFLAGS(f) ((uchar*)(f))[file_struct_len-1]
+
 /*
  * Start the flist array at FLIST_START entries and grow it
  * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR
--- orig/rsync.yo	2006-02-05 15:31:49
+++ rsync.yo	2006-01-31 03:06:45
@@ -323,8 +323,9 @@ to the detailed description below for a 
      --devices               preserve device files (super-user only)
      --specials              preserve special files
  -D                          same as --devices --specials
- -t, --times                 preserve times
- -O, --omit-dir-times        omit directories when preserving times
+ -t, --times                 preserve modify times
+ -O, --omit-dir-times        omit directories when preserving mod-times
+ -U, --atimes                preserve access (use) times
      --super                 receiver attempts super-user activities
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
@@ -800,6 +801,12 @@ it is preserving modification times (see
 the directories on the receiving side, it is a good idea to use bf(-O).
 This option is inferred if you use bf(--backup) without bf(--backup-dir).
 
+dit(bf(-U, --atimes)) This tells rsync to set the access (use) times of the
+destination files to the same value as the source files.  Note that the
+reading of the source file may update the atime of the source files, so
+repeated rsync runs with --atimes may be needed if you want to force the
+access-time values to be 100% identical on the two systems.
+
 dit(bf(--super)) This tells the receiving side to attempt super-user
 activities even if the receiving rsync wasn't run by the super-user.  These
 activities include: preserving users via the bf(--owner) option, preserving
@@ -1307,8 +1314,8 @@ if the receiving rsync is at least versi
 with older versions of rsync, but that also turns on the output of other
 verbose messages).
 
-The "%i" escape has a cryptic output that is 8 letters long.  The general
-format is like the string bf(YXcstpog), where bf(Y) is replaced by the
+The "%i" escape has a cryptic output that is 9 letters long.  The general
+format is like the string bf(YXcstupog), where bf(Y) is replaced by the
 kind of update being done, bf(X) is replaced by the file-type, and the
 other letters represent attributes that may be output if they are being
 modified.
@@ -1348,9 +1355,13 @@ quote(itemize(
   by the file transfer.
   it() A bf(t) means the modification time is different and is being updated
   to the sender's value (requires bf(--times)).  An alternate value of bf(T)
-  means that the time will be set to the transfer time, which happens
+  means that the modify time will be set to the transfer time, which happens
   anytime a symlink is transferred, or when a file or device is transferred
   without bf(--times).
+  it() A bf(u) means the access (use) time is different and is being updated to
+  the sender's value (requires bf(--atimes)).  An alternate value of bf(U)
+  means that the access time will be set to the transfer time, which happens
+  anytime a symlink is transferred.
   it() A bf(p) means the permissions are different and are being updated to
   the sender's value (requires bf(--perms)).
   it() An bf(o) means the owner is different and is being updated to the
--- orig/sender.c	2006-01-14 20:27:10
+++ sender.c	2006-01-24 18:10:23
@@ -38,6 +38,7 @@ extern int do_progress;
 extern int inplace;
 extern int batch_fd;
 extern int write_batch;
+extern unsigned int file_struct_len;
 extern struct stats stats;
 extern struct file_list *the_file_list;
 extern char *log_format;
@@ -126,7 +127,7 @@ void successful_send(int ndx)
 
 	file = the_file_list->files[ndx];
 	/* The generator might tell us about symlinks we didn't send. */
-	if (!(file->flags & FLAG_SENT) && !S_ISLNK(file->mode))
+	if (!(FFLAGS(file) & FLAG_SENT) && !S_ISLNK(file->mode))
 		return;
 	if (file->dir.root) {
 		offset = stringjoin(fname, sizeof fname,
@@ -370,7 +371,7 @@ void send_files(struct file_list *flist,
 			rprintf(FINFO, "sender finished %s\n", fname);
 
 		/* Flag that we actually sent this entry. */
-		file->flags |= FLAG_SENT;
+		FFLAGS(file) |= FLAG_SENT;
 	}
 	make_backups = save_make_backups;
 
--- orig/testsuite/atimes.test	2006-01-24 22:54:53
+++ testsuite/atimes.test	2006-01-24 22:54:53
@@ -0,0 +1,19 @@
+#! /bin/sh
+
+# Test rsync copying atimes
+
+. "$suitedir/rsync.fns"
+
+set -x
+
+mkdir "$fromdir"
+
+touch "$fromdir/foo"
+touch -a -t 200102031717.42 "$fromdir/foo"
+
+TLS_ARGS=--atime
+
+checkit "$RSYNC -rtUgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+
+# The script would have aborted on error, so getting here means we've won.
+exit 0
--- orig/testsuite/devices.test	2006-01-30 08:12:44
+++ testsuite/devices.test	2006-01-26 10:53:43
@@ -42,14 +42,14 @@ touch -r "$fromdir/block" "$fromdir/bloc
 $RSYNC -ai "$fromdir/block" "$todir/block2" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD++++++ block
+cD+++++++ block
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
 
 $RSYNC -ai "$fromdir/block2" "$todir/block" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD++++++ block2
+cD+++++++ block2
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
 
@@ -58,7 +58,7 @@ sleep 1
 $RSYNC -Di "$fromdir/block3" "$todir/block" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD..T... block3
+cD..T.... block3
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
@@ -66,15 +66,15 @@ $RSYNC -aiHvv "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d..t... ./
-cD..t... block
-cD...... block2
-cD++++++ block3
-hD++++++ block2.5 => block3
-cD++++++ char
-cD++++++ char2
-cD++++++ char3
-cS++++++ fifo
+.d..t.... ./
+cD..t.... block
+cD....... block2
+cD+++++++ block3
+hD+++++++ block2.5 => block3
+cD+++++++ char
+cD+++++++ char2
+cD+++++++ char3
+cS+++++++ fifo
 EOT
 if test ! -b "$fromdir/block2.5"; then
     sed -e '/block2\.5/d' \
--- orig/testsuite/itemize.test	2006-02-04 19:52:05
+++ testsuite/itemize.test	2006-01-24 22:32:03
@@ -29,14 +29,14 @@ ln "$fromdir/foo/config1" "$fromdir/foo/
 $RSYNC -iplr "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cd++++++ bar/
-cd++++++ bar/baz/
->f++++++ bar/baz/rsync
-cd++++++ foo/
->f++++++ foo/config1
->f++++++ foo/config2
->f++++++ foo/extra
-cL++++++ foo/sym -> ../bar/baz/rsync
+cd+++++++ bar/
+cd+++++++ bar/baz/
+>f+++++++ bar/baz/rsync
+cd+++++++ foo/
+>f+++++++ foo/config1
+>f+++++++ foo/config2
+>f+++++++ foo/extra
+cL+++++++ foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
 
@@ -48,10 +48,10 @@ chmod 601 "$fromdir/foo/config2"
 $RSYNC -iplrH "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
->f..T... bar/baz/rsync
->f..T... foo/config1
->f.sTp.. foo/config2
-hf..T... foo/extra => foo/config1
+>f..T.... bar/baz/rsync
+>f..T.... foo/config1
+>f.sT.p.. foo/config2
+hf..T.... foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
 
@@ -68,11 +68,11 @@ chmod 777 "$todir/bar/baz/rsync"
 $RSYNC -iplrtc "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.f..tp.. bar/baz/rsync
-.d..t... foo/
-.f..t... foo/config1
->fcstp.. foo/config2
-cL..T... foo/sym -> ../bar/baz/rsync
+.f..t.p.. bar/baz/rsync
+.d..t.... foo/
+.f..t.... foo/config1
+>fcst.p.. foo/config2
+cL..T.... foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
@@ -97,15 +97,15 @@ $RSYNC -ivvplrtH "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d       ./
-.d       bar/
-.d       bar/baz/
-.f...p.. bar/baz/rsync
-.d       foo/
-.f       foo/config1
->f..t... foo/config2
-hf       foo/extra
-.L       foo/sym -> ../bar/baz/rsync
+.d        ./
+.d        bar/
+.d        bar/baz/
+.f....p.. bar/baz/rsync
+.d        foo/
+.f        foo/config1
+>f..t.... foo/config2
+hf        foo/extra
+.L        foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 5 failed"
 
@@ -124,8 +124,8 @@ touch "$todir/foo/config2"
 $RSYNC -iplrtH "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.f...p.. foo/config1
->f..t... foo/config2
+.f....p.. foo/config1
+>f..t.... foo/config2
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 7 failed"
 
@@ -134,15 +134,15 @@ $RSYNC -ivvplrtH --copy-dest="$lddir" "$
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-cf       bar/baz/rsync
-cd++++++ foo/
-cf       foo/config1
-cf       foo/config2
-hf       foo/extra => foo/config1
-cL..T... foo/sym -> ../bar/baz/rsync
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cf        bar/baz/rsync
+cd+++++++ foo/
+cf        foo/config1
+cf        foo/config2
+hf        foo/extra => foo/config1
+cL..T.... foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 8 failed"
 
@@ -150,11 +150,11 @@ rm -rf "$todir"
 $RSYNC -iplrtH --copy-dest="$lddir" "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-cd++++++ foo/
-hf       foo/extra => foo/config1
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cd+++++++ foo/
+hf        foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 9 failed"
 
@@ -181,15 +181,15 @@ $RSYNC -ivvplrtH --link-dest="$lddir" "$
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-hf       bar/baz/rsync
-cd++++++ foo/
-hf       foo/config1
-hf       foo/config2
-hf       foo/extra => foo/config1
-hL       foo/sym -> ../bar/baz/rsync
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+hf        bar/baz/rsync
+cd+++++++ foo/
+hf        foo/config1
+hf        foo/config2
+hf        foo/extra => foo/config1
+hL        foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 11 failed"
 
@@ -197,10 +197,10 @@ rm -rf "$todir"
 $RSYNC -iplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-cd++++++ foo/
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cd+++++++ foo/
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 12 failed"
 
@@ -228,14 +228,14 @@ filter_outfile
 # TODO fix really-old problem when combining -H with --compare-dest:
 # missing output for foo/extra hard-link (and it might not be updated)!
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-.f       bar/baz/rsync
-cd++++++ foo/
-.f       foo/config1
-.f       foo/config2
-.L       foo/sym -> ../bar/baz/rsync
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+.f        bar/baz/rsync
+cd+++++++ foo/
+.f        foo/config1
+.f        foo/config2
+.L        foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 14 failed"
 
@@ -243,10 +243,10 @@ rm -rf "$todir"
 $RSYNC -iplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.d..t... ./
-cd++++++ bar/
-cd++++++ bar/baz/
-cd++++++ foo/
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cd+++++++ foo/
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 15 failed"
 
--- orig/testsuite/rsync.fns	2006-02-04 19:52:05
+++ testsuite/rsync.fns	2005-07-28 00:41:20
@@ -66,7 +66,7 @@ printmsg() {
 }
 
 rsync_ls_lR() {
-    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls"
+    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls" $TLS_ARGS
 }
 
 check_perms() {
@@ -184,6 +184,10 @@ checkit() {
     # We can just write everything to stdout/stderr, because the
     # wrapper hides it unless there is a problem.
 
+    if test x$TLS_ARGS = x--atime; then
+	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+    fi
+
     echo "Running: \"$1\""  
     eval "$1" 
     status=$?
@@ -191,10 +195,13 @@ checkit() {
 	failed="YES";
     fi
 
+    if test x$TLS_ARGS != x--atime; then
+	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+    fi
+
     echo "-------------"
     echo "check how the directory listings compare with diff:"
     echo ""
-    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
     ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
     diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
 
--- orig/tls.c	2005-09-24 17:40:31
+++ tls.c	2005-03-23 17:49:48
@@ -39,6 +39,7 @@
 
 
 #include "rsync.h"
+#include "popt.h"
 
 #define PROGRAM "tls"
 
@@ -48,6 +49,7 @@ int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
 
+static int display_atime = 0;
 
 static void failed(char const *what, char const *where)
 {
@@ -56,14 +58,29 @@ static void failed(char const *what, cha
 	exit(1);
 }
 
+static void storetime(char *dest, time_t t)
+{
+	if (t) {
+		struct tm *mt = gmtime(&t);
 
+		sprintf(dest, "%04d-%02d-%02d %02d:%02d:%02d ",
+			(int)mt->tm_year + 1900,
+			(int)mt->tm_mon + 1,
+			(int)mt->tm_mday,
+			(int)mt->tm_hour,
+			(int)mt->tm_min,
+			(int)mt->tm_sec);
+	} else {
+		strcpy(dest, "                    ");
+	}
+}	
 
 static void list_file(const char *fname)
 {
 	STRUCT_STAT buf;
 	char permbuf[PERMSTRING_SIZE];
-	struct tm *mt;
-	char datebuf[50];
+	char mtimebuf[50];
+	char atimebuf[50];
 	char linkbuf[4096];
 
 	if (do_lstat(fname, &buf) < 0)
@@ -96,19 +113,8 @@ static void list_file(const char *fname)
 
 	permstring(permbuf, buf.st_mode);
 
-	if (buf.st_mtime) {
-		mt = gmtime(&buf.st_mtime);
-
-		sprintf(datebuf, "%04d-%02d-%02d %02d:%02d:%02d",
-			(int)mt->tm_year + 1900,
-			(int)mt->tm_mon + 1,
-			(int)mt->tm_mday,
-			(int)mt->tm_hour,
-			(int)mt->tm_min,
-			(int)mt->tm_sec);
-	} else {
-		strcpy(datebuf, "                   ");
-	}
+	storetime(mtimebuf, buf.st_mtime);
+	storetime(atimebuf, buf.st_atime);
 
 	/* TODO: Perhaps escape special characters in fname? */
 
@@ -119,24 +125,55 @@ static void list_file(const char *fname)
 		    (long)minor(buf.st_rdev));
 	} else /* NB: use double for size since it might not fit in a long. */
 		printf("%12.0f", (double)buf.st_size);
-	printf(" %6ld.%-6ld %6ld %s %s%s\n",
+	printf(" %6ld.%-6ld %6ld %s%s%s%s\n",
 	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
-	       datebuf, fname, linkbuf);
+ 	       mtimebuf, display_atime && !S_ISDIR(buf.st_mode) ? atimebuf : "",
+	       fname, linkbuf);
 }
 
+static struct poptOption long_options[] = {
+  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
+  {"atime",           'u', POPT_ARG_NONE,   &display_atime, 0,   0, 0},
+  {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0},
+  {0,0,0,0,0,0,0}
+};
+
+static void tls_usage(int ret)
+{
+	fprintf(stderr, "usage: " PROGRAM " [--atime | -u] DIR ...\n"
+	    "Trivial file listing program for portably checking rsync\n");
+	exit(ret);
+}
 
 int
 main(int argc, char *argv[])
 {
-	if (argc < 2) {
-		fprintf(stderr, "usage: " PROGRAM " DIR ...\n"
-			"Trivial file listing program for portably checking rsync\n");
-		return 1;
+	poptContext pc;
+	const char **extra_args;
+	int opt;
+
+	pc = poptGetContext(PROGRAM, argc, (const char **)argv,
+			    long_options, 0);
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		switch (opt) {
+		case 'h':
+			tls_usage(0);
+		default:
+			fprintf(stderr,
+			        "%s: %s\n",
+				poptBadOption(pc, POPT_BADOPTION_NOALIAS),
+				poptStrerror(opt));
+			tls_usage(1);
+		}
 	}
 
-	for (argv++; *argv; argv++) {
-		list_file(*argv);
-	}
+	extra_args = poptGetArgs(pc);
+	if (*extra_args == NULL)
+		tls_usage(1);
+
+	for (; *extra_args; extra_args++)
+		list_file(*extra_args);
+	poptFreeContext(pc);
 
 	return 0;
 }
--- orig/util.c	2006-02-03 20:00:36
+++ util.c	2006-01-14 08:20:29
@@ -130,7 +130,7 @@ void overflow_exit(char *str)
 
 
 
-int set_modtime(char *fname, time_t modtime, mode_t mode)
+int set_times(char *fname, time_t modtime, time_t atime, mode_t mode)
 {
 #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
 	if (S_ISLNK(mode))
@@ -138,9 +138,13 @@ int set_modtime(char *fname, time_t modt
 #endif
 
 	if (verbose > 2) {
-		rprintf(FINFO, "set modtime of %s to (%ld) %s",
+		char mtimebuf[200];
+
+		strlcpy(mtimebuf, timestring(modtime), sizeof mtimebuf);
+		rprintf(FINFO,
+			"set modtime, atime of %s to (%ld) %s, (%ld) %s\n",
 			fname, (long)modtime,
-			asctime(localtime(&modtime)));
+			mtimebuf, (long)atime, timestring(atime));
 	}
 
 	if (dry_run)
@@ -149,7 +153,7 @@ int set_modtime(char *fname, time_t modt
 	{
 #ifdef HAVE_UTIMES
 		struct timeval t[2];
-		t[0].tv_sec = time(NULL);
+		t[0].tv_sec = atime;
 		t[0].tv_usec = 0;
 		t[1].tv_sec = modtime;
 		t[1].tv_usec = 0;
@@ -160,12 +164,12 @@ int set_modtime(char *fname, time_t modt
 		return utimes(fname, t);
 #elif defined HAVE_UTIMBUF
 		struct utimbuf tbuf;
-		tbuf.actime = time(NULL);
+		tbuf.actime = atime;
 		tbuf.modtime = modtime;
 		return utime(fname,&tbuf);
 #elif defined HAVE_UTIME
 		time_t t[2];
-		t[0] = time(NULL);
+		t[0] = atime;
 		t[1] = modtime;
 		return utime(fname,t);
 #else
@@ -1183,8 +1187,8 @@ int msleep(int t)
 
 
 /**
- * Determine if two file modification times are equivalent (either
- * exact or in the modification timestamp window established by
+ * Determine if two file  times are equivalent (either
+ * exact or in the timestamp window established by
  * --modify-window).
  *
  * @retval 0 if the times should be treated as the same
@@ -1193,7 +1197,7 @@ int msleep(int t)
  *
  * @retval -1 if the 2nd is later
  **/
-int cmp_modtime(time_t file1, time_t file2)
+int cmp_time(time_t file1, time_t file2)
 {
 	if (file2 > file1) {
 		if (file2 - file1 <= modify_window)
