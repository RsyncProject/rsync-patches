CAUTION:  This patch compiles, but is otherwise totally untested!

This patch also implements --times-only.

Implementation details for the --source-filter and -dest-filter options:

 - These options open a *HUGE* security hole in daemon mode unless they
   are refused in your rsyncd.conf!

 - Filtering disables rsync alogrithm. (This should be fixed.)

 - Source filter makes temporary files in /tmp. (Should be overridable.)

 - If source filter fails, data is send unfiltered. (Should be changed
   to abort.)

 - Failure of destination filter, causes data loss!!! (Should be changed
   to abort.)

 - If filter changes size of file, you should use --times-only option to
   prevent repeated transfers of unchanged files.

 - If the COMMAND contains single quotes, option-passing breaks.  (Needs
   to be fixed.)

To use this patch, run these commands for a successful build:

    patch -p1 <patches/source-filter_dest-filter.diff
    ./prepare-source
    ./configure                                (optional if already run)
    make

--- old/generator.c
+++ new/generator.c
@@ -61,6 +61,7 @@ extern int append_mode;
 extern int make_backups;
 extern int csum_length;
 extern int ignore_times;
+extern int times_only;
 extern int size_only;
 extern OFF_T max_size;
 extern OFF_T min_size;
@@ -619,7 +620,7 @@ void itemize(const char *fnamecmp, struc
 /* Perform our quick-check heuristic for determining if a file is unchanged. */
 int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
 {
-	if (st->st_size != F_LENGTH(file))
+	if (!times_only && st->st_size != F_LENGTH(file))
 		return 0;
 
 	/* if always checksum is set then we use the checksum instead
--- old/main.c
+++ new/main.c
@@ -132,7 +132,7 @@ pid_t wait_process(pid_t pid, int *statu
 }
 
 /* Wait for a process to exit, calling io_flush while waiting. */
-static void wait_process_with_flush(pid_t pid, int *exit_code_ptr)
+void wait_process_with_flush(pid_t pid, int *exit_code_ptr)
 {
 	pid_t waited_pid;
 	int status;
--- old/options.c
+++ new/options.c
@@ -102,6 +102,7 @@ int keep_partial = 0;
 int safe_symlinks = 0;
 int copy_unsafe_links = 0;
 int size_only = 0;
+int times_only = 0;
 int daemon_bwlimit = 0;
 int bwlimit = 0;
 int fuzzy_basis = 0;
@@ -159,6 +160,8 @@ char *logfile_name = NULL;
 char *logfile_format = NULL;
 char *stdout_format = NULL;
 char *password_file = NULL;
+char *source_filter = NULL;
+char *dest_filter = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
 char backup_dir_buf[MAXPATHLEN];
@@ -379,6 +382,7 @@ void usage(enum logcode F)
   rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
   rprintf(F,"     --size-only             skip files that match in size\n");
+  rprintf(F,"     --times-only            skip files that match in mod-time\n");
   rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
@@ -418,6 +422,8 @@ void usage(enum logcode F)
   rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
   rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
   rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
+  rprintf(F,"     --source-filter=COMMAND filter file through COMMAND at source\n");
+  rprintf(F,"     --dest-filter=COMMAND   filter file through COMMAND at destination\n");
   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 #ifdef ICONV_OPTION
   rprintf(F,"     --iconv=CONVERT_SPEC    request charset conversion of filesnames\n");
@@ -520,6 +526,7 @@ static struct poptOption long_options[] 
   {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
   {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
+  {"times-only",       0,  POPT_ARG_NONE,   &times_only , 0, 0, 0 },
   {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
   {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
@@ -619,6 +626,8 @@ static struct poptOption long_options[] 
   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
+  {"source-filter",    0,  POPT_ARG_STRING, &source_filter, 0, 0, 0 },
+  {"dest-filter",      0,  POPT_ARG_STRING, &dest_filter, 0, 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
   {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
   {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
@@ -1575,6 +1584,16 @@ int parse_arguments(int *argc_p, const c
 		}
 	}
 
+	if (source_filter || dest_filter) {
+		if (whole_file == 0) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--no-whole-file cannot be used with --%s-filter\n",
+				 source_filter ? "source" : "dest");
+			return 0;
+		}
+		whole_file = 1;
+	}
+
 	if (files_from) {
 		char *h, *p;
 		int q;
@@ -1895,6 +1914,25 @@ void server_options(char **args, int *ar
 		}
 	}
 
+	if (times_only && am_sender)
+		args[ac++] = "--times-only";
+
+	if (source_filter && !am_sender) {
+		/* Need to single quote the arg to keep the remote shell
+		 * from splitting it.  FIXME: breaks if command has single quotes. */
+	        if (asprintf(&arg, "--source-filter='%s'", source_filter) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
+
+	if (dest_filter && am_sender) {
+		/* Need to single quote the arg to keep the remote shell
+		 * from splitting it.  FIXME: breaks if command has single quotes. */
+	        if (asprintf(&arg, "--dest-filter='%s'", dest_filter) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
+
 	if (modify_window_set) {
 		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
 			goto oom;
--- old/pipe.c
+++ new/pipe.c
@@ -164,3 +164,77 @@ pid_t local_child(int argc, char **argv,
 
 	return pid;
 }
+
+pid_t run_filter(char *command[], int out, int *pipe_to_filter)
+{
+	pid_t pid;
+	int pipefds[2];
+	
+	if (verbose >= 2)
+		print_child_argv("opening connection using:", command);
+
+	if (pipe(pipefds) < 0) {
+		rsyserr(FERROR, errno, "pipe");
+		exit_cleanup(RERR_IPC);
+	}
+
+	pid = do_fork();
+	if (pid == -1) {
+		rsyserr(FERROR, errno, "fork");
+		exit_cleanup(RERR_IPC);
+	}
+
+	if (pid == 0) {
+		if (dup2(pipefds[0], STDIN_FILENO) < 0
+		 || close(pipefds[1]) < 0
+		 || dup2(out, STDOUT_FILENO) < 0) {
+			rsyserr(FERROR, errno, "Failed dup/close");
+			exit_cleanup(RERR_IPC);
+		}
+		umask(orig_umask);
+		set_blocking(STDIN_FILENO);
+		if (blocking_io)
+			set_blocking(STDOUT_FILENO);
+		execvp(command[0], command);
+		rsyserr(FERROR, errno, "Failed to exec %s", command[0]);
+		exit_cleanup(RERR_IPC);
+	}
+
+	if (close(pipefds[0]) < 0) {
+		rsyserr(FERROR, errno, "Failed to close");
+		exit_cleanup(RERR_IPC);
+	}
+
+	*pipe_to_filter = pipefds[1];
+
+	return pid;
+}
+
+pid_t run_filter_on_file(char *command[], int out, int in)
+{
+	pid_t pid;
+	
+	if (verbose >= 2)
+		print_child_argv("opening connection using:", command);
+
+	pid = do_fork();
+	if (pid == -1) {
+		rsyserr(FERROR, errno, "fork");
+		exit_cleanup(RERR_IPC);
+	}
+
+	if (pid == 0) {
+		if (dup2(in, STDIN_FILENO) < 0
+		 || dup2(out, STDOUT_FILENO) < 0) {
+			rsyserr(FERROR, errno, "Failed to dup2");
+			exit_cleanup(RERR_IPC);
+		}
+		if (blocking_io)
+			set_blocking(STDOUT_FILENO);
+		execvp(command[0], command);
+		rsyserr(FERROR, errno, "Failed to exec %s", command[0]);
+		exit_cleanup(RERR_IPC);
+	}
+
+	return pid;
+}
--- old/receiver.c
+++ new/receiver.c
@@ -52,6 +52,7 @@ extern int delay_updates;
 extern mode_t orig_umask;
 extern struct stats stats;
 extern char *tmpdir;
+extern char *dest_filter;
 extern char *partial_dir;
 extern char *basis_dir[];
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
@@ -357,6 +358,8 @@ int recv_files(int f_in, char *local_nam
 	const char *parent_dirname = "";
 #endif
 	int ndx, recv_ok;
+	pid_t pid = 0;
+	char *filter_argv[MAX_FILTER_ARGS + 1];
 
 	if (verbose > 2)
 		rprintf(FINFO, "recv_files(%d) starting\n", cur_flist->used);
@@ -366,6 +369,23 @@ int recv_files(int f_in, char *local_nam
 
 	updating_basis = inplace;
 
+	if (dest_filter) {
+		char *p;
+		char *sep = " \t";
+		int i;
+		for (p = strtok(dest_filter, sep), i = 0;
+		     p && i < MAX_FILTER_ARGS;
+		     p = strtok(0, sep))
+			filter_argv[i++] = p;
+		filter_argv[i] = NULL;
+		if (p) {
+			rprintf(FERROR,
+				"Too many arguments to dest-filter (> %d)\n",
+				MAX_FILTER_ARGS);
+			exit_cleanup(RERR_SYNTAX);
+		}
+	}
+
 	while (1) {
 		cleanup_disable();
 
@@ -663,6 +683,9 @@ int recv_files(int f_in, char *local_nam
 		else if (!am_server && verbose && do_progress)
 			rprintf(FINFO, "%s\n", fname);
 
+		if (dest_filter)
+			pid = run_filter(filter_argv, fd2, &fd2);
+
 		/* recv file data */
 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 				       fname, fd2, F_LENGTH(file));
@@ -677,6 +700,16 @@ int recv_files(int f_in, char *local_nam
 			exit_cleanup(RERR_FILEIO);
 		}
 
+		if (dest_filter) {
+			int status;
+			wait_process_with_flush(pid, &status);
+			if (status != 0) {
+				rprintf(FERROR, "filter %s exited code: %d\n",
+					dest_filter, status);
+				continue;
+			}
+		}
+
 		if ((recv_ok && (!delay_updates || !partialptr)) || inplace) {
 			char *temp_copy_name;
 			if (partialptr == fname)
--- old/rsync.h
+++ new/rsync.h
@@ -128,6 +128,7 @@
 #define IOERR_DEL_LIMIT (1<<2)
 
 #define MAX_ARGS 1000
+#define MAX_FILTER_ARGS 100
 #define MAX_BASIS_DIRS 20
 #define MAX_SERVER_ARGS (MAX_BASIS_DIRS*2 + 100)
 
--- old/rsync.yo
+++ new/rsync.yo
@@ -386,6 +386,7 @@ to the detailed description below for a 
      --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          don't skip files that match size and time
      --size-only             skip files that match in size
+     --times-only            skip files that match in mod-time
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
  -y, --fuzzy                 find similar file for basis if no dest file
@@ -424,6 +425,8 @@ to the detailed description below for a 
      --write-batch=FILE      write a batched update to FILE
      --only-write-batch=FILE like --write-batch but w/o updating dest
      --read-batch=FILE       read a batched update from FILE
+     --source-filter=COMMAND filter file through COMMAND at source
+     --dest-filter=COMMAND   filter file through COMMAND at destination
      --protocol=NUM          force an older protocol version to be used
      --iconv=CONVERT_SPEC    request charset conversion of filesnames
      --checksum-seed=NUM     set block/file checksum seed (advanced)
@@ -1936,6 +1939,33 @@ file previously generated by bf(--write-
 If em(FILE) is bf(-), the batch data will be read from standard input.
 See the "BATCH MODE" section for details.
 
+dit(bf(--source-filter=COMMAND)) This option allows the user to specify a
+filter program that will be applied to the contents of all transferred
+regular files before the data is sent to destination.  COMMAND will receive
+the data on its standard input and it should write the filtered data to
+standard output.  COMMAND should exit non-zero if it cannot process the
+data or if it encounters an error when writing the data to stdout.
+
+Example: --source-filter="gzip -9" will cause remote files to be
+compressed.
+Use of --source-filter automatically enables --whole-file.
+If your filter does not output the same number of bytes that it received on
+input, you should use --times-only to disable size and content checks on
+subsequent rsync runs.
+
+dit(bf(--dest-filter=COMMAND)) This option allows you to specify a filter
+program that will be applied to the contents of all transferred regular
+files before the data is written to disk.  COMMAND will receive the data on
+its standard input and it should write the filtered data to standard
+output.  COMMAND should exit non-zero if it cannot process the data or if
+it encounters an error when writing the data to stdout.
+
+Example: --dest-filter="gzip -9" will cause remote files to be compressed.
+Use of --dest-filter automatically enables --whole-file.
+If your filter does not output the same number of bytes that it
+received on input, you should use --times-only to disable size and
+content checks on subsequent rsync runs.
+
 dit(bf(--protocol=NUM)) Force an older protocol version to be used.  This
 is useful for creating a batch file that is compatible with an older
 version of rsync.  For instance, if rsync 2.6.4 is being used with the
--- old/sender.c
+++ new/sender.c
@@ -43,6 +43,7 @@ extern int do_progress;
 extern int inplace;
 extern int batch_fd;
 extern int write_batch;
+extern char *source_filter;
 extern struct stats stats;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 
@@ -181,6 +182,26 @@ void send_files(int f_in, int f_out)
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int f_xfer = write_batch < 0 ? batch_fd : f_out;
 	int ndx, j;
+	char *filter_argv[MAX_FILTER_ARGS + 1];
+	char *tmp = 0;
+	int unlink_tmp = 0;
+
+	if (source_filter) {
+		char *p;
+		char *sep = " \t";
+		int i;
+		for (p = strtok(source_filter, sep), i = 0;
+		     p && i < MAX_FILTER_ARGS;
+		     p = strtok(0, sep))
+			filter_argv[i++] = p;
+		filter_argv[i] = NULL;
+		if (p) {
+			rprintf(FERROR,
+				"Too many arguments to source-filter (> %d)\n",
+				MAX_FILTER_ARGS);
+			exit_cleanup(RERR_SYNTAX);
+		}
+	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_files starting\n");
@@ -284,6 +305,7 @@ void send_files(int f_in, int f_out)
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
+		unlink_tmp = 0;
 		fd = do_open(fname, O_RDONLY, 0);
 		if (fd == -1) {
 			if (errno == ENOENT) {
@@ -314,6 +336,33 @@ void send_files(int f_in, int f_out)
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
+		if (source_filter) {
+			int fd2;
+			char *tmpl = "/tmp/rsync-filtered_sourceXXXXXX";
+
+			tmp = strdup(tmpl);
+			fd2 = mkstemp(tmp);
+			if (fd2 == -1) {
+				rprintf(FERROR, "mkstemp %s failed: %s\n",
+					tmp, strerror(errno));
+			} else {
+				int status;
+				pid_t pid = run_filter_on_file(filter_argv, fd2, fd);
+				close(fd);
+				close(fd2);
+				wait_process_with_flush(pid, &status);
+				if (status != 0) {
+					rprintf(FERROR,
+					    "bypassing source filter %s; exited with code: %d\n",
+					    source_filter, status);
+					fd = do_open(fname, O_RDONLY, 0);
+				} else {
+					fd = do_open(tmp, O_RDONLY, 0);
+					unlink_tmp = 1;
+				}
+			}
+		}
+
 		if (st.st_size) {
 			int32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);
 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
@@ -355,6 +404,8 @@ void send_files(int f_in, int f_out)
 			}
 		}
 		close(fd);
+		if (unlink_tmp)
+			unlink(tmp);
 
 		free_sums(s);
 
