This patches creates two new command line options as follows:
	--backup-dir-dels=DIR
	--suffix-dels=SUFFIX

The backup-dir-dels and suffix-dels options give the ability to store
backup of removed files on the receiver in different directories or with
different suffix than the backup of files that have been changed but that
are still on the source drive.  Both commands can be combined.

The default behaviour if one or both of the options are not specified
is the previous behaviour, both backups use the same directory or
suffix.

Marc St-Onge

To use this patch, run these commands for a successful build:

    patch -p1 <patches/backup-dir-dels.diff
    ./configure                                 (optional if already run)
    make

diff --git a/backup.c b/backup.c
index 0da6b33..ff77078 100644
--- a/backup.c
+++ b/backup.c
@@ -29,10 +29,17 @@ extern int preserve_specials;
 extern int preserve_links;
 extern int safe_symlinks;
 extern int backup_dir_len;
+extern int backup_dir_dels_len;
 extern unsigned int backup_dir_remainder;
+extern unsigned int backup_dir_dels_remainder;
 extern char backup_dir_buf[MAXPATHLEN];
+extern char backup_dir_dels_buf[MAXPATHLEN];
 extern char *backup_suffix;
+extern char *backup_suffix_dels;
 extern char *backup_dir;
+extern char *backup_dir_dels;
+
+static BOOL deleting;
 
 /* make a complete pathname for backup file */
 char *get_backup_name(const char *fname)
@@ -51,6 +58,22 @@ char *get_backup_name(const char *fname)
 	return NULL;
 }
 
+static char *get_delete_name(const char *fname)
+{
+	if (backup_dir_dels) {
+		if (stringjoin(backup_dir_dels_buf + backup_dir_dels_len, backup_dir_dels_remainder,
+			       fname, backup_suffix_dels, NULL) < backup_dir_dels_remainder)
+			return backup_dir_dels_buf;
+	} else {
+		if (stringjoin(backup_dir_dels_buf, MAXPATHLEN,
+			       fname, backup_suffix_dels, NULL) < MAXPATHLEN)
+			return backup_dir_dels_buf;
+	}
+
+	rprintf(FERROR, "delete filename too long\n");
+	return NULL;
+}
+
 /****************************************************************************
 Create a directory given an absolute path, perms based upon another directory
 path
@@ -59,7 +82,7 @@ int make_bak_dir(const char *fullpath)
 {
 	char fbuf[MAXPATHLEN], *rel, *end, *p;
 	struct file_struct *file;
-	int len = backup_dir_len;
+	int len = deleting ? backup_dir_dels_len : backup_dir_len;
 	stat_x sx;
 
 	while (*fullpath == '.' && fullpath[1] == '/') {
@@ -179,7 +202,7 @@ int make_backup(const char *fname, BOOL prefer_rename)
 	stat_x sx;
 	struct file_struct *file;
 	int save_preserve_xattrs;
-	char *buf = get_backup_name(fname);
+	char *buf = deleting ? get_delete_name(fname) : get_backup_name(fname);
 	int ret = 0;
 
 	if (!buf)
@@ -341,3 +364,13 @@ int make_backup(const char *fname, BOOL prefer_rename)
 	}
 	return ret;
 }
+
+/* backup switch routine called only when backing-up removed file */
+int safe_delete(const char *fname)
+{
+	int ret;
+	deleting = 1;
+	ret = make_backup(fname, True);
+	deleting = 0;
+	return ret;
+}
diff --git a/delete.c b/delete.c
index 33fdd0e..31228d0 100644
--- a/delete.c
+++ b/delete.c
@@ -28,6 +28,9 @@ extern int max_delete;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
+extern char *backup_dir_dels;
+extern char *backup_suffix_dels;
+extern int backup_suffix_dels_len;
 extern uid_t our_uid;
 extern struct stats stats;
 
@@ -35,10 +38,14 @@ int ignore_perishable = 0;
 int non_perishable_cnt = 0;
 int skipped_deletes = 0;
 
+/* Function now compares both backup_suffix and backup_suffix_dels. */
 static inline int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
-	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
+	if (k > 0 && strcmp(fn+k, backup_suffix) == 0)
+		return 1;
+	k += backup_suffix_len - backup_suffix_dels_len;
+	return k > 0 && strcmp(fn+k, backup_suffix_dels) == 0;
 }
 
 /* The directory is about to be deleted: if DEL_RECURSE is given, delete all
@@ -170,9 +177,9 @@ enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
 		what = "rmdir";
 		ok = do_rmdir(fbuf) == 0;
 	} else {
-		if (make_backups > 0 && (backup_dir || !is_backup_file(fbuf))) {
+		if (make_backups > 0 && (backup_dir_dels || !is_backup_file(fbuf))) {
 			what = "make_backup";
-			ok = make_backup(fbuf, True);
+			ok = safe_delete(fbuf);
 			if (ok == 2) {
 				what = "unlink";
 				ok = robust_unlink(fbuf) == 0;
diff --git a/options.c b/options.c
index e7c6c61..37e4086 100644
--- a/options.c
+++ b/options.c
@@ -151,10 +151,14 @@ int no_detach
 int write_batch = 0;
 int read_batch = 0;
 int backup_dir_len = 0;
+int backup_dir_dels_len = 0;
 int backup_suffix_len;
+int backup_suffix_dels_len;
 unsigned int backup_dir_remainder;
+unsigned int backup_dir_dels_remainder;
 
 char *backup_suffix = NULL;
+char *backup_suffix_dels = NULL;
 char *tmpdir = NULL;
 char *partial_dir = NULL;
 char *basis_dir[MAX_BASIS_DIRS+1];
@@ -166,7 +170,9 @@ char *stdout_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
+char *backup_dir_dels = NULL;
 char backup_dir_buf[MAXPATHLEN];
+char backup_dir_dels_buf[MAXPATHLEN];
 char *sockopts = NULL;
 char *usermap = NULL;
 char *groupmap = NULL;
@@ -669,6 +675,8 @@ void usage(enum logcode F)
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
   rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
+  rprintf(F,"     --backup-dir-dels=DIR   backup removed files into hierarchy based in DIR\n");
+  rprintf(F,"     --suffix-dels=SUFFIX    set removed-files suffix (def. --suffix w/o b-d-d)\n");
   rprintf(F," -u, --update                skip files that are newer on the receiver\n");
   rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
   rprintf(F,"     --append                append data onto shorter files\n");
@@ -968,7 +976,9 @@ static struct poptOption long_options[] = {
   {"backup",          'b', POPT_ARG_VAL,    &make_backups, 1, 0, 0 },
   {"no-backup",        0,  POPT_ARG_VAL,    &make_backups, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
+  {"backup-dir-dels",  0,  POPT_ARG_STRING, &backup_dir_dels, 0, 0, 0 },
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
+  {"suffix-dels",      0,  POPT_ARG_STRING, &backup_suffix_dels, 0, 0, 0 },
   {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
   {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
   {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
@@ -1964,6 +1974,8 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0, SP_DEFAULT);
 		if (backup_dir)
 			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0, SP_DEFAULT);
+		if (backup_dir_dels)
+			backup_dir_dels = sanitize_path(NULL, backup_dir_dels, NULL, 0, SP_DEFAULT);
 	}
 	if (daemon_filter_list.head && !am_sender) {
 		struct filter_list_struct *elp = &daemon_filter_list;
@@ -1985,6 +1997,14 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 			if (check_filter(elp, FLOG, dir, 1) < 0)
 				goto options_rejected;
 		}
+		/* Clean backup_dir_dels same as for backup_dir */
+		if (backup_dir_dels) {
+			if (!*backup_dir_dels)
+				goto options_rejected;
+			clean_fname(backup_dir_dels, 1);
+			if (check_filter(elp, FLOG, backup_dir_dels, 1) < 0)
+				goto options_rejected;
+		}
 	}
 
 	if (!backup_suffix)
@@ -1996,6 +2016,20 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 			backup_suffix);
 		return 0;
 	}
+	/* --suffix-dels defaults to --suffix, or empty for a client given an
+	 * explicit --backup-dir-dels (just as --suffix defaults to empty when
+	 * a --backup-dir is given).  The second case does not apply to the
+	 * server for consistency with server_options, which sends --suffix-dels
+	 * to the server iff it differs from --suffix. */
+	if (!backup_suffix_dels)
+		backup_suffix_dels = backup_dir_dels && !am_server ? "" : backup_suffix;
+	backup_suffix_dels_len = strlen(backup_suffix_dels);
+	if (strchr(backup_suffix_dels, '/') != NULL) {
+		snprintf(err_buf, sizeof err_buf,
+			"--suffix-dels cannot contain slashes: %s\n",
+			backup_suffix_dels);
+		return 0;
+	}
 	if (backup_dir) {
 		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
 		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
@@ -2019,6 +2053,34 @@ int parse_arguments(int *argc_p, const char ***argv_p)
 			"P *%s", backup_suffix);
 		parse_rule(&filter_list, backup_dir_buf, 0, 0);
 	}
+	if (backup_dir_dels) {
+		backup_dir_dels_len = strlcpy(backup_dir_dels_buf, backup_dir_dels, sizeof backup_dir_dels_buf);
+		backup_dir_dels_remainder = sizeof backup_dir_dels_buf - backup_dir_dels_len;
+		if (backup_dir_dels_remainder < 32) {
+			snprintf(err_buf, sizeof err_buf,
+				"the --backup-dir-dels path is WAY too long.\n");
+			return 0;
+		}
+		if (backup_dir_dels_buf[backup_dir_dels_len - 1] != '/') {
+			backup_dir_dels_buf[backup_dir_dels_len++] = '/';
+			backup_dir_dels_buf[backup_dir_dels_len] = '\0';
+		}
+		if (INFO_GTE(BACKUP, 1) && !am_sender)
+			rprintf(FINFO, "backup_dir_dels is %s\n", backup_dir_dels_buf);
+	} else if (backup_dir) {
+		backup_dir_dels = backup_dir;
+		backup_dir_dels_len = backup_dir_len;
+		backup_dir_dels_remainder = backup_dir_remainder;
+		strlcpy(backup_dir_dels_buf, backup_dir_buf, sizeof backup_dir_buf);
+	} else if (!backup_suffix_dels_len && (!am_server || !am_sender)) {
+		snprintf(err_buf, sizeof err_buf,
+			"--suffix-dels cannot be a null string without --backup-dir-dels\n");
+		return 0;
+	} else if (make_backups && delete_mode && !delete_excluded && !am_server) {
+		snprintf(backup_dir_dels_buf, sizeof backup_dir_dels_buf,
+			"P *%s", backup_suffix_dels);
+		parse_rule(&filter_list, backup_dir_dels_buf, 0, 0);
+	}
 
 	if (make_backups && !backup_dir) {
 		omit_dir_times = 0; /* Implied, so avoid -O to sender. */
@@ -2432,6 +2494,10 @@ void server_options(char **args, int *argc_p)
 		args[ac++] = "--backup-dir";
 		args[ac++] = backup_dir;
 	}
+	if (backup_dir_dels && backup_dir_dels != backup_dir) {
+		args[ac++] = "--backup-dir-dels";
+		args[ac++] = backup_dir_dels;
+	}
 
 	/* Only send --suffix if it specifies a non-default value. */
 	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0) {
@@ -2440,7 +2506,14 @@ void server_options(char **args, int *argc_p)
 			goto oom;
 		args[ac++] = arg;
 	}
-
+	/* Only send --suffix-dels if it specifies a value different from the
+	 * --suffix value, which would normally be used for deletions too. */
+	if (strcmp(backup_suffix_dels, backup_suffix) != 0) {
+		/* We use the following syntax to avoid weirdness with '~'. */
+		if (asprintf(&arg, "--suffix-dels=%s", backup_suffix_dels) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
 	if (am_sender) {
 		if (max_delete > 0) {
 			if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
